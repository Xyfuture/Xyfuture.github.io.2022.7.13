<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Program | My New Hugo Site</title>

<meta name="keywords" content="" />
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://xyfuture.github.io/tags/program/" />
<link href="/assets/css/stylesheet.min.5c4f6d85b7abfcfea458637c672d16a7a9c38c37f002753cfdc7f314b6d3c8f2.css" integrity="sha256-XE9thber/P6kWGN8Zy0Wp6nDjDfwAnU8/cfzFLbTyPI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="http://xyfuture.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://xyfuture.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://xyfuture.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://xyfuture.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="http://xyfuture.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />
<link rel="alternate" type="application/rss&#43;xml" href="http://xyfuture.github.io/tags/program/index.xml">


<meta property="og:title" content="Program" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://xyfuture.github.io/tags/program/" />
<meta property="og:updated_time" content="2020-06-11T14:37:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Program"/>
<meta name="twitter:description" content=""/>



</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://xyfuture.github.io/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()"></ul>
    </nav>
</header>

    <main class="main"> 
<header class="page-header">
  <h1>Program</h1>
</header>



<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week8-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>homework A - 区间选点 II 题意 题面 题意很简单,就是给定一个区间,要求在每个区间内得取够给定个数的点(可以超过,但是不能少),问全局最少需要去多少个点
解法 本道题要求使用差分约束来解
差分约束首先要构建方程,找到用于一个表示X的量,这里使用一个数组dis,dis[i]代表从min到第i个点一共有多少个点(注意这里的min对应着题目中最小的区间端点),那么实际上我们求取的就是dis[max]的值(max代表给出的最大区间端点).
下面开始构建约束
对于给出的区间(i,j)要求k的点我们可以构建方程
$dis[j]-dis[i-1]\geq k$
除此之外为了使题目有意义我们得保证每个点只能被取0次或1次,因此需要方程约束
$0\leq dis[t]-dis[t-1]\leq 1$s
题目中使从0开的,我们给每个点都进行偏移,使整个数轴从1开始,那么我们还能知道$dis[0]=0\ or\ dis[min-1]=0$
综上我们知道了如下信息 $$ dis[min-1] =0\
dis[j]-dis[i]\geq k\
dis[t]-dis[t-1]\geq 0\
dis[t-1] - dis[t]\geq -1 $$ 我们要求的最少用多少个点,那么就是求取最大值最小,使用最长路求取,因为有负边权我们使用SPFA来求,鉴于本题一定有答案,不做负环的判断
求出最长路只需要换一下啊松弛条件就可以了
这道题复杂度同SPFA一样,O(KM)
code #include&lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;// #include &lt;algorithm&gt; #include &lt;queue&gt;#include &lt;cstring&gt; using namespace std; vector&lt;pair&lt;int,int&gt; &gt; G[50005];//图 queue&lt;int&gt; q;//队列 int dis[50005];//最大值,差分数组 int inque[50005];//是否在队列中 int main() { memset(dis,-128,sizeof(dis)); memset(inque,0,sizeof(inque)); int n; scanf(&#34;%d&#34;,&amp;n); int min = 50005,max = 0 ; for(int i=0;i&lt;n;i&#43;&#43;) { int a,b,c; scanf(&#34;%d%d%d&#34;,&amp;a,&amp;b,&amp;c); a&#43;=1,b&#43;=1;//把从0开始改为从1开始  if(a&lt;min) min = a;//起始位置  if(b&gt;max) max = b;//结束位置  G[a-1]....</p>
  </section>
  <footer class="entry-footer">April 15, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week8-homework" href="http://xyfuture.github.io/posts/program-week8-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program_week7_homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week7-homework A - TT 的魔法猫 题意 题面 这道题就是求一个传递闭包,题目中给出胜负关系可以看成一对序偶,相互之间具有传递关系,给出基本的几个序偶,然后让求取改集合的传递闭包,然后看看闭包中有多少个元素
解法 首先我们把这个输赢关系建成图,使用二维矩阵直接存储这个图,N个人代表矩阵大小是N*N,M个关系则代表图中有M条边,A B,代表A赢过B,建立一条A到B的边,如果B能到C则也有A到C的边
将图按照给定的元素初始化后我们对这张图跑floyd-warshall.不过要把松弛条件改一下,不是最短路径了,而是只要能到达则将数组中对应的位置改为1.
注意在这种情况下能够进行剪枝,如果在判断i经过j能能不能到达新节点时,若i直接不能到达j,则跳过.经过剪枝后时间复杂度会降低不少.
最后计算未知的数量,首先使用组合的知识计算出多少场比赛$C^2_n$,减去矩阵中1的数量,这样就能得到未知的场数
code #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt; using namespace std; // vector&lt;int&gt; G[502]; int G[502][502];//二维矩阵  int main() { int cnt; scanf(&#34;%d&#34;,&amp;cnt); for (int i=0;i&lt;cnt;i&#43;&#43;) { int n,m; scanf(&#34;%d%d&#34;,&amp;n,&amp;m); memset(G,0,sizeof(G));//初始化  for(int j=0;j&lt;m;j&#43;&#43;) { int a,b; scanf(&#34;%d%d&#34;,&amp;a,&amp;b); G[a][b] = 1;//A赢B,A-&gt;B的路  } for(int k=0;k&lt;n&#43;1;k&#43;&#43;)//经过第k个  for(int t=0;t&lt;n&#43;1;t&#43;&#43;) if(G[t][k]==1)//剪枝,不能到达就不继续了,正常floyd也可以有  for(int e=0;e&lt;n&#43;1;e&#43;&#43;) if(G[k][e]==1)//更新,可能会重复,但不影响正确  G[t][e] = 1; int ans = 0; for(int p=0;p&lt;n&#43;1;p&#43;&#43;) for(int q=0;q&lt;n&#43;1;q&#43;&#43;) if(G[p][q] == 1) ans&#43;&#43;;//统计已知场数  ans = ((n*(n-1))/2 ) - ans; printf(&#34;%d\n&#34;,ans); } } 总结 这道题一开始交的时候没有考虑剪枝的情况(虽然上课讲了),然后就T了,后来想起来可以剪枝降低复杂度,就加了剪枝,然后就过了,以后还是要写带剪枝的floyd....</p>
  </section>
  <footer class="entry-footer">April 13, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program_week7_homework" href="http://xyfuture.github.io/posts/program-week7-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week6-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week6-csp A - 掌握魔法の东东 II 题意 给定一组扑克牌,每张牌拥有两个属性,花色和大小,不存在完全相同的两张牌.首先取两张,了解其花色和大小,然后再取三张牌,问问总共的5张牌,在9种情况中各有多少
解法 这道题有两种解法,一种思路是搜索,用DFS搜索一遍,每次在5张牌时判断目前的五张牌是什么情况,对应的情况计数增加.第二种解法是直接用排列组合的方式直接计算出每种情况的个数.
这道题我是用第二种方法做的,首先写一个用于计算组合数的函数,用它来计算组合数.设牌的大小是1-n,花色有m种
 首先判断两张牌花色相同且相差不大于4,然后找到上下界,在上下界中找出大小为5的窗口有几个就行了 和上一个差不多,但是不判断花色了,然后后摸的三张牌颜色要进行组合最后要减去1的数量 判断两张牌的花色是否相同,相同的话,直接$C_{n-2}^3$就行了,最后减1中的 首先判断总的花色数,必须等于4,判断两张牌大小是否相等,相等的话只有一张牌是自由的,那么一共有(n-1)*m种可能,否则没有牌是自由的,只有两种可能 首先判断m是不是大于等于3,然后分成两类,一类是先摸的两张牌大小相同,这种情况下在分为先摸的牌为2和先摸的牌为3再次讨论,如果两张牌(A,B)大小不同则按A为2,B为3和A为3,B为2讨论,这两种情况是一样的,直接*2就行 这个也是先判断花色总数,然后分为先摸牌相等和不等两种情况,第二种情况下还要判断先摸的两张牌都是对,还是一个是1一个是对 注意这里的3张大小相同要求剩下的两张必须不同.同样先判断花色总数,之后分为先摸牌相等和不等讨论.在进一步的讨论中,还要分出3,1,1具体对应的是哪个 同样,2张相同的,3张不同的.剩下的方法也是相似的,看花色总数,分成先摸牌相等和不等讨论,进一步的讨论中分清楚2,1,1,1分别是那个 计算出总的情况数,减去上面的就行了  这种方法实在是太麻烦了,搜索的方法会简单很多,因为判断条件要比排列组合好写太多
code #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std; int ans[10];//1 start int A,B;//A是牌的总大小,B是牌的花色数 pair&lt;int,int&gt; curCard[2];//记录先摸的两张牌 int comb(int a,int b)//计算组合数 { int answer = 1; for(int i=0;i&lt;b;i&#43;&#43;) answer*=(a-i); for(int i=0;i&lt;b;i&#43;&#43;) answer/=(i&#43;1); if(answer&lt;0) return 0; return answer; } void con1() { if(curCard[0].second!=curCard[1].second||abs(curCard[0].first-curCard[1].first)&gt;4) return ; int max = curCard[0].first&gt;curCard[1].first?curCard[0].first:curCard[1].first;//取出两张牌中大的和小的  int min = curCard[0]....</p>
  </section>
  <footer class="entry-footer">March 28, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week6-homework" href="http://xyfuture.github.io/posts/program-week6-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week5-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week5-homework A-最大矩形 题意 给定一个直方图,求取直方图中规则的矩形的最大面积,其中直方图中间隔都是1,每个间隔的高度都是现场给定的.
解法 使用单调栈
对于每个间隔p,我们都在左边和右边找到第一个小于该间隔高度的间隔(如果相等则继续,不停止),在这两个边界之中,高度取p的高度建立的矩形是以p为高度的最大矩形,遍历一遍所有间隔就能获得整个图形中的最大矩形面积
求取左右的端点就是用单调栈实现,单调栈中保存的是从开始到现在所有的信息.对于一个出栈顺序是从小到大的单调栈而言,当一个元素弹出时,遇到的一定是第一个比他大的元素,因为假如之前遇到过比他的元素它早就被弹出了.反过来的顺序就是第一个它小的元素,我们大到小出栈顺序设计单调栈就可以实现我们上面的需求了.右边第一个是从0间隔到n间隔,左边第一个是从n间隔到0间隔 复杂度就是遍历一遍的大小$O(n)$
code #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std; int data[100004];//所有间隔的高度 int s[100004];//栈 int top = -1;//栈顶 pair&lt;int,int&gt; arr[100004];//左边第一个和右边第一个的坐标 int main() { int n; memset(data,0,sizeof(data)); memset(s,0,sizeof(s)); memset(arr,0,sizeof(arr)); while(true) { scanf(&#34;%d&#34;,&amp;n); if (n == 0) return 0; // data[0]=0,data[n&#43;1]=0;  for(int i=0;i&lt;n;i&#43;&#43;) scanf(&#34;%d&#34;,data&#43;i);//录入元素  for(int i=0;i&lt;n;i&#43;&#43;)//找到右边第一个小于的坐标  { while(top!=-1 &amp;&amp; data[s[top]]&gt;data[i])//不满足条件就出栈,同时更新出栈元素的边界  arr[s[top--]].second = i; s[&#43;&#43;top] = i;//新元素入栈  } while(top!=-1)//走到头把所有元素出栈  arr[s[top--]].second = n; top = -1;//重新开始栈  for(int i=n-1;i&gt;=0;i--)//左边第一个元素坐标,操作相同  { while(top!...</p>
  </section>
  <footer class="entry-footer">March 24, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week5-homework" href="http://xyfuture.github.io/posts/program-week5-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week4-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week3-CSP A-咕咕东的奇遇 题意 该题算是一个贪心问题,在一个环(26个数)上布置有序的数字,环上有一个指针,然后给定一个数字序列,要求转动圆环,使得指针指向给定的数字,要求总的转动的次数最少.题目中的不是数字而是字母,不过无所谓,ascii直接转换就行
解法 我们使用贪心的方案,每一次都找到从当前位置到指定位置的最短路径,最短路径只有两种可能,顺时针转过去或者逆时针转过去.在环上本身就是mod26系统,因此让大数减小数是一种,小数加26减大数是另一种,那个小取那个
code #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std; int main() { char s [10002];//数组开大 	memset(s,0,sizeof(s)); scanf(&#34;%s&#34;,s); int count=0;//总和 	int i = 0; char temp; int posi = 0; int maxShift = 0; while((temp=s[i])!=&#39;\0&#39;)//判断截止 	{ int cur = temp-&#39;a&#39;; if(cur&gt;posi) { int left = cur- posi;//一种方向 	int right = posi&#43;26 -cur;//另一种方向 	count&#43;=(left&gt;right? right:left);//取最小 	} if(cur&lt;=posi) { int left = cur&#43;26 - posi; int right = posi-cur; count&#43;= (left&gt;right?...</p>
  </section>
  <footer class="entry-footer">March 15, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week4-homework" href="http://xyfuture.github.io/posts/program-week4-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-二分
    </h2>
  </header>
  <section class="entry-content">
    <p>二分算法是一种性能优秀的算法,常常用在有序的序列上
二分分为三种,整数二分,浮点二分,答案二分
 整数二分 整数二分类似找数问题,在数组中找到指定元素开始的位置和结束的位置
上述代码是找到第一个大于等于x的点,也就是x开始的位置.(有好几个连续的x就是最先的x的下标)
下面是镜像算法,找出x结束的位置
当然这个写法比较麻烦,也可以第一种写法一样把&lt;和=合在一起
算法证明 这个证明有点意思,改天一定写写,用数学归纳法或者反正法都可以证明,把&lt;和=结合起来也挺秒的
一些思想 运用条件很简单,只要上线性的,然后有序就行
浮点二分 浮点二分是数学上的问题,这里不讨论很多,可以去看看零点定理,连续的函数在一个区间中有正有负,那么就是有零点,确定两个边界用零点存在定理算就完事了,注意精度的问题,建议是用固定的运算次数来保证精度
答案二分  结合一个题说一下,这个应该是用的比较多的
题目原题:POJ 3579
 答案如果是在一个区间内有序,我们就可以使用二分来查找
题目 暴力肯定是不行,算出B全部值的复杂度是$n^2$数据范围不过
但是我们注意到求中位数是从有序序列中找,因此可以二分找
我们首先将这个X数组排序,排序之后生成的B和不排序的是等价的(因为绝对值),然后用这个X参与后续计算
B的最小值肯定不小于0(不是B[1]-B[0]),最大值是B[n*(n-1)/2 -1]- B[0],因此我们就从这个区间中开始搜索,找到一个mid后问题就是判断和中位数关系,大于就缩小最大值,小于就提升最小值,一直这样下去直到最大值小于最小值(类似前面整数的操作,后面会再解释)
问题来了,如何确定中位数,最简单的方法,两个for看看有多少个X[j]-X[i]小于等于mid(找出最后一个mid的位置),但是复杂度会超,因此用二分的方法看看有多少个元素.
X[j]-X[i],对i的循环不变,对j用二分,从i&#43;1到n-1二分,这个过程中用到了整数二分中算法
cur是找的目标,找到最后一个cur的位置,e中存的是再B中cur的位置(从1开始算)
这样话我们直到中位数的位置,也知道mid的位置,就能知道mid是不是中位数,让我们再回到第一个二分,即便我们知道是不是中位数,我们也不写第一个二分
这时我们观察B数组情况
我们把这个数组假想成如图所示,X位置是中位数我们可以不构造一个函数(check)让大于等于中位数的mid返回一个0,让小于中位数的mid返回一个1,正是图中数组,这个数组熟悉啊,用整数二分中的方法,找到第一个0就能找到中位数了.
因此魔改一下这个
把a[mid]&gt;=x改为check函数,check(mid,target(中位数位置)),我们知道了怎么判断mid的位置,用它和中位数位置一比,大于返回个0,小于返回个1,这个就是check函数.
最终max&lt;min会退出第一层二分就结束了,整个复杂度是两个二分加一个遍历
详细证明 这个证明和整数二分有相似之处,主要是针对为什么替换为check函数是对的,改天有写吧...</p>
  </section>
  <footer class="entry-footer">March 13, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-二分" href="http://xyfuture.github.io/posts/program-%E4%BA%8C%E5%88%86/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program_贪心
    </h2>
  </header>
  <section class="entry-content">
    <p> 贪心算法是常用的算法,但是证明似乎比较麻烦.
 贪心的几个性质 贪心的核心思想是找到当前最优解,然后迭代,每一步都是当前的最优解,最终由局部最优达到全局的最优,因此我们需要关注几个东西:
 如何区分步骤,怎样划分一步, 如何选择一步的最优解,选择一个贪心指标,使这个值最大或者最小 每进行一步应该怎样更新数据得到下一步  贪心证明 两种证法
第一种的意思是贪心算法优于所有非贪心算法的情况,一般用数学归纳法证明,设计一个指标,在初始情况说明一下,到第n次说明一下,然后就证出来了 注意这个要求一点,就贪心算法是绝对最优的,没有算法能与之等价或者超过他,下面的情况是有算法可以与之等价,都是最优解
第二种的意思是有多种算法都是最优的,然后贪心能与其中一种进行转化,得到等价的最优解,通常情况下我们假设一种最优解,然后说明贪心的结果能和最优解相互转换
目前根据经验第二种方法用的多一些
贪心例题  说实话没有啥好说的,还是看题吧
 区间调度问题 贪心准则 在这里结束时间是关键
我们要找到当前所有相容子区间中结束时间最早的,然后选他,更新相容区间
这里是最早结束的,不关心开始的情况
证明 可用方法2
设现在存在最优解,在第i个区间和贪心不同,那么最优解的结束时间一定小于贪心解,我们把最优解换成贪心解发现结束时间变早了,不影响后面的解,所以贪心解和最优解等价,因此贪心最优
最小延时调度 贪心准则 将ddl排序,先放ddl最小的(最早ddl的)
证明 区间选点 区间分数 ...</p>
  </section>
  <footer class="entry-footer">March 12, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program_贪心" href="http://xyfuture.github.io/posts/program-%E8%B4%AA%E5%BF%83/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program_week3_homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week3-homework  本次作业的主要内容是DFS和贪心算法,贪心算法看似简单但是证明存在一定难度
 A 选数问题  ZJM友情客串
 题意 题面是英文,但是比较容易理解,就是说给了一堆正数,让你从正数中选出几个数,使得他们相加得到给定的数
解法 解决方法就是DFS,感觉更像普通递归,递归函数 void dfs(int data[],int s,int l,int ans) 这个函数data是输入的数组,s是开始搜索的位置,s之前的都不能用,l是第几层,到达指定层之后就会停住,ans是上一层传来的答案.
这样的话,如果当前层到了指定层就从s开始扫描,如果&#43;ans能等于给定值计数增加,扫描结束则退出,如果不是指定层,则从s开始扫描,进行递归dfs(data,i,l&#43;1,ans&#43;data[i])进入下一层
这样做的话能保证所有组合都是出现的,而且不会出现重复,为了优化性能,在到达指定层前,ans就超了指定答案时不进行递归.
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt; using namespace std; int n,k,m; int count = 0;//全局变量,总的次数 void dfs(int data[],int s,int l,int ans) { if(l == k)//最后一个数,不用向下dfs了  { for(int i=s;i&lt;n;i&#43;&#43;) if (ans&#43;data[i] == m) count &#43;&#43;; return ; } else { for(int i=s;i&lt;n;i&#43;&#43;) if(ans&#43;data[i]&lt;m)//省下来的数还能支撑继续dfs  dfs(data,i&#43;1,l&#43;1,ans&#43;data[i]); return ; } } int main() { // int n,k,m;  int c; int data[1000]; memset(data,0,sizeof(data)); scanf(&#34;%d&#34;,&amp;c); for(int i=0;i&lt;c;i&#43;&#43;) { count = 0; scanf(&#34;%d%d%d&#34;,&amp;n,&amp;k,&amp;m); for(int j=0;j&lt;n;j&#43;&#43;) scanf(&#34;%d&#34;,data&#43;j); dfs(data,0,1,0); printf(&#34;%d\n&#34;,count); } } 总结 降低时间复杂度的一个重要的方法是剪枝,可行性剪枝,最优化剪枝,同时加入vis数组避免重复访问....</p>
  </section>
  <footer class="entry-footer">March 5, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program_week3_homework" href="http://xyfuture.github.io/posts/program-week3-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program_week3_class
    </h2>
  </header>
  <section class="entry-content">
    <p>DFS 记录节点状态
 可行性 最优化 记忆化搜索(就是标记走过的路)  贪心算法 证明   贪心算法最优,其他都比他差.
  贪心算法和其他一样优,其他算法的结果可以转化为贪心算法
  ...</p>
  </section>
  <footer class="entry-footer">March 4, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program_week3_class" href="http://xyfuture.github.io/posts/%E7%A8%8B%E8%AE%BE-week3/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program_week2_homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week2-contest  本次题目全是基础的模拟题,虽然看着简单,但是实际操作起来会发现还是有很多问题,主要是题意的理解和输出格式,除此之外模拟题不能浪费太多时间,coding的速度一定要练上去.
 A-化学  原题: Gym 270437A
 题意 本题的目的是给出化学分子式,然后输出它的名字. 化学分子式的输入类似图结构,分子式有几个分子是确定,输入的是分子之间的连接情况,两个分子之间有连线就输入一个数对,代表这俩相连.当然因为分子不和数字直接对应因此一个分子式有多种数对表示.[(1,2)可以理解为1号分子和2号分子连接]
做法 ​	首先我们观察给出的分子的结构,可以发现,n-hexane中4个节点的度为2,其他分子式不具备这个特点,同理2,3-dimenthylbutane中2个节点度为3, 2,2-dimenthylbutane中1个节点的度为4,借助节点度的特征可以确定这几种结构,但是2-methylpentane和和3-methylpentane的节点的度的情况基本相同,1个3度,2个2度,3个1度,因此还要区分这两个. ​	区分的方法是从3度节点入手,查找它邻接的节点,如果有邻接节点中有两个1度节点则为2-methylpentane,否则就是3-methylpentane.
​	我们需要一个数组存每个节点的度,除此之外使用一个多值字典(multimap)记录邻接情况(mp[i]的值是所有与i节点邻接的节点),这个字典是为了后两种情况,使用这两个手段就能区分所有情况.
code #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std; int data[8]; multimap &lt;int,int&gt; mp; void check() { int count[10];//多开一点,用于记录不同度的节点个数count[i]代表度为i的节点有几个  memset(count,0,sizeof(count)); for(int i=0;i&lt;8;i&#43;&#43;) count[data[i]]&#43;&#43;;//初始化  if(count[4] == 1){//前3种根据度直接判断  printf(&#34;2,2-dimethylbutane\n&#34;); return ; } else if (count[3] == 2){ printf(&#34;2,3-dimethylbutane\n&#34;); return ; } else if (count[2]==4){ printf(&#34;n-hexane\n&#34;); return ; } else{//后两种情况  int tar = 0;//找到度为3的节点  for (int i=0;i&lt;8;i&#43;&#43;) if (data[i] == 3) tar = i; int c = 0;//记录邻接点种度为1的节点个数  for (map&lt;int,int&gt;::iterator it = mp....</p>
  </section>
  <footer class="entry-footer">March 3, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program_week2_homework" href="http://xyfuture.github.io/posts/program-week2-homework/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://xyfuture.github.io/tags/program/">« Prev Page</a>
  </nav>
</footer>

    </main><footer class="footer">
    <span>&copy; 2021 <a href="http://xyfuture.github.io/">My New Hugo Site</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
