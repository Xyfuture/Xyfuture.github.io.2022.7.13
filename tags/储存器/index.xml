<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>储存器 on My New Hugo Site</title>
    <link>http://xyfuture.github.io/tags/%E5%82%A8%E5%AD%98%E5%99%A8/</link>
    <description>Recent content in 储存器 on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 09 Mar 2020 08:02:36 +0000</lastBuildDate><atom:link href="http://xyfuture.github.io/tags/%E5%82%A8%E5%AD%98%E5%99%A8/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计组-存储器</title>
      <link>http://xyfuture.github.io/posts/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95/</link>
      <pubDate>Mon, 09 Mar 2020 08:02:36 +0000</pubDate>
      
      <guid>http://xyfuture.github.io/posts/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95/</guid>
      <description>储存器基础 存储器种类 这张图画的不错,一个要注意的点,主存储器(内存)分为RAM和ROM RAM: Random Access Memory 可读可写,存取时间与物理地址无关 ROM: Read Only Memory 只能读,但是读的时间也与物理地址无关
主存储器  下面讲的都是主存储器,就是内存
 按照之前的理论,主存有MDR和MAR,两个重要的寄存器,MAR(Memory Address Register)用来存放访存的地址,访存指读或者写,MDR(Memory Data Register)访存的内容写在这里面.
在这两个寄存器上有许多其他电路辅助访存,MAR上有译码器和驱动器,根据MAR中内容找到找到数据在存储体中实际的位置译码器将地址分开,驱动器给使能信号啥的,MDR有读写控制,用于决定是读是写
一共有三种总线,地址总线,数据总线和控制总线,总线可以理解为并行接口,传输数据,地址总线和数据总线就不用说了,控制总线传输读写控制,芯片使能等控制信号
大致可以理解为这样
控制信号有点反直觉,只要上是上面加横杆的都代表低电平有效
译码驱动  这里一直在说一个芯片,芯片中必然有最小存储单元,这个最小的单元一般是1位,但是存储芯片的字长是多位的,这就需要多个最小芯片位于一个地址,同时输出信息
 线选法 芯片按行分开,地址就是对应哪一行,译码器就将地址分析成一行,然后这一行的最小的单元就被选中,进行读写电路
重合法 这是重合法的线路,首先我们将地址分为行地址和列地址,一行中有多个组,行地址代表选中这一行,列地址选定一组中的哪一个,因为有多个组因此可以输出指定字长的信号
Intel 2114的例子
可以看看这个,列地址有4位,代表一个组中最多就16个单位,行地址则有6位,代表有64行,然后数据总线是4位 ,因此有4组,这样整个的结构是64*64的.
示意图如上
时序 因为访存一次需要传输多种信号,因此我们需要定义好顺序,这个顺序是人为规定的,符合这个顺序的数据才能访存,否则无效.
行地址和地址可能是分开的,下面展示一个示意图
DRAM  Dynamic Random Access Memory 用电容的方式存储数据
 数据刷新 DRAM需要定时刷新,一共有三种常见的刷新方式
集中刷新 过一段时间刷新所有单元
一个周期刷新多少个单元是设计的问题,这里设计为了刷新一行的单元(反正是并行的)
刷新期间不能访存,称为死区
分散刷新 这种方式是访存一次就刷新一行,同时把刷新时间计算到访存中去,这样就没了死区问题,但是访存速度慢了
异步刷新 访存几次然后刷新一行(不是刷新全部),结合上述两种方式的新方式
还可以把刷新的时间设定在不访存的时候(指令译码阶段)这样就没有死区了.
存储器与CPU连接 容量: 1K*4位 1K-&amp;gt;存储单元个数(地址长度) 4-&amp;gt;字长,一个单元的长度
10条地址线,4条数据线就可以实现对这个存储器的访问.
按字寻址 按字节寻址
位扩展 1k*4 -&amp;gt; 1k*8</description>
    </item>
    
  </channel>
</rss>
