<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>二分 on My New Hugo Site</title>
    <link>http://xyfuture.github.io/tags/%E4%BA%8C%E5%88%86/</link>
    <description>Recent content in 二分 on My New Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Mar 2020 19:40:59 +0000</lastBuildDate><atom:link href="http://xyfuture.github.io/tags/%E4%BA%8C%E5%88%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Program-二分</title>
      <link>http://xyfuture.github.io/posts/program-%E4%BA%8C%E5%88%86/</link>
      <pubDate>Fri, 13 Mar 2020 19:40:59 +0000</pubDate>
      
      <guid>http://xyfuture.github.io/posts/program-%E4%BA%8C%E5%88%86/</guid>
      <description>二分算法是一种性能优秀的算法,常常用在有序的序列上
二分分为三种,整数二分,浮点二分,答案二分
 整数二分 整数二分类似找数问题,在数组中找到指定元素开始的位置和结束的位置
上述代码是找到第一个大于等于x的点,也就是x开始的位置.(有好几个连续的x就是最先的x的下标)
下面是镜像算法,找出x结束的位置
当然这个写法比较麻烦,也可以第一种写法一样把&amp;lt;和=合在一起
算法证明 这个证明有点意思,改天一定写写,用数学归纳法或者反正法都可以证明,把&amp;lt;和=结合起来也挺秒的
一些思想 运用条件很简单,只要上线性的,然后有序就行
浮点二分 浮点二分是数学上的问题,这里不讨论很多,可以去看看零点定理,连续的函数在一个区间中有正有负,那么就是有零点,确定两个边界用零点存在定理算就完事了,注意精度的问题,建议是用固定的运算次数来保证精度
答案二分  结合一个题说一下,这个应该是用的比较多的
题目原题:POJ 3579
 答案如果是在一个区间内有序,我们就可以使用二分来查找
题目 暴力肯定是不行,算出B全部值的复杂度是$n^2$数据范围不过
但是我们注意到求中位数是从有序序列中找,因此可以二分找
我们首先将这个X数组排序,排序之后生成的B和不排序的是等价的(因为绝对值),然后用这个X参与后续计算
B的最小值肯定不小于0(不是B[1]-B[0]),最大值是B[n*(n-1)/2 -1]- B[0],因此我们就从这个区间中开始搜索,找到一个mid后问题就是判断和中位数关系,大于就缩小最大值,小于就提升最小值,一直这样下去直到最大值小于最小值(类似前面整数的操作,后面会再解释)
问题来了,如何确定中位数,最简单的方法,两个for看看有多少个X[j]-X[i]小于等于mid(找出最后一个mid的位置),但是复杂度会超,因此用二分的方法看看有多少个元素.
X[j]-X[i],对i的循环不变,对j用二分,从i+1到n-1二分,这个过程中用到了整数二分中算法
cur是找的目标,找到最后一个cur的位置,e中存的是再B中cur的位置(从1开始算)
这样话我们直到中位数的位置,也知道mid的位置,就能知道mid是不是中位数,让我们再回到第一个二分,即便我们知道是不是中位数,我们也不写第一个二分
这时我们观察B数组情况
我们把这个数组假想成如图所示,X位置是中位数我们可以不构造一个函数(check)让大于等于中位数的mid返回一个0,让小于中位数的mid返回一个1,正是图中数组,这个数组熟悉啊,用整数二分中的方法,找到第一个0就能找到中位数了.
因此魔改一下这个
把a[mid]&amp;gt;=x改为check函数,check(mid,target(中位数位置)),我们知道了怎么判断mid的位置,用它和中位数位置一比,大于返回个0,小于返回个1,这个就是check函数.
最终max&amp;lt;min会退出第一层二分就结束了,整个复杂度是两个二分加一个遍历
详细证明 这个证明和整数二分有相似之处,主要是针对为什么替换为check函数是对的,改天有写吧</description>
    </item>
    
  </channel>
</rss>
