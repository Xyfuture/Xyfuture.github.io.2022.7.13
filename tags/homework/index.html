<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>homework | My New Hugo Site</title>

<meta name="keywords" content="" />
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://xyfuture.github.io/tags/homework/" />
<link href="/assets/css/stylesheet.min.5c4f6d85b7abfcfea458637c672d16a7a9c38c37f002753cfdc7f314b6d3c8f2.css" integrity="sha256-XE9thber/P6kWGN8Zy0Wp6nDjDfwAnU8/cfzFLbTyPI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://xyfuture.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xyfuture.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xyfuture.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xyfuture.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://xyfuture.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />
<link rel="alternate" type="application/rss&#43;xml" href="https://xyfuture.github.io/tags/homework/index.xml">


<meta property="og:title" content="homework" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://xyfuture.github.io/tags/homework/" />
<meta property="og:updated_time" content="2020-06-11T14:37:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="homework"/>
<meta name="twitter:description" content=""/>



</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xyfuture.github.io/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()"></ul>
    </nav>
</header>

    <main class="main"> 
<header class="page-header">
  <h1>homework</h1>
</header>



<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Progarm-optional-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week11 E - 选做题11-1 东东与 ATM 题面 这道题是一道多重背包,而且需要使用二进制拆分进行优化才可过
解法 这道题可以直接按多重背包思路来理解,但是稍有不同,这个不需要价值最大,只需要满足要求
ans[j]=1表示能提供j金额的现金,使用滚动数组优化,然后状态方程为
对第t类钞票 ans[j] = ans[j-data[t]] (逆序)
然后因为每类钞票数量都是有限制的,因此采取类似多重背包二进制拆分的方案,将钞票按量分开,作为一种新钞票
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;cstring&gt; using namespace std; int ans[100002]; int num[12]; int value[12]; int nnum[10002]; int nvalue[10002]; int split[12]; int ssum[12]; void init() { for(int i=0;i&lt;12;i&#43;&#43;) { split[i]=1&lt;&lt;i; if(i==0) ssum[i] = 1; else ssum[i] = ssum[i-1]&#43;split[i]; } } int main() { int n,m,p; init();//初始化二进制拆分数组  while(scanf(&#34;%d&#34;,&amp;n)!=EOF) { memset(ans,128,sizeof(ans)); scanf(&#34;%d&#34;,&amp;m); for(int i=1;i&lt;=m;i&#43;&#43;) scanf(&#34;%d%d&#34;,num&#43;i,value&#43;i); p=1; for(int i=1;i&lt;=m;i&#43;&#43;) { int t=0; int temp=num[i];//将个数进行二进制拆分  while((temp&gt;&gt;1)&gt;0){//最多是2^x  t&#43;&#43;; temp = temp&gt;&gt;1; } for(int s=0;s&lt;t;s&#43;&#43;)//拆分  nnum[p]=split[s],nvalue[p&#43;&#43;]=value[i]; if(t==0)//剩下的  nnum[p] = num[i]; else nnum[p]=num[i]-ssum[t-1]; nvalue[p&#43;&#43;]=value[i]; } ans[0] = 1;//提供0是可以的  for(int i=1;i&lt;=p-1;i&#43;&#43;)//一个一个钞票类型来  { for(int j=n;j&gt;=0;j--)//最多就是提供n  { // ans[j] = ans[j];  if(j-nnum[i]*nvalue[i]&gt;=0)//大于0,避免负数现金  if(ans[j-nnum[i]*nvalue[i]] == 1)//子情况能提供  ans[j] = 1; } } int cur=0; for(int i=n;i&gt;=0;i--) if(ans[i] == 1) { cur =i; break; } printf(&#34;%d\n&#34;,cur); } } 总结 这道题一开始使用的是朴素的多重背包，结果t了，然后使用二进制拆分过了，经过二进制拆分就把一个多重背包转换成了普通的背包问题，因为拆分后结果可以组合成多背包的每一种情况，但是对于拆开后的背包，每一个都是独立的，因此可以缩小复杂度把n转换为log（n）...</p>
  </section>
  <footer class="entry-footer">June 11, 2020
</footer>
  <a class="entry-link" aria-label="post link to Progarm-optional-homework" href="https://xyfuture.github.io/posts/progarm-optional-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-month-simulate
    </h2>
  </header>
  <section class="entry-content">
    <p>模拟 炉石传说201609-3 题面 完整题面非常长，前面都是介绍背景，没啥用，重点关注后面，基本规则
 1个英雄 7个随从 一个回合三种操作 添加随从，随从死亡都是顺移的 攻击的规则是双方都掉血  然后看看最后的约定就可以了
解法 这道题完全就是模拟，因此直接按照题意要求做就可以
随从的存放使用vector，比较方便插入和删除随从
随从根据血量和攻击力确定，使用pair存储，每次攻击时判断攻击后的血量，然后按要求删除
英雄和随从放在一起，但是在数组的0号下标
最后输赢判断就是看看谁的英雄hp是负的，负的（0）为输，都正为平
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std; int n; vector&lt;pair&lt;int,int&gt; &gt; player[2];//0是先手，1是后手  void summon(int t)//加入随从 { int posi,hp,atk; cin&gt;&gt;posi&gt;&gt;atk&gt;&gt;hp; player[t].insert(player[t].begin()&#43;posi,make_pair(hp,atk)); } void attack(int t)//攻击 { int attacker,defender; cin&gt;&gt;attacker&gt;&gt;defender; player[t][attacker].first -= player[t^1][defender].second; player[t^1][defender].first -= player[t][attacker].second; if(defender!=0&amp;&amp;player[t^1][defender].first&lt;=0)//删除，不删英雄  player[t^1].erase(player[t^1].begin()&#43;defender); if(player[t][attacker].first&lt;=0) player[t].erase(player[t].begin()&#43;attacker); } void process(int t,string temp) { if(temp == &#34;summon&#34;) summon(t); else if (temp == &#34;attack&#34; ) attack(t); } int main() { cin&gt;&gt;n; for(int i=0;i&lt;=7;i&#43;&#43;) if(i==0) { player[0]....</p>
  </section>
  <footer class="entry-footer">June 9, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-month-simulate" href="https://xyfuture.github.io/posts/program-month-simulate/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week15-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week15-homework B - ZJM 与生日礼物（选做） 题面 解法 ...</p>
  </section>
  <footer class="entry-footer">June 9, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week15-homework" href="https://xyfuture.github.io/posts/program-week15-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week16-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week16-CSP A - TT数鸭子 题面 数位计数,统计一个数中每一位上不同数字的个数
解法 直接把每一位分离,然后用个桶排就行了
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std; typedef long long ll; int num[10]; int getDif(ll temp)//统计 { memset(num,0,sizeof(num)); while(temp)//分离  { num[temp%10] &#43;&#43;; temp/=10; } int cnt=0; for(int i=0;i&lt;10;i&#43;&#43;) if(num[i]) cnt&#43;&#43;;//只要有就计数  return cnt; } int main() { int cnt = 0; int n,k; ll cur; scanf(&#34;%d%d&#34;,&amp;n,&amp;k); for(int i=0;i&lt;n;i&#43;&#43;) { scanf(&#34;%lld&#34;,&amp;cur); if(getDif(cur)&lt;k)//总个数  cnt&#43;&#43;; } printf(&#34;%d&#34;,cnt); return 0; } 总结 题目难度不大,不过题目的描述有点坑,k本身最大就是10...</p>
  </section>
  <footer class="entry-footer">June 4, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week16-homework" href="https://xyfuture.github.io/posts/program-week16-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week14-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week14-模拟 A - 猫睡觉问题 题面 一天内有时间段必须醒着,其他时间可以睡觉也可以醒着,但是连续醒着时间有限制,连续睡觉有最短时间限制,同时这个时间可能是跨天的(一个循环),求取睡觉的策略
解法 这道题的难点主要在于跨天的时间管理和题意理解(存在一种特殊情况)
对于跨天的时间管理,我们采取模的策略,每天开始的时间不是0点,而是第一个出现的时间点.这样无论跨不跨天都是按24小时算.(相当于画了个圈,只不过把起始点换了一下)
特殊情况:
这个一开始没想到
就是一天全部都要醒着,导致根本没有睡觉时间,应该输出个No,但是第一次的代码输出了Yes,然后没输出时间.
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std; //使用环 struct timeSeg { int s;//存分钟数  int e; bool operator &lt; (timeSeg&amp; op) const //优先队列  {return s&lt;op.s;} bool operator &gt;(const timeSeg&amp; op) const {return s&gt;op.s;} timeSeg() {s=0;e=0;} timeSeg(int a,int b):s(a),e(b) {} }; priority_queue&lt;timeSeg,vector&lt;timeSeg&gt;,greater&lt;timeSeg&gt; &gt; timeTable;//这个存必须醒着的时间,按顺序排 vector&lt;timeSeg&gt; sp;//存输出结果,睡觉的时间 int A,B,N;//初始需要的三个参数 int weekTime;//连续醒的时间  bool process() { timeSeg firstTime = timeTable....</p>
  </section>
  <footer class="entry-footer">May 26, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week14-homework" href="https://xyfuture.github.io/posts/program-week14-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week13-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week13-homework A - TT 的神秘任务1（必做） 题面 解法 这道题考察了一些基本的数学知识.
首先核心就是 奇数&#43;奇数=偶数 偶数&#43;偶数=奇数 奇数&#43;偶数=奇数
然后还一个就是经常忘的情况,0是偶数,(虽然这个题要求从1开始)
解题思路就是偶数情况,前k-1个数为2,最后一个数(n-2k&#43;2)要求是偶数
奇数情况前k-1个数是1,最后一个数(n-k&#43;1)要求是奇数
如果这两种情况都不能满足那么说明不能满足
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std; int data; int k; int main() { int n; scanf(&#34;%d&#34;,&amp;n); for(int i=0;i&lt;n;i&#43;&#43;) { scanf(&#34;%d%d&#34;,&amp;data,&amp;k); if((data-2*k&#43;2)&gt;0&amp;&amp;(data-2*k&#43;2)%2==0)//偶数情况,需要判断大于0  { printf(&#34;YES\n&#34;); for(int t=0;t&lt;k-1;t&#43;&#43;)//先输出2  printf(&#34;2 &#34;); printf(&#34;%d\n&#34;,(data-2*k&#43;2));//最后一个偶数  } else if((data-k&#43;1)&gt;0&amp;&amp;(data-k&#43;1)%2==1)//奇数情况  { printf(&#34;YES\n&#34;); for(int t=0;t&lt;k-1;t&#43;&#43;)//先输出1  printf(&#34;1 &#34;); printf(&#34;%d\n&#34;,data-k&#43;1);//最后一个奇数  } else//不能满足  printf(&#34;NO\n&#34;); } } 总结 奇偶判断，感觉比较简单...</p>
  </section>
  <footer class="entry-footer">May 26, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week13-homework" href="https://xyfuture.github.io/posts/program-week13-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week12-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week12-CSP A - csp-m3-t1 题面 这个求相同元素区间的个数,之前做过,但是还是做错了
解法 简单的计数就行了
一定要注意指针超界问题,这次就是因为这个原因被RE了
code #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std; int data [10000]; int main() { int n; memset(data,0,sizeof(data)); scanf(&#34;%d&#34;,&amp;n); for(int i=0;i&lt;n;i&#43;&#43;) scanf(&#34;%d&#34;,data&#43;i); int pre=data[0]; int cnt =0 ; for(int i=0;i&lt;n;) { while(pre == data[i]) if(&#43;&#43;i&gt;n)//避免指针超界  break; cnt&#43;&#43;; pre = data[i]; } printf(&#34;%d&#34;,cnt); } 下面这个实现更好一些
#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std; int data [10000]; int main() { int n; memset(data,0,sizeof(data)); scanf(&#34;%d&#34;,&amp;n); for(int i=0;i&lt;n;i&#43;&#43;) scanf(&#34;%d&#34;,data&#43;i); int pre=data[0]; int cnt = 1;//因为最后一个不会被算入,提前&#43;1  for(int i=0;i&lt;n;i&#43;&#43;)//保证不越界  { if(pre == data[i]) continue ; else { cnt&#43;&#43;;//遇到新的&#43;1  pre =data[i]; } } printf(&#34;%d&#34;,cnt); } 总结 这题真的是不该错,实在是太简单了,一开始写的是对的,后来瞎改,把i&lt;n的条件给去掉了,导致一个点re...</p>
  </section>
  <footer class="entry-footer">May 14, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week12-homework" href="https://xyfuture.github.io/posts/program-week12-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week10-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week11-homework A - 必做题11-1 题面 解法 这是一道简单的模拟题,首先得了解高中学的概率知识,明白$(1&#43;k)^t$这样一个增长公式然后可以用模拟的方法一年一年的模拟解出问题,也可以推一个的数学公式,直接算出来,这里采取模拟的方法
code #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std; int main() { float n; float m=200; float k; scanf(&#34;%f%f&#34;,&amp;n,&amp;k);//浮点  k = k/100;//小数  int i=1; float total = m; float salary = 0; while(salary-total&lt;0.000001) { salary =i*n;//收入  total = m*pow((1&#43;k),i-1);//房价  if(i&#43;&#43;&gt;21)//大于20年  break; } if(i&gt;21) printf(&#34;Impossible&#34;); else printf(&#34;%d&#34;,i-1); return 0; } 总结 难度不大,但是得理清楚年份之间的关系,第一年房价是原价
B - 必做题11-2 题面 输入输出都是一个数字组成的矩阵
解法 题目本身也是模拟,这个考察了数组的下标的运用,通过下标的转换实现数组的转换
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt; using namespace std; int n; int data[22][22]; int ans[22][22]; // int mid[22][22];  inline bool dec(int t,int i,int j) { if(t == 1) return data[i][j]!...</p>
  </section>
  <footer class="entry-footer">May 14, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week10-homework" href="https://xyfuture.github.io/posts/program-week11-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week9-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week9-homework A - 咕咕东的目录管理器 题意 题面 题目要求实现一个简单的目录管理器,主要是实现几个命令,建议还是去原题看看
解法 命令分为两种操作和询问,对于操作类型来说有一个undo 的操作,因此要使用一个栈来记录所有的操作型指令用于恢复.
首先我们设计文件树的存储(为啥用树?题目直接说了文件树 … )
这个树肯定是多个孩子的,我们可以用类似孩子链表的形式使用vector nodes存储所有节点,我们要求孩子顺序是字典序,因此使用map&lt;string,int&gt;存储孩子,string是文件名,int是vector种的下标.为了溯源存储一个int father,表示父节点的下标
剩下的几个变量都是为了题目实现而存储的信息.int allNodes代表的是以该节点为根的文件树的总节点数(每次插入或者删除节点向上溯源更新). string nodeName表示文件的当前节点的文件夹名.除此之外vector&lt;string&gt; ftree用来储存tree命令时前后的5个文件夹名.int change储存ftree是否应该发生改变,change=1表示文件结构被更新过,ftree不能用了.
下面讲解各个命令:
首先编写一个pushForward函数,用来从当前节点开始通过father向上更新整棵树,更新allNode和change.使用一个int curPosi记录当前操作的节点下标
mkdir: 首先检查新的文件名是否在children中存在,存在输出ERR.,不存在就新建,插入到nodes中,同时更新children,调用pushForward,将该次命令和操作的两个节点下标插入到栈history
rm: 首先检查children中有没有该文件,没有输出ERR,有就在children中删除(在nodes中不清除节点),调用pushForwad,将命令和操作的两个下标插入到history
cd: 遇到&#34;..“直接返回到father,如果father是0(根节点)输出ERR.否则检查孩子中有没有想到的文件名,如果可以没有输出ERR,最后将命令和操作的下标插入到history
sz: 直接输出allNodes
ls: 首先看孩子个数,小于10,全部输出,大于10,输出前5个和后5个
tree: 该命令是比较难实现的,需要一定的记忆化 首先看当前节点的孩子个数,0个输出EMPTY,直接结束.其他情况首先递归实现以该节点为根的文件树通过先根遍历的方式更新ftree.更新时,更新过的节点change改为0表示无需再次更新.然后输出ftree前5个和后5个
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std; struct treeNode { string nodeName;//文件名  int father;//父节点下标  int allNodes;//总的孩子个数&#43;1 sz使用  vector&lt;string&gt; ftree;//tree命令使用的数组,前5个和后5个  int change;//ftree是否发生改变  map&lt;string,int&gt; children;//按字典序存孩子节点的文件名和下标  treeNode(string name,int father,int allNodes,int change):nodeName(name),father(father),allNodes(allNodes),change(change) {} treeNode(){} }; struct cmd { string command; int pwd; int newDir; }; vector&lt;treeNode&gt; nodes;//所有节点的数组,下标就是这里的 stack&lt;cmd&gt; history;//操作命令历史记录 int curPosi;//当前操作的位置的下标  void pushForward(int posi,int num)//从posi开始上溯 { nodes[posi]....</p>
  </section>
  <footer class="entry-footer">April 29, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week9-homework" href="https://xyfuture.github.io/posts/program-week9-homework/"></a>
</article>
<article class="post-entry tag-entry"> 

  <header class="entry-header">
    <h2>
      Program-week10-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week10-homework A - 签到题 题面 解法 直接m/n看看是不能整除,不整除,直接输出-1
整除的话将得到的商先除2再除3,如果能够整除,就输出次数,不行输出-1
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt; using namespace std; int main() { int n,m; scanf(&#34;%d%d&#34;,&amp;n,&amp;m); if(m%n!=0||n&gt;m)//能整除  { printf(&#34;-1\n&#34;); return 0; } int t = m/n;//倍数  int i=0; while(t%2 == 0)//一直/2直到不能进行  { t/=2; i&#43;&#43;; } while(t%3 == 0)//一直除3直到不能进行  { t/=3; i&#43;&#43;; } if(t!=1)//除不尽  printf(&#34;-1\n&#34;); else //除尽  printf(&#34;%d\n&#34;,i); return 0; } 总结 问题不难,考虑除尽的情况即可
B - LIS &amp; LCS 题面 解法 这是一道DP的模板题...</p>
  </section>
  <footer class="entry-footer">April 29, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week10-homework" href="https://xyfuture.github.io/posts/program-week10-homework/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://xyfuture.github.io/tags/homework/page/2/">Next Page »</a>
  </nav>
</footer>

    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://xyfuture.github.io/">My New Hugo Site</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
