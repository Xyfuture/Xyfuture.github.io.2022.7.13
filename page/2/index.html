<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>My New Hugo Site</title>

<meta name="keywords" content="" />
<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="http://example.org/" />
<link href="/assets/css/stylesheet.min.5c4f6d85b7abfcfea458637c672d16a7a9c38c37f002753cfdc7f314b6d3c8f2.css" integrity="sha256-XE9thber/P6kWGN8Zy0Wp6nDjDfwAnU8/cfzFLbTyPI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="http://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="http://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />
<link rel="alternate" type="application/rss&#43;xml" href="http://example.org/index.xml">


<meta property="og:title" content="My New Hugo Site" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="http://example.org/" />
<meta property="og:updated_time" content="2020-06-11T14:37:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="My New Hugo Site"/>
<meta name="twitter:description" content=""/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "My New Hugo Site",
  "url": "http://example.org/",
  "description": "",
  "thumbnailUrl": "http://example.org/favicon.ico",
  "sameAs": [
      
  ]
}
</script>


</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()"></ul>
    </nav>
</header>

    <main class="main"> 



<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      Program-week8-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>homework A - 区间选点 II 题意 题面 题意很简单,就是给定一个区间,要求在每个区间内得取够给定个数的点(可以超过,但是不能少),问全局最少需要去多少个点
解法 本道题要求使用差分约束来解
差分约束首先要构建方程,找到用于一个表示X的量,这里使用一个数组dis,dis[i]代表从min到第i个点一共有多少个点(注意这里的min对应着题目中最小的区间端点),那么实际上我们求取的就是dis[max]的值(max代表给出的最大区间端点).
下面开始构建约束
对于给出的区间(i,j)要求k的点我们可以构建方程
$dis[j]-dis[i-1]\geq k$
除此之外为了使题目有意义我们得保证每个点只能被取0次或1次,因此需要方程约束
$0\leq dis[t]-dis[t-1]\leq 1$s
题目中使从0开的,我们给每个点都进行偏移,使整个数轴从1开始,那么我们还能知道$dis[0]=0\ or\ dis[min-1]=0$
综上我们知道了如下信息 $$ dis[min-1] =0\
dis[j]-dis[i]\geq k\
dis[t]-dis[t-1]\geq 0\
dis[t-1] - dis[t]\geq -1 $$ 我们要求的最少用多少个点,那么就是求取最大值最小,使用最长路求取,因为有负边权我们使用SPFA来求,鉴于本题一定有答案,不做负环的判断
求出最长路只需要换一下啊松弛条件就可以了
这道题复杂度同SPFA一样,O(KM)
code #include&lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;// #include &lt;algorithm&gt; #include &lt;queue&gt;#include &lt;cstring&gt; using namespace std; vector&lt;pair&lt;int,int&gt; &gt; G[50005];//图 queue&lt;int&gt; q;//队列 int dis[50005];//最大值,差分数组 int inque[50005];//是否在队列中 int main() { memset(dis,-128,sizeof(dis)); memset(inque,0,sizeof(inque)); int n; scanf(&#34;%d&#34;,&amp;n); int min = 50005,max = 0 ; for(int i=0;i&lt;n;i&#43;&#43;) { int a,b,c; scanf(&#34;%d%d%d&#34;,&amp;a,&amp;b,&amp;c); a&#43;=1,b&#43;=1;//把从0开始改为从1开始  if(a&lt;min) min = a;//起始位置  if(b&gt;max) max = b;//结束位置  G[a-1]....</p>
  </section>
  <footer class="entry-footer">April 15, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week8-homework" href="http://example.org/posts/program-week8-homework/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      Program_week7_homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week7-homework A - TT 的魔法猫 题意 题面 这道题就是求一个传递闭包,题目中给出胜负关系可以看成一对序偶,相互之间具有传递关系,给出基本的几个序偶,然后让求取改集合的传递闭包,然后看看闭包中有多少个元素
解法 首先我们把这个输赢关系建成图,使用二维矩阵直接存储这个图,N个人代表矩阵大小是N*N,M个关系则代表图中有M条边,A B,代表A赢过B,建立一条A到B的边,如果B能到C则也有A到C的边
将图按照给定的元素初始化后我们对这张图跑floyd-warshall.不过要把松弛条件改一下,不是最短路径了,而是只要能到达则将数组中对应的位置改为1.
注意在这种情况下能够进行剪枝,如果在判断i经过j能能不能到达新节点时,若i直接不能到达j,则跳过.经过剪枝后时间复杂度会降低不少.
最后计算未知的数量,首先使用组合的知识计算出多少场比赛$C^2_n$,减去矩阵中1的数量,这样就能得到未知的场数
code #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt; using namespace std; // vector&lt;int&gt; G[502]; int G[502][502];//二维矩阵  int main() { int cnt; scanf(&#34;%d&#34;,&amp;cnt); for (int i=0;i&lt;cnt;i&#43;&#43;) { int n,m; scanf(&#34;%d%d&#34;,&amp;n,&amp;m); memset(G,0,sizeof(G));//初始化  for(int j=0;j&lt;m;j&#43;&#43;) { int a,b; scanf(&#34;%d%d&#34;,&amp;a,&amp;b); G[a][b] = 1;//A赢B,A-&gt;B的路  } for(int k=0;k&lt;n&#43;1;k&#43;&#43;)//经过第k个  for(int t=0;t&lt;n&#43;1;t&#43;&#43;) if(G[t][k]==1)//剪枝,不能到达就不继续了,正常floyd也可以有  for(int e=0;e&lt;n&#43;1;e&#43;&#43;) if(G[k][e]==1)//更新,可能会重复,但不影响正确  G[t][e] = 1; int ans = 0; for(int p=0;p&lt;n&#43;1;p&#43;&#43;) for(int q=0;q&lt;n&#43;1;q&#43;&#43;) if(G[p][q] == 1) ans&#43;&#43;;//统计已知场数  ans = ((n*(n-1))/2 ) - ans; printf(&#34;%d\n&#34;,ans); } } 总结 这道题一开始交的时候没有考虑剪枝的情况(虽然上课讲了),然后就T了,后来想起来可以剪枝降低复杂度,就加了剪枝,然后就过了,以后还是要写带剪枝的floyd....</p>
  </section>
  <footer class="entry-footer">April 13, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program_week7_homework" href="http://example.org/posts/program-week7-homework/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      Program-week6-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week6-csp A - 掌握魔法の东东 II 题意 给定一组扑克牌,每张牌拥有两个属性,花色和大小,不存在完全相同的两张牌.首先取两张,了解其花色和大小,然后再取三张牌,问问总共的5张牌,在9种情况中各有多少
解法 这道题有两种解法,一种思路是搜索,用DFS搜索一遍,每次在5张牌时判断目前的五张牌是什么情况,对应的情况计数增加.第二种解法是直接用排列组合的方式直接计算出每种情况的个数.
这道题我是用第二种方法做的,首先写一个用于计算组合数的函数,用它来计算组合数.设牌的大小是1-n,花色有m种
 首先判断两张牌花色相同且相差不大于4,然后找到上下界,在上下界中找出大小为5的窗口有几个就行了 和上一个差不多,但是不判断花色了,然后后摸的三张牌颜色要进行组合最后要减去1的数量 判断两张牌的花色是否相同,相同的话,直接$C_{n-2}^3$就行了,最后减1中的 首先判断总的花色数,必须等于4,判断两张牌大小是否相等,相等的话只有一张牌是自由的,那么一共有(n-1)*m种可能,否则没有牌是自由的,只有两种可能 首先判断m是不是大于等于3,然后分成两类,一类是先摸的两张牌大小相同,这种情况下在分为先摸的牌为2和先摸的牌为3再次讨论,如果两张牌(A,B)大小不同则按A为2,B为3和A为3,B为2讨论,这两种情况是一样的,直接*2就行 这个也是先判断花色总数,然后分为先摸牌相等和不等两种情况,第二种情况下还要判断先摸的两张牌都是对,还是一个是1一个是对 注意这里的3张大小相同要求剩下的两张必须不同.同样先判断花色总数,之后分为先摸牌相等和不等讨论.在进一步的讨论中,还要分出3,1,1具体对应的是哪个 同样,2张相同的,3张不同的.剩下的方法也是相似的,看花色总数,分成先摸牌相等和不等讨论,进一步的讨论中分清楚2,1,1,1分别是那个 计算出总的情况数,减去上面的就行了  这种方法实在是太麻烦了,搜索的方法会简单很多,因为判断条件要比排列组合好写太多
code #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std; int ans[10];//1 start int A,B;//A是牌的总大小,B是牌的花色数 pair&lt;int,int&gt; curCard[2];//记录先摸的两张牌 int comb(int a,int b)//计算组合数 { int answer = 1; for(int i=0;i&lt;b;i&#43;&#43;) answer*=(a-i); for(int i=0;i&lt;b;i&#43;&#43;) answer/=(i&#43;1); if(answer&lt;0) return 0; return answer; } void con1() { if(curCard[0].second!=curCard[1].second||abs(curCard[0].first-curCard[1].first)&gt;4) return ; int max = curCard[0].first&gt;curCard[1].first?curCard[0].first:curCard[1].first;//取出两张牌中大的和小的  int min = curCard[0]....</p>
  </section>
  <footer class="entry-footer">March 28, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week6-homework" href="http://example.org/posts/program-week6-homework/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      Program-week5-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week5-homework A-最大矩形 题意 给定一个直方图,求取直方图中规则的矩形的最大面积,其中直方图中间隔都是1,每个间隔的高度都是现场给定的.
解法 使用单调栈
对于每个间隔p,我们都在左边和右边找到第一个小于该间隔高度的间隔(如果相等则继续,不停止),在这两个边界之中,高度取p的高度建立的矩形是以p为高度的最大矩形,遍历一遍所有间隔就能获得整个图形中的最大矩形面积
求取左右的端点就是用单调栈实现,单调栈中保存的是从开始到现在所有的信息.对于一个出栈顺序是从小到大的单调栈而言,当一个元素弹出时,遇到的一定是第一个比他大的元素,因为假如之前遇到过比他的元素它早就被弹出了.反过来的顺序就是第一个它小的元素,我们大到小出栈顺序设计单调栈就可以实现我们上面的需求了.右边第一个是从0间隔到n间隔,左边第一个是从n间隔到0间隔 复杂度就是遍历一遍的大小$O(n)$
code #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std; int data[100004];//所有间隔的高度 int s[100004];//栈 int top = -1;//栈顶 pair&lt;int,int&gt; arr[100004];//左边第一个和右边第一个的坐标 int main() { int n; memset(data,0,sizeof(data)); memset(s,0,sizeof(s)); memset(arr,0,sizeof(arr)); while(true) { scanf(&#34;%d&#34;,&amp;n); if (n == 0) return 0; // data[0]=0,data[n&#43;1]=0;  for(int i=0;i&lt;n;i&#43;&#43;) scanf(&#34;%d&#34;,data&#43;i);//录入元素  for(int i=0;i&lt;n;i&#43;&#43;)//找到右边第一个小于的坐标  { while(top!=-1 &amp;&amp; data[s[top]]&gt;data[i])//不满足条件就出栈,同时更新出栈元素的边界  arr[s[top--]].second = i; s[&#43;&#43;top] = i;//新元素入栈  } while(top!=-1)//走到头把所有元素出栈  arr[s[top--]].second = n; top = -1;//重新开始栈  for(int i=n-1;i&gt;=0;i--)//左边第一个元素坐标,操作相同  { while(top!...</p>
  </section>
  <footer class="entry-footer">March 24, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week5-homework" href="http://example.org/posts/program-week5-homework/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      c_with_python
    </h2>
  </header>
  <section class="entry-content">
    <p>最近在写数据结构课设,需要许多图形化的内容,然后cpp直接写GUI会比较麻烦,即便使用MFC,QT,工程量仍旧是很大,所有想到了C和Python之间相互调用
 C与python python是一种脚本语言,实现有多种方式,常见的python实现方式是用c实现cpython,这样的方式.既然是用c实现,cpp自然能调用python,在cpp中include&lt;Python.h&gt;就可以实现对python的调用,除此之外要把需要的库和dll连接上,否则无法编译
要注意c调用python时主要架构,要求双方位数一样,建议都是64,用mingw w64和python3.7 64位,位数不一致无法运行.
python作为胶水语言也可以调用cpp,这种调用方式一般是将cpp编译为python的包,然后在python中import这个模块,使用其中的函数,速度是cpp的原生速度.我们有很多这样的封装工具,boost库,pybind11,swig都可以实现封装操作,比较建议pybind11,这个库只需要头文件,不过其只支持c11
conda conda是python的一种包管理器,同时允许你有多个虚拟的python环境,在一个console中只能同时处于一个环境,这个环境中python的版本是指定的,包也是属于这个环境的,实现的原理主要是建一个单独的文件夹存放python完整的文件,在不同的环境中将命令指向不同的文件夹,大致上是这样
graphviz 这个是一个好东西,能够方便我们我们画图,语言是dot语言,可以直接用python生成dot代码,每次根据代码生成图像或者pdf,方便显示,缺点是不是动态的,不能删除元素
tkinter tkinter是python自带的GUI,方便使用,本次也是调用这个实现GUI的渲染,doc可以参考网上的
要注意的几点
tkinter本身实际上cpp,只不过是给了python接口,但是python接口是真的简单.
tkinter在cpp中调用要设置sys.argv,因为tkinter中会读取命令行参数,除此之外编译时需要链接他的一个dll
conda base powershell 在base环境中powershell会出现问题,cpp的exe无法正常运行if和argv,不知道是什么原因,建议退出base,因为原始环境和base的python基本上是等价的
C调用python参考 官方中文 确实有中文,但是感觉写的不怎么好
转化为python变量 写的不错
完整程序  给了不错的例子,包含大部分调用
简介...</p>
  </section>
  <footer class="entry-footer">March 15, 2020
</footer>
  <a class="entry-link" aria-label="post link to c_with_python" href="http://example.org/posts/c-with-python/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      Program-week4-homework
    </h2>
  </header>
  <section class="entry-content">
    <p>week3-CSP A-咕咕东的奇遇 题意 该题算是一个贪心问题,在一个环(26个数)上布置有序的数字,环上有一个指针,然后给定一个数字序列,要求转动圆环,使得指针指向给定的数字,要求总的转动的次数最少.题目中的不是数字而是字母,不过无所谓,ascii直接转换就行
解法 我们使用贪心的方案,每一次都找到从当前位置到指定位置的最短路径,最短路径只有两种可能,顺时针转过去或者逆时针转过去.在环上本身就是mod26系统,因此让大数减小数是一种,小数加26减大数是另一种,那个小取那个
code #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std; int main() { char s [10002];//数组开大 	memset(s,0,sizeof(s)); scanf(&#34;%s&#34;,s); int count=0;//总和 	int i = 0; char temp; int posi = 0; int maxShift = 0; while((temp=s[i])!=&#39;\0&#39;)//判断截止 	{ int cur = temp-&#39;a&#39;; if(cur&gt;posi) { int left = cur- posi;//一种方向 	int right = posi&#43;26 -cur;//另一种方向 	count&#43;=(left&gt;right? right:left);//取最小 	} if(cur&lt;=posi) { int left = cur&#43;26 - posi; int right = posi-cur; count&#43;= (left&gt;right?...</p>
  </section>
  <footer class="entry-footer">March 15, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-week4-homework" href="http://example.org/posts/program-week4-homework/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      Program-二分
    </h2>
  </header>
  <section class="entry-content">
    <p>二分算法是一种性能优秀的算法,常常用在有序的序列上
二分分为三种,整数二分,浮点二分,答案二分
 整数二分 整数二分类似找数问题,在数组中找到指定元素开始的位置和结束的位置
上述代码是找到第一个大于等于x的点,也就是x开始的位置.(有好几个连续的x就是最先的x的下标)
下面是镜像算法,找出x结束的位置
当然这个写法比较麻烦,也可以第一种写法一样把&lt;和=合在一起
算法证明 这个证明有点意思,改天一定写写,用数学归纳法或者反正法都可以证明,把&lt;和=结合起来也挺秒的
一些思想 运用条件很简单,只要上线性的,然后有序就行
浮点二分 浮点二分是数学上的问题,这里不讨论很多,可以去看看零点定理,连续的函数在一个区间中有正有负,那么就是有零点,确定两个边界用零点存在定理算就完事了,注意精度的问题,建议是用固定的运算次数来保证精度
答案二分  结合一个题说一下,这个应该是用的比较多的
题目原题:POJ 3579
 答案如果是在一个区间内有序,我们就可以使用二分来查找
题目 暴力肯定是不行,算出B全部值的复杂度是$n^2$数据范围不过
但是我们注意到求中位数是从有序序列中找,因此可以二分找
我们首先将这个X数组排序,排序之后生成的B和不排序的是等价的(因为绝对值),然后用这个X参与后续计算
B的最小值肯定不小于0(不是B[1]-B[0]),最大值是B[n*(n-1)/2 -1]- B[0],因此我们就从这个区间中开始搜索,找到一个mid后问题就是判断和中位数关系,大于就缩小最大值,小于就提升最小值,一直这样下去直到最大值小于最小值(类似前面整数的操作,后面会再解释)
问题来了,如何确定中位数,最简单的方法,两个for看看有多少个X[j]-X[i]小于等于mid(找出最后一个mid的位置),但是复杂度会超,因此用二分的方法看看有多少个元素.
X[j]-X[i],对i的循环不变,对j用二分,从i&#43;1到n-1二分,这个过程中用到了整数二分中算法
cur是找的目标,找到最后一个cur的位置,e中存的是再B中cur的位置(从1开始算)
这样话我们直到中位数的位置,也知道mid的位置,就能知道mid是不是中位数,让我们再回到第一个二分,即便我们知道是不是中位数,我们也不写第一个二分
这时我们观察B数组情况
我们把这个数组假想成如图所示,X位置是中位数我们可以不构造一个函数(check)让大于等于中位数的mid返回一个0,让小于中位数的mid返回一个1,正是图中数组,这个数组熟悉啊,用整数二分中的方法,找到第一个0就能找到中位数了.
因此魔改一下这个
把a[mid]&gt;=x改为check函数,check(mid,target(中位数位置)),我们知道了怎么判断mid的位置,用它和中位数位置一比,大于返回个0,小于返回个1,这个就是check函数.
最终max&lt;min会退出第一层二分就结束了,整个复杂度是两个二分加一个遍历
详细证明 这个证明和整数二分有相似之处,主要是针对为什么替换为check函数是对的,改天有写吧...</p>
  </section>
  <footer class="entry-footer">March 13, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program-二分" href="http://example.org/posts/program-%E4%BA%8C%E5%88%86/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      Program_贪心
    </h2>
  </header>
  <section class="entry-content">
    <p> 贪心算法是常用的算法,但是证明似乎比较麻烦.
 贪心的几个性质 贪心的核心思想是找到当前最优解,然后迭代,每一步都是当前的最优解,最终由局部最优达到全局的最优,因此我们需要关注几个东西:
 如何区分步骤,怎样划分一步, 如何选择一步的最优解,选择一个贪心指标,使这个值最大或者最小 每进行一步应该怎样更新数据得到下一步  贪心证明 两种证法
第一种的意思是贪心算法优于所有非贪心算法的情况,一般用数学归纳法证明,设计一个指标,在初始情况说明一下,到第n次说明一下,然后就证出来了 注意这个要求一点,就贪心算法是绝对最优的,没有算法能与之等价或者超过他,下面的情况是有算法可以与之等价,都是最优解
第二种的意思是有多种算法都是最优的,然后贪心能与其中一种进行转化,得到等价的最优解,通常情况下我们假设一种最优解,然后说明贪心的结果能和最优解相互转换
目前根据经验第二种方法用的多一些
贪心例题  说实话没有啥好说的,还是看题吧
 区间调度问题 贪心准则 在这里结束时间是关键
我们要找到当前所有相容子区间中结束时间最早的,然后选他,更新相容区间
这里是最早结束的,不关心开始的情况
证明 可用方法2
设现在存在最优解,在第i个区间和贪心不同,那么最优解的结束时间一定小于贪心解,我们把最优解换成贪心解发现结束时间变早了,不影响后面的解,所以贪心解和最优解等价,因此贪心最优
最小延时调度 贪心准则 将ddl排序,先放ddl最小的(最早ddl的)
证明 区间选点 区间分数 ...</p>
  </section>
  <footer class="entry-footer">March 12, 2020
</footer>
  <a class="entry-link" aria-label="post link to Program_贪心" href="http://example.org/posts/program-%E8%B4%AA%E5%BF%83/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      算法小结
    </h2>
  </header>
  <section class="entry-content">
    <p>dijkstra 迪杰斯特拉算法是用于计算单点最短路,并且要求图是无负边权的.
算法思路 从一个点开始,记录一个到其他所有点的数组,从这个数组中取出最近的一个点,更新那个数组,然后重复那个数组,每次取最短的点然后更新,直到所有点都被遍历.
复杂度 节点数 v 边数 e
邻接表
$O(v^2)$ ($O(v^2&#43;e)$)
因为一共更新了n个点,每个点取的时候首先找最短的点(n的复杂度),同时取完了会找一遍所有的边
邻接矩阵
$O(v^2)$
Prime Kruskal SPFA Floyd BFS BFS啥都能干…
算法思路 首先有一个vis数组,这个数组用来记录走过的点,然后开一个队列用来记录访问的元素.好了现在开始BFS,先将原点的vis标记,将这个点加入到队列,从队列中取出这个点,对这个点操作,然后访问这个点所有的邻接点,将没有被标记的点标记加入到队列中,重复队列的循环,直到队列空.
复杂度 顶点数 v 边数 e
邻接表
$O(v&#43;e)$
每个点都被访问一次,访问时候v^2走一个函数,所有点就算v,然后有一个加入队列的for循环,这个循环总的合起来就是e,因此时v&#43;e
邻接矩阵
$O(v^2)$
两个for 都是v
Question
邻接表和邻接矩阵的复杂度看着似乎有点问题,不是一个量级,但是你要注意到e最大是v^2,所以还是一个量级的
DFS 算法思想 DFS是递归的方法,首先标记自己,然后搜索所有没有被标记的点,对他们进行DFS,不能继续搜索就返回到上一级,直到所有都返回
复杂度 和BFS相同
邻接表
$O(v&#43;e)$
注意点 DFS和BFS都需要注意剪枝的问题,不符合条件的情况一定不要继续访问,主要就是vis数组要标记好
参考CSP卖菜问题...</p>
  </section>
  <footer class="entry-footer">March 9, 2020
</footer>
  <a class="entry-link" aria-label="post link to 算法小结" href="http://example.org/posts/%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93/"></a>
</article>
<article class="post-entry"> 

  <header class="entry-header">
    <h2>
      计组-存储器
    </h2>
  </header>
  <section class="entry-content">
    <p>储存器基础 存储器种类 这张图画的不错,一个要注意的点,主存储器(内存)分为RAM和ROM RAM: Random Access Memory 可读可写,存取时间与物理地址无关 ROM: Read Only Memory 只能读,但是读的时间也与物理地址无关
主存储器  下面讲的都是主存储器,就是内存
 按照之前的理论,主存有MDR和MAR,两个重要的寄存器,MAR(Memory Address Register)用来存放访存的地址,访存指读或者写,MDR(Memory Data Register)访存的内容写在这里面.
在这两个寄存器上有许多其他电路辅助访存,MAR上有译码器和驱动器,根据MAR中内容找到找到数据在存储体中实际的位置译码器将地址分开,驱动器给使能信号啥的,MDR有读写控制,用于决定是读是写
一共有三种总线,地址总线,数据总线和控制总线,总线可以理解为并行接口,传输数据,地址总线和数据总线就不用说了,控制总线传输读写控制,芯片使能等控制信号
大致可以理解为这样
控制信号有点反直觉,只要上是上面加横杆的都代表低电平有效
译码驱动  这里一直在说一个芯片,芯片中必然有最小存储单元,这个最小的单元一般是1位,但是存储芯片的字长是多位的,这就需要多个最小芯片位于一个地址,同时输出信息
 线选法 芯片按行分开,地址就是对应哪一行,译码器就将地址分析成一行,然后这一行的最小的单元就被选中,进行读写电路
重合法 这是重合法的线路,首先我们将地址分为行地址和列地址,一行中有多个组,行地址代表选中这一行,列地址选定一组中的哪一个,因为有多个组因此可以输出指定字长的信号
Intel 2114的例子
可以看看这个,列地址有4位,代表一个组中最多就16个单位,行地址则有6位,代表有64行,然后数据总线是4位 ,因此有4组,这样整个的结构是64*64的.
示意图如上
时序 因为访存一次需要传输多种信号,因此我们需要定义好顺序,这个顺序是人为规定的,符合这个顺序的数据才能访存,否则无效.
行地址和地址可能是分开的,下面展示一个示意图
DRAM  Dynamic Random Access Memory 用电容的方式存储数据
 数据刷新 DRAM需要定时刷新,一共有三种常见的刷新方式
集中刷新 过一段时间刷新所有单元
一个周期刷新多少个单元是设计的问题,这里设计为了刷新一行的单元(反正是并行的)
刷新期间不能访存,称为死区
分散刷新 这种方式是访存一次就刷新一行,同时把刷新时间计算到访存中去,这样就没了死区问题,但是访存速度慢了
异步刷新 访存几次然后刷新一行(不是刷新全部),结合上述两种方式的新方式
还可以把刷新的时间设定在不访存的时候(指令译码阶段)这样就没有死区了.
存储器与CPU连接 容量: 1K*4位 1K-&gt;存储单元个数(地址长度) 4-&gt;字长,一个单元的长度
10条地址线,4条数据线就可以实现对这个存储器的访问.
按字寻址 按字节寻址
位扩展 1k*4 -&gt; 1k*8...</p>
  </section>
  <footer class="entry-footer">March 9, 2020
</footer>
  <a class="entry-link" aria-label="post link to 计组-存储器" href="http://example.org/posts/%E8%AE%A1%E7%BB%84-%E5%AD%98%E5%82%A8%E5%99%A8%E6%89%A9%E5%B1%95/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="http://example.org/">« Prev Page</a>
    <a class="next" href="http://example.org/page/3/">Next Page »</a>
  </nav>
</footer>

    </main><footer class="footer">
    <span>&copy; 2021 <a href="http://example.org/">My New Hugo Site</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
