<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Program-week10-homework | My New Hugo Site</title>

<meta name="keywords" content="Program, homework" />
<meta name="description" content="week10-homework A - 签到题 题面 解法 直接m/n看看是不能整除,不整除,直接输出-1
整除的话将得到的商先除2再除3,如果能够整除,就输出次数,不行输出-1
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt; using namespace std; int main() { int n,m; scanf(&#34;%d%d&#34;,&amp;n,&amp;m); if(m%n!=0||n&gt;m)//能整除  { printf(&#34;-1\n&#34;); return 0; } int t = m/n;//倍数  int i=0; while(t%2 == 0)//一直/2直到不能进行  { t/=2; i&#43;&#43;; } while(t%3 == 0)//一直除3直到不能进行  { t/=3; i&#43;&#43;; } if(t!=1)//除不尽  printf(&#34;-1\n&#34;); else //除尽  printf(&#34;%d\n&#34;,i); return 0; } 总结 问题不难,考虑除尽的情况即可
B - LIS &amp; LCS 题面 解法 这是一道DP的模板题">
<meta name="author" content="">
<link rel="canonical" href="https://xyfuture.github.io/posts/program-week10-homework/" />
<link href="/assets/css/stylesheet.min.5c4f6d85b7abfcfea458637c672d16a7a9c38c37f002753cfdc7f314b6d3c8f2.css" integrity="sha256-XE9thber/P6kWGN8Zy0Wp6nDjDfwAnU8/cfzFLbTyPI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://xyfuture.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xyfuture.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xyfuture.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xyfuture.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://xyfuture.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />


<meta property="og:title" content="Program-week10-homework" />
<meta property="og:description" content="week10-homework A - 签到题 题面 解法 直接m/n看看是不能整除,不整除,直接输出-1
整除的话将得到的商先除2再除3,如果能够整除,就输出次数,不行输出-1
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt; using namespace std; int main() { int n,m; scanf(&#34;%d%d&#34;,&amp;n,&amp;m); if(m%n!=0||n&gt;m)//能整除  { printf(&#34;-1\n&#34;); return 0; } int t = m/n;//倍数  int i=0; while(t%2 == 0)//一直/2直到不能进行  { t/=2; i&#43;&#43;; } while(t%3 == 0)//一直除3直到不能进行  { t/=3; i&#43;&#43;; } if(t!=1)//除不尽  printf(&#34;-1\n&#34;); else //除尽  printf(&#34;%d\n&#34;,i); return 0; } 总结 问题不难,考虑除尽的情况即可
B - LIS &amp; LCS 题面 解法 这是一道DP的模板题" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xyfuture.github.io/posts/program-week10-homework/" />
<meta property="article:published_time" content="2020-04-29T21:28:09+00:00" />
<meta property="article:modified_time" content="2020-04-29T21:28:09+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Program-week10-homework"/>
<meta name="twitter:description" content="week10-homework A - 签到题 题面 解法 直接m/n看看是不能整除,不整除,直接输出-1
整除的话将得到的商先除2再除3,如果能够整除,就输出次数,不行输出-1
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt; using namespace std; int main() { int n,m; scanf(&#34;%d%d&#34;,&amp;n,&amp;m); if(m%n!=0||n&gt;m)//能整除  { printf(&#34;-1\n&#34;); return 0; } int t = m/n;//倍数  int i=0; while(t%2 == 0)//一直/2直到不能进行  { t/=2; i&#43;&#43;; } while(t%3 == 0)//一直除3直到不能进行  { t/=3; i&#43;&#43;; } if(t!=1)//除不尽  printf(&#34;-1\n&#34;); else //除尽  printf(&#34;%d\n&#34;,i); return 0; } 总结 问题不难,考虑除尽的情况即可
B - LIS &amp; LCS 题面 解法 这是一道DP的模板题"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Program-week10-homework",
  "name": "Program-week10-homework",
  "description": "week10-homework A - 签到题 题面 解法 直接m/n看看是不能整除,不整除,直接输出-1\n整除的话将得到的商先除2再除3,如果能够整除,就输出次数,不行输出-1\ncode #include \u0026amp;lt;iostream\u0026amp;gt;#include \u0026amp;lt;cstdio\u0026amp;gt;#include \u0026amp;lt;cstring\u0026amp;gt;#include …",
  "keywords": [
    "Program", "homework"
  ],
  "articleBody": "week10-homework A - 签到题 题面 解法 直接m/n看看是不能整除,不整除,直接输出-1\n整除的话将得到的商先除2再除3,如果能够整除,就输出次数,不行输出-1\ncode #include #include #include #include  using namespace std; int main() { int n,m; scanf(\"%d%d\",\u0026n,\u0026m); if(m%n!=0||nm)//能整除  { printf(\"-1\\n\"); return 0; } int t = m/n;//倍数  int i=0; while(t%2 == 0)//一直/2直到不能进行  { t/=2; i++; } while(t%3 == 0)//一直除3直到不能进行  { t/=3; i++; } if(t!=1)//除不尽  printf(\"-1\\n\"); else //除尽  printf(\"%d\\n\",i); return 0; } 总结 问题不难,考虑除尽的情况即可\nB - LIS \u0026 LCS 题面 解法 这是一道DP的模板题\n对于LIS 最长上升子序列而言,使用1维dp即可\n$dp[j] = max(dp[i],\\ (data[i]$dp[j]$表示序列中第j个位置,以data[j]结尾的字符的LIS,全局的最大值要从整个序列中取最大值\n对于LRS最长公共子序列,需要使用二维的DP,因为涉及到对两个区间的操作\n$dp[i][j]$表示第一个序列第i个位置和第二个序列第j个位置的最长公共子序列长度\n状态转移方程如下:\n$A[i] == B[j]\\ \\ \\ \\ dp[i][j] = dp[i-1][j-1]+1$ $A[i]!=B[j]\\ \\ \\ \\ dp[i][j]=max(dp[i-1][j],dp[i][j-1])$\n初始化所有长度为0\ncode #include #include #include #include #include // #include  using namespace std; //最长上升子序列和最长公共子序列 int n,m; int A[5005];//两个序列原始信息 int B[5005]; int LIS[5005];//存储答案 int LRS[5005][5005]; int findLIS() { int allMax = 0;//最长上升子序列  for(int i=0;in;i++) { int temp = A[i]; int Max=0; for(int t=0;ti;t++) if(A[t]temp) if(LIS[t]Max)//状态转移方程  Max = LIS[t];//取比A[i]小的元素的最大值  LIS[i] = Max+1;//更新  if(Max+1allMax) allMax = Max+1; } return allMax; } void findLRS() { for(int i=1;in;i++) { for(int t=1;tm;t++) if(A[i-1] == B[t-1]) LRS[i][t] = LRS[i-1][t-1]+1;//相同更新加1  else LRS[i][t] = max(LRS[i-1][t],LRS[i][t-1]);//矩阵上方或则左侧  } } int main() { memset(LIS,0,sizeof(LIS)); memset(LRS,0,sizeof(LRS)); memset(A,0,sizeof(A)); memset(B,0,sizeof(B));//初始化  scanf(\"%d%d\",\u0026n,\u0026m); for(int i=0;in;i++) scanf(\"%d\",A+i); for(int i=0;im;i++) scanf(\"%d\",B+i); int maxELe = findLIS(); findLRS(); int ans2 = LRS[n][m]; printf(\"%d %d\",maxELe,ans2); return 0; } 总结 dp 四件套 状态表示 转移方程 初始条件 转移策略\n转移状态非常重要,LIS的状态表示没有直接给出要求的东西,但是能通过其他方法求取这个最大值,挺妙,得多想想\nC - 拿数问题 II 题面 解法 这道题是对课上题目的小改,其实就是对一开始输入的系列进行一些处理,首先排个序,然后将所有相同的值合并,构造两个新序列,$pdata[i]$表示新序列对应位置的原始值,$process[i]$是原序列中$pdata[i]$的值的和(就是相当于把相同的值都加起来,然后保留加和和原本的值).\n然后开始dp,$dp[i]$表示到第i个位置,总和最大值是多少​.\n$pdata[i]==pdata[i-1]+1\\ \\ \\ \\ dp[i]=max(process[i]+dp[i-2],dp[i-1])$\n$pdata[i]!=pdata[i-1]+1\\ \\ \\ \\ dp[i]=process[i]+dp[i-1]$\n初始化为0,然后从小到大开始dp即可\ncode #include #include #include #include using namespace std; long long data[100005];//原始数据 long long process[100005];//合并所有相同项后 long long ans[100005];//结果 long long pdata[100005];//process对应位置的原先的值 int n,m; int main() { memset(data,0,sizeof(data)); memset(process,0,sizeof(process)); memset(ans,0,sizeof(ans)); memset(pdata,0,sizeof(pdata));//初始化  scanf(\"%d\",\u0026n); for(int i=0;in;i++) scanf(\"%lld\",data+i); sort(data,data+n);//排序  m=0; for(int i=0;in;i++) { long long temp = data[i]; long long sum = data[i]; while(temp == data[i+1]) sum+=data[++i]; pdata[m]=temp;//原先的值  process[m++] = sum;//计算和  } ans[0] = process[0];//初始化  if(pdata[1] == pdata[0]+1) ans[1] = max(ans[0],process[1]); else ans[1] = ans[0]+process[1]; for(int i=2;im;i++) { if(pdata[i] == pdata[i-1]+1)//不能取前一个数  ans[i]= max(ans[i-1],process[i]+ans[i-2]); else//能取前一个数,直接加  ans[i] = ans[i-1]+process[i]; } printf(\"%lld\",ans[m-1]); } 总结 这道题数据范围需要稍微注意一下,可能会超int,dp的规则相较于课上讲的其实变化不大,只不过需要多一步预处理.\nCSP-模拟 A - 签到题 题面 解法 这道题就是非常简单的判断最大最小值问题\n题目让切分图形,最简单的就是长宽高方向切分,那么一共有三种面,求出最小的那个面就可以了\n数据给到了1e9,用int会爆,因此用long long\ncode #include #include #include #include #include  using namespace std; //数据范围用long long int main() { long long a,b,c; scanf(\"%lld%lld%lld\",\u0026a,\u0026b,\u0026c); if(a%2==0||b%2==0||c%2==0) { printf(\"0\"); return 0; } //找三个面最小的那一个  long long Min = b*c; if(Mina*b) Min = a*b; if(Mina*c) Min = a*c; printf(\"%lld\",Min); return 0; } 总结 难度不大,还是要关注一下数据范围,会超int\nB - 团 队 聚 会 题面 题面稍微有点长,大致意思就是又一系列区间,要求求出没有不区间覆盖为部分(或者仅被一个区间覆盖)\n解法 题目本身很简单,但是因为区间的格式有点复杂,是一个确切的时间,因此要针对时间进行处理 首先写一个时间结构体,这个结构体有6个变量,分别是年月日时分秒,用来对应输入的时间,然后写好比较函数\n然后写一个事件结构体event,包含两个时间点,一个起始时间,一个结束时间,然后两个时间点表示一段时间,这一段时间表示一个时间,用来存储输出的事件\n我们使用两个堆,一个堆allTime存储所有的时间点,就是每个人每个时间段的开始时间和结束时间,另一个是堆数组person,用来存储每个人的事件,堆中排序依据事件起始事件,用一个vector存储所有的空闲时间段\n编写事件处理函数,将每个人每个事件都存储为event,加入到对应的堆中,同时把每个时间也加入到allTime,\n然后从allTime中提出两个时间,组成一个event,检查这个event所有人是否有空,如果满足条件,满足条件就将这个event加入到vector中,一直重复到堆空\n检查过程就是先看看每个人堆顶的起始时间和待检测的结束时间关系,如果大于,则有空,如果小于,且待检测的开始时间晚于堆顶开始时间,待检测时间结束时间早于堆顶结束时间,则说明有事,如果堆顶结束时间早于待检测开始时间,弹出堆顶,继续检测\n最终所有有空的时间都到了vector中,我们要输出这个时间,这其中有连续的时间被分割成多个连续片段的情况,因此要先合并,然后检查合并后的时间长度是否大于1h,是就输出.\ncode #include #include #include #include #include #include #include #include using namespace std; struct time { int dataInfo[6];//时间从年到秒  bool operator  (const time\u0026 op) const //重载操作符 一定要是const  { for(int i=0;i6;i++) if(dataInfo[i]op.dataInfo[i]) return true; else if(dataInfo[i] == op.dataInfo[i]) continue; else return false; return false; } bool operator == (const time\u0026 op)const { for(int i=0;i6;i++) if(dataInfo[i]!=op.dataInfo[i]) return false; return true; } bool operator (const time\u0026 op)const { for(int i=0;i6;i++) if(dataInfo[i]op.dataInfo[i]) return true; else if(dataInfo[i] == op.dataInfo[i]) continue; else return false; return false; } bool operator (const time\u0026 op)const { for(int i=0;i6;i++) if(dataInfo[i]op.dataInfo[i]) return true; else if(dataInfo[i] == op.dataInfo[i]) continue; else return false; for(int i=0;i6;i++) if(dataInfo[i]!=op.dataInfo[i]) return false; return true; } //起始写麻烦了,可以写一个然后调用  time(){}; time(int year,int month,int day,int hour,int minute,int second) { dataInfo[0] = year; dataInfo[1] = month; dataInfo[2] = day; dataInfo[3] = hour; dataInfo[4] = minute; dataInfo[5] = second; } }; struct event { //一个时间,包括起始时间和结束时间  time startTime; time endTime; bool operator  (const event\u0026 op) const { return startTime  op.startTime;} }; //最小堆 priority_queuetime,vectortime,greatertime  allTime;//所有时间点的数组 priority_queueevent,vectorevent,greaterevent  person[22];//每个人的事件 vectorevent freeTime;//存储一小段一小段能开会的时间 int perCnt;//人数  event readTime()//读入一个时间 { event tempEvent; for(int i=0;i6;i++) scanf(\"%d\",tempEvent.startTime.dataInfo+i); for(int i=0;i6;i++) scanf(\"%d\",tempEvent.endTime.dataInfo+i); while(getchar()!='\\n')//去除后面没用的文字  continue; return tempEvent; } int checkFree(int ptr,const event\u0026 curTime)//检查一个人在一个时间段是不是有空的 { if(person[ptr].empty())//什么事都没了  return 1; event curEvent = person[ptr].top();//最靠前的事  if(curTime.endTime  curEvent.startTime)//当前没有事  return 1; if(curEvent.startTimecurTime.startTime\u0026\u0026curTime.endTimecurEvent.endTime)//当前有事  return 0; if(curEvent.endTimecurTime.startTime)//当前的事已经干完了,取下一个事  { person[ptr].pop(); return checkFree(ptr,curTime); } return 0; } int checkAllPerson()//检查所有人的时间情况 { event curEvent;//当前时间段  while(!allTime.empty())//时间点不空  { curEvent.startTime = allTime.top(); allTime.pop(); if(allTime.empty()) break; curEvent.endTime = allTime.top();//取两个时间点组成一个时间片段,检查时间片段内是否能开会  if(curEvent.startTime == curEvent.endTime)//无效时间片段  continue; int cnt =0; for(int i=0;iperCnt;i++) cnt+=checkFree(i,curEvent);//有空人的个数  if(cnt=perCnt-1\u0026\u0026cnt=2)//能开会  freeTime.push_back(curEvent);//将开会时间片段放入freeTime  } return 0; } void printMin(const time\u0026 t,int i)//输出时间的每一个小段 { if(t.dataInfo[i]=10) printf(\"%d\",t.dataInfo[i]); else if(t.dataInfo[i]10\u0026\u0026t.dataInfo[i]0) printf(\"0%d\",t.dataInfo[i]); else if(t.dataInfo[i] == 0) printf(\"00\"); } void printTime(const time\u0026 s)//输出时间 { printMin(s,1); printf(\"/\"); printMin(s,2); printf(\"/\"); printMin(s,0); printf(\" \"); printMin(s,3); printf(\":\"); printMin(s,4); printf(\":\"); printMin(s,5); } bool checkLimit(time s,time e)//检查时间段下限,时间要超过1h { time newTime ; int t= 2; if(s.dataInfo[3]+1=24) { newTime.dataInfo[3] = 0; if(s.dataInfo[2]+1=31) { newTime.dataInfo[2] = 1; if(s.dataInfo[1]+1=13) { newTime.dataInfo[1] = 1; newTime.dataInfo[0] = s.dataInfo[0]+1; t = -1; } else { newTime.dataInfo[1] = s.dataInfo[1]+1; t=0; } } else { newTime.dataInfo[2] = s.dataInfo[2]+1; t=1; } } else newTime.dataInfo[3] = s.dataInfo[3]+1; for(int i=0;it;i++) newTime.dataInfo[i] = s.dataInfo[i]; newTime.dataInfo[4]= s.dataInfo[4]; newTime.dataInfo[5] = s.dataInfo[5]; return newTimee; } void output() { event startEvent; event endEvent; time st; time et; int flag = 1;//没有可用时间标置  for(int i=0;ifreeTime.size();i++) { st = freeTime[i].startTime; et = freeTime[i].endTime; while(ifreeTime.size()-1)//多个时间段可能是连着的,需要合成一个  { if(et == freeTime[i+1].startTime)//头尾相连  et=freeTime[++i].endTime; else break; } if(!checkLimit(st,et)) continue; flag = 0;//有可用时间  printf(\"appointment possible from \"); printTime(st); printf(\" to \"); printTime(et); printf(\"\\n\"); } if(flag) printf(\"no appointment possible\\n\"); } int main() { int t; scanf(\"%d\",\u0026t); int flag = 1; for(int i=0;it;i++) { if(flag == 0)//输出格式  { printf(\"\\n\"); } flag = 0; scanf(\"%d\",\u0026perCnt); for(int c=0;cperCnt;c++) while(!person[c].empty()) person[c].pop(); while(!allTime.empty()) allTime.pop(); freeTime.clear();//清空  int endCheck = 1; time rbegin(1800,1,1,0,0,0);//总的开始时间  time rend(2200,1,1,0,0,0);//总的结束时间  for(int j=0;jperCnt;j++) { int n; scanf(\"%d\",\u0026n); for(int m=0;mn;m++) { event tempEve = readTime(); person[j].push(tempEve);//每个人的事件  if(tempEve.endTime == rend) endCheck = 0; allTime.push(tempEve.startTime);//每一个时间点  allTime.push(tempEve.endTime); } } if(!(allTime.top()==rbegin))//重复插入,其实不用管  allTime.push(rbegin); if(endCheck) allTime.push(rend); checkAllPerson(); printf(\"Scenario #%d:\\n\",i+1); output(); } return 0; } 总结 这道题思路不麻烦,难的是代码的编写,这次写的非常丑,时间比较那里可以简化一下,同时可以把时间直接转换为秒,代码量更少.\n",
  "wordCount" : "862",
  "inLanguage": "en",
  "datePublished": "2020-04-29T21:28:09Z",
  "dateModified": "2020-04-29T21:28:09Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xyfuture.github.io/posts/program-week10-homework/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xyfuture.github.io/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xyfuture.github.io/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()"></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Program-week10-homework
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">April 29, 2020

    </div>
  </header> 

  <div class="post-content">
<h1 id="week10-homework">week10-homework<a hidden class="anchor" aria-hidden="true" href="#week10-homework">#</a></h1>
<h2 id="a---签到题httpsvjudgenetproblemcodeforces-1141a"><a href="https://vjudge.net/problem/CodeForces-1141A">A - 签到题</a><a hidden class="anchor" aria-hidden="true" href="#a---签到题httpsvjudgenetproblemcodeforces-1141a">#</a></h2>
<h3 id="题面">题面<a hidden class="anchor" aria-hidden="true" href="#题面">#</a></h3>
<p><img src="https://i.loli.net/2020/05/13/oWrKmnd8pHkwOzN.png" alt=""></p>
<h3 id="解法">解法<a hidden class="anchor" aria-hidden="true" href="#解法">#</a></h3>
<p>直接m/n看看是不能整除,不整除,直接输出-1</p>
<p>整除的话将得到的商先除2再除3,如果能够整除,就输出次数,不行输出-1</p>
<h3 id="code">code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> n,m;
    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>n,<span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">if</span>(m<span style="color:#f92672">%</span>n<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>n<span style="color:#f92672">&gt;</span>m)<span style="color:#75715e">//能整除
</span><span style="color:#75715e"></span>    {
        printf(<span style="color:#e6db74">&#34;-1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> m<span style="color:#f92672">/</span>n;<span style="color:#75715e">//倍数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span>(t<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//一直/2直到不能进行
</span><span style="color:#75715e"></span>    {
        t<span style="color:#f92672">/=</span><span style="color:#ae81ff">2</span>;
        i<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">while</span>(t<span style="color:#f92672">%</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//一直除3直到不能进行
</span><span style="color:#75715e"></span>    {
        t<span style="color:#f92672">/=</span><span style="color:#ae81ff">3</span>;
        i<span style="color:#f92672">++</span>;
    }
    <span style="color:#66d9ef">if</span>(t<span style="color:#f92672">!=</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//除不尽
</span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;-1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">else</span> <span style="color:#75715e">//除尽
</span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,i);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>问题不难,考虑除尽的情况即可</p>
<h2 id="b---lis--lcshttpsvjudgenetproblemgym-277140a"><a href="https://vjudge.net/problem/Gym-277140A">B - LIS &amp; LCS</a><a hidden class="anchor" aria-hidden="true" href="#b---lis--lcshttpsvjudgenetproblemgym-277140a">#</a></h2>
<h3 id="题面-1">题面<a hidden class="anchor" aria-hidden="true" href="#题面-1">#</a></h3>
<p><img src="https://i.loli.net/2020/05/13/ImC1iALlYHBNZXf.png" alt="image-20200513115536949"></p>
<h3 id="解法-1">解法<a hidden class="anchor" aria-hidden="true" href="#解法-1">#</a></h3>
<p>这是一道DP的模板题</p>
<p>对于LIS 最长上升子序列而言,使用1维dp即可</p>
<p>$dp[j] = max(dp[i],\ (data[i]&lt;data[j],\ i&lt;j))+1$</p>
<p>$dp[j]$表示序列中第j个位置,以data[j]结尾的字符的LIS,全局的最大值要从整个序列中取最大值</p>
<p>对于LRS最长公共子序列,需要使用二维的DP,因为涉及到对两个区间的操作</p>
<p>$dp[i][j]$表示第一个序列第i个位置和第二个序列第j个位置的最长公共子序列长度</p>
<p>状态转移方程如下:</p>
<p>$A[i] == B[j]\ \ \ \ dp[i][j] = dp[i-1][j-1]+1$
$A[i]!=B[j]\ \ \ \ dp[i][j]=max(dp[i-1][j],dp[i][j-1])$</p>
<p>初始化所有长度为0</p>
<h3 id="code-1">code<a hidden class="anchor" aria-hidden="true" href="#code-1">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">// #include &lt;algorithm&gt;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">//最长上升子序列和最长公共子序列
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n,m;
<span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">5005</span>];<span style="color:#75715e">//两个序列原始信息
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> B[<span style="color:#ae81ff">5005</span>];
<span style="color:#66d9ef">int</span> LIS[<span style="color:#ae81ff">5005</span>];<span style="color:#75715e">//存储答案
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> LRS[<span style="color:#ae81ff">5005</span>][<span style="color:#ae81ff">5005</span>];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">findLIS</span>()
{
    <span style="color:#66d9ef">int</span> allMax <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//最长上升子序列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> A[i];
        <span style="color:#66d9ef">int</span> Max<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;t<span style="color:#f92672">&lt;</span>i;t<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(A[t]<span style="color:#f92672">&lt;</span>temp)
                <span style="color:#66d9ef">if</span>(LIS[t]<span style="color:#f92672">&gt;</span>Max)<span style="color:#75715e">//状态转移方程
</span><span style="color:#75715e"></span>                    Max <span style="color:#f92672">=</span> LIS[t];<span style="color:#75715e">//取比A[i]小的元素的最大值
</span><span style="color:#75715e"></span>        LIS[i] <span style="color:#f92672">=</span> Max<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//更新
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(Max<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>allMax)
            allMax <span style="color:#f92672">=</span> Max<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> allMax;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">findLRS</span>()
{
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;t<span style="color:#f92672">&lt;=</span>m;t<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(A[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> B[t<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])
                LRS[i][t] <span style="color:#f92672">=</span> LRS[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][t<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//相同更新加1
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span> 
                LRS[i][t] <span style="color:#f92672">=</span> max(LRS[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>][t],LRS[i][t<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);<span style="color:#75715e">//矩阵上方或则左侧
</span><span style="color:#75715e"></span>    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    memset(LIS,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(LIS));
    memset(LRS,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(LRS));
    memset(A,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(A));
    memset(B,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(B));<span style="color:#75715e">//初始化
</span><span style="color:#75715e"></span>    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>n,<span style="color:#f92672">&amp;</span>m);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,A<span style="color:#f92672">+</span>i);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>m;i<span style="color:#f92672">++</span>)
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,B<span style="color:#f92672">+</span>i);
    <span style="color:#66d9ef">int</span> maxELe <span style="color:#f92672">=</span> findLIS();
    findLRS();
    <span style="color:#66d9ef">int</span> ans2 <span style="color:#f92672">=</span> LRS[n][m];
    printf(<span style="color:#e6db74">&#34;%d %d&#34;</span>,maxELe,ans2);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h3>
<p>dp 四件套 状态表示 转移方程 初始条件 转移策略</p>
<p>转移状态非常重要,LIS的状态表示没有直接给出要求的东西,但是能通过其他方法求取这个最大值,挺妙,得多想想</p>
<h2 id="c---拿数问题-iihttpsvjudgenetproblemcodeforces-455a"><a href="https://vjudge.net/problem/CodeForces-455A">C - 拿数问题 II</a><a hidden class="anchor" aria-hidden="true" href="#c---拿数问题-iihttpsvjudgenetproblemcodeforces-455a">#</a></h2>
<h3 id="题面-2">题面<a hidden class="anchor" aria-hidden="true" href="#题面-2">#</a></h3>
<p><img src="https://i.loli.net/2020/05/13/LAEqapWsrVHfM5w.png" alt=""></p>
<h3 id="解法-2">解法<a hidden class="anchor" aria-hidden="true" href="#解法-2">#</a></h3>
<p>这道题是对课上题目的小改,其实就是对一开始输入的系列进行一些处理,首先排个序,然后将所有相同的值合并,构造两个新序列,$pdata[i]$表示新序列对应位置的原始值,$process[i]$是原序列中$pdata[i]$的值的和(就是相当于把相同的值都加起来,然后保留加和和原本的值).</p>
<p>然后开始dp,$dp[i]$表示到第i个位置,总和最大值是多少​.</p>
<p>$pdata[i]==pdata[i-1]+1\ \ \ \ dp[i]=max(process[i]+dp[i-2],dp[i-1])$</p>
<p>$pdata[i]!=pdata[i-1]+1\ \ \ \ dp[i]=process[i]+dp[i-1]$</p>
<p>初始化为0,然后从小到大开始dp即可</p>
<h3 id="code-2">code<a hidden class="anchor" aria-hidden="true" href="#code-2">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> data[<span style="color:#ae81ff">100005</span>];<span style="color:#75715e">//原始数据
</span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> process[<span style="color:#ae81ff">100005</span>];<span style="color:#75715e">//合并所有相同项后
</span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ans[<span style="color:#ae81ff">100005</span>];<span style="color:#75715e">//结果
</span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> pdata[<span style="color:#ae81ff">100005</span>];<span style="color:#75715e">//process对应位置的原先的值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> n,m;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    memset(data,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(data));
    memset(process,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(process));
    memset(ans,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(ans));
    memset(pdata,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(pdata));<span style="color:#75715e">//初始化
</span><span style="color:#75715e"></span>    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
        scanf(<span style="color:#e6db74">&#34;%lld&#34;</span>,data<span style="color:#f92672">+</span>i);
    sort(data,data<span style="color:#f92672">+</span>n);<span style="color:#75715e">//排序
</span><span style="color:#75715e"></span>    m<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> temp <span style="color:#f92672">=</span> data[i];
        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> sum <span style="color:#f92672">=</span> data[i];
        <span style="color:#66d9ef">while</span>(temp <span style="color:#f92672">==</span> data[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>])
            sum<span style="color:#f92672">+=</span>data[<span style="color:#f92672">++</span>i];
        pdata[m]<span style="color:#f92672">=</span>temp;<span style="color:#75715e">//原先的值
</span><span style="color:#75715e"></span>        process[m<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> sum;<span style="color:#75715e">//计算和
</span><span style="color:#75715e"></span>    }
    ans[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> process[<span style="color:#ae81ff">0</span>];<span style="color:#75715e">//初始化
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(pdata[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">==</span> pdata[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
        ans[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> max(ans[<span style="color:#ae81ff">0</span>],process[<span style="color:#ae81ff">1</span>]);
    <span style="color:#66d9ef">else</span>
        ans[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> ans[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">+</span>process[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">&lt;</span>m;i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">if</span>(pdata[i] <span style="color:#f92672">==</span> pdata[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//不能取前一个数
</span><span style="color:#75715e"></span>            ans[i]<span style="color:#f92672">=</span> max(ans[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>],process[i]<span style="color:#f92672">+</span>ans[i<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]);
        <span style="color:#66d9ef">else</span><span style="color:#75715e">//能取前一个数,直接加
</span><span style="color:#75715e"></span>            ans[i] <span style="color:#f92672">=</span> ans[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>process[i];
    }
    printf(<span style="color:#e6db74">&#34;%lld&#34;</span>,ans[m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);
}

</code></pre></div><h3 id="总结-2">总结<a hidden class="anchor" aria-hidden="true" href="#总结-2">#</a></h3>
<p>这道题数据范围需要稍微注意一下,可能会超int,dp的规则相较于课上讲的其实变化不大,只不过需要多一步预处理.</p>
<h1 id="csp-模拟">CSP-模拟<a hidden class="anchor" aria-hidden="true" href="#csp-模拟">#</a></h1>
<h2 id="a---签到题httpsvjudgenetproblematcoder-2041"><a href="https://vjudge.net/problem/AtCoder-2041">A - 签到题</a><a hidden class="anchor" aria-hidden="true" href="#a---签到题httpsvjudgenetproblematcoder-2041">#</a></h2>
<h3 id="题面-3">题面<a hidden class="anchor" aria-hidden="true" href="#题面-3">#</a></h3>
<p><img src="https://i.loli.net/2020/05/13/LuBieR152XMxVjz.png" alt=""></p>
<h3 id="解法-3">解法<a hidden class="anchor" aria-hidden="true" href="#解法-3">#</a></h3>
<p>这道题就是非常简单的判断最大最小值问题</p>
<p>题目让切分图形,最简单的就是长宽高方向切分,那么一共有三种面,求出最小的那个面就可以了</p>
<p>数据给到了1e9,用int会爆,因此用long long</p>
<h3 id="code-3">code<a hidden class="anchor" aria-hidden="true" href="#code-3">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">//数据范围用long long
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> a,b,c;
    scanf(<span style="color:#e6db74">&#34;%lld%lld%lld&#34;</span>,<span style="color:#f92672">&amp;</span>a,<span style="color:#f92672">&amp;</span>b,<span style="color:#f92672">&amp;</span>c);
    <span style="color:#66d9ef">if</span>(a<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span><span style="color:#f92672">==</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>b<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span><span style="color:#f92672">==</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>c<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span><span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
    {
        printf(<span style="color:#e6db74">&#34;0&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
    <span style="color:#75715e">//找三个面最小的那一个
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> Min <span style="color:#f92672">=</span> b<span style="color:#f92672">*</span>c;
    <span style="color:#66d9ef">if</span>(Min<span style="color:#f92672">&gt;</span>a<span style="color:#f92672">*</span>b)
        Min <span style="color:#f92672">=</span> a<span style="color:#f92672">*</span>b;
    <span style="color:#66d9ef">if</span>(Min<span style="color:#f92672">&gt;</span>a<span style="color:#f92672">*</span>c)
        Min <span style="color:#f92672">=</span> a<span style="color:#f92672">*</span>c;
    printf(<span style="color:#e6db74">&#34;%lld&#34;</span>,Min);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="总结-3">总结<a hidden class="anchor" aria-hidden="true" href="#总结-3">#</a></h3>
<p>难度不大,还是要关注一下数据范围,会超int</p>
<h2 id="b---团-队-聚-会httpsvjudgenetproblempoj-1960"><a href="https://vjudge.net/problem/POJ-1960">B - 团 队 聚 会</a><a hidden class="anchor" aria-hidden="true" href="#b---团-队-聚-会httpsvjudgenetproblempoj-1960">#</a></h2>
<h3 id="题面-4">题面<a hidden class="anchor" aria-hidden="true" href="#题面-4">#</a></h3>
<p><img src="https://i.loli.net/2020/05/13/tWUm59dogr6XBsP.png" alt="image-20200513142515530"></p>
<p>题面稍微有点长,大致意思就是又一系列区间,要求求出没有不区间覆盖为部分(或者仅被一个区间覆盖)</p>
<h3 id="解法-4">解法<a hidden class="anchor" aria-hidden="true" href="#解法-4">#</a></h3>
<p>题目本身很简单,但是因为区间的格式有点复杂,是一个确切的时间,因此要针对时间进行处理
首先写一个时间结构体,这个结构体有6个变量,分别是年月日时分秒,用来对应输入的时间,然后写好比较函数</p>
<p>然后写一个事件结构体event,包含两个时间点,一个起始时间,一个结束时间,然后两个时间点表示一段时间,这一段时间表示一个时间,用来存储输出的事件</p>
<p>我们使用两个堆,一个堆allTime存储所有的时间点,就是每个人每个时间段的开始时间和结束时间,另一个是堆数组person,用来存储每个人的事件,堆中排序依据事件起始事件,用一个vector存储所有的空闲时间段</p>
<p>编写事件处理函数,将每个人每个事件都存储为event,加入到对应的堆中,同时把每个时间也加入到allTime,</p>
<p>然后从allTime中提出两个时间,组成一个event,检查这个event所有人是否有空,如果满足条件,满足条件就将这个event加入到vector中,一直重复到堆空</p>
<p>检查过程就是先看看每个人堆顶的起始时间和待检测的结束时间关系,如果大于,则有空,如果小于,且待检测的开始时间晚于堆顶开始时间,待检测时间结束时间早于堆顶结束时间,则说明有事,如果堆顶结束时间早于待检测开始时间,弹出堆顶,继续检测</p>
<p>最终所有有空的时间都到了vector中,我们要输出这个时间,这其中有连续的时间被分割成多个连续片段的情况,因此要先合并,然后检查合并后的时间长度是否大于1h,是就输出.</p>
<h3 id="code-4">code<a hidden class="anchor" aria-hidden="true" href="#code-4">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">time</span>
{
    <span style="color:#66d9ef">int</span> dataInfo[<span style="color:#ae81ff">6</span>];<span style="color:#75715e">//时间从年到秒
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> time<span style="color:#f92672">&amp;</span> op) <span style="color:#66d9ef">const</span> <span style="color:#75715e">//重载操作符 一定要是const
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">6</span>;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(dataInfo[i]<span style="color:#f92672">&lt;</span>op.dataInfo[i])
                <span style="color:#66d9ef">return</span> true;
            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(dataInfo[i] <span style="color:#f92672">==</span> op.dataInfo[i])
                <span style="color:#66d9ef">continue</span>;
            <span style="color:#66d9ef">else</span>
                <span style="color:#66d9ef">return</span> false;            
        <span style="color:#66d9ef">return</span> false;
    }
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">==</span> (<span style="color:#66d9ef">const</span> time<span style="color:#f92672">&amp;</span>  op)<span style="color:#66d9ef">const</span> 
    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">6</span>;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(dataInfo[i]<span style="color:#f92672">!=</span>op.dataInfo[i])
                <span style="color:#66d9ef">return</span> false;
        <span style="color:#66d9ef">return</span> true;
    }
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&gt;</span>(<span style="color:#66d9ef">const</span> time<span style="color:#f92672">&amp;</span> op)<span style="color:#66d9ef">const</span> 
    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">6</span>;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(dataInfo[i]<span style="color:#f92672">&gt;</span>op.dataInfo[i])
                <span style="color:#66d9ef">return</span> true;
            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(dataInfo[i] <span style="color:#f92672">==</span> op.dataInfo[i])
                <span style="color:#66d9ef">continue</span>;
            <span style="color:#66d9ef">else</span>
                <span style="color:#66d9ef">return</span> false;  
        <span style="color:#66d9ef">return</span> false;
    }
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&lt;=</span>(<span style="color:#66d9ef">const</span> time<span style="color:#f92672">&amp;</span> op)<span style="color:#66d9ef">const</span> 
    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">6</span>;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(dataInfo[i]<span style="color:#f92672">&lt;</span>op.dataInfo[i])
                <span style="color:#66d9ef">return</span> true;
            <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span>(dataInfo[i] <span style="color:#f92672">==</span> op.dataInfo[i])
                <span style="color:#66d9ef">continue</span>;
            <span style="color:#66d9ef">else</span>
                <span style="color:#66d9ef">return</span> false;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">6</span>;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(dataInfo[i]<span style="color:#f92672">!=</span>op.dataInfo[i])
                <span style="color:#66d9ef">return</span> false;
        <span style="color:#66d9ef">return</span> true;    
    }
    <span style="color:#75715e">//起始写麻烦了,可以写一个然后调用
</span><span style="color:#75715e"></span>    time(){};
    time(<span style="color:#66d9ef">int</span> year,<span style="color:#66d9ef">int</span> month,<span style="color:#66d9ef">int</span> day,<span style="color:#66d9ef">int</span> hour,<span style="color:#66d9ef">int</span> minute,<span style="color:#66d9ef">int</span> second)
    {
        dataInfo[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> year;
        dataInfo[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> month;
        dataInfo[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> day;
        dataInfo[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> hour;
        dataInfo[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> minute;
        dataInfo[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> second;
    }
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">event</span> 
{ <span style="color:#75715e">//一个时间,包括起始时间和结束时间
</span><span style="color:#75715e"></span>    time startTime;
    time endTime;
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&gt;</span> (<span style="color:#66d9ef">const</span> event<span style="color:#f92672">&amp;</span> op) <span style="color:#66d9ef">const</span> 
    { <span style="color:#66d9ef">return</span> startTime <span style="color:#f92672">&gt;</span> op.startTime;}
};
<span style="color:#75715e">//最小堆
</span><span style="color:#75715e"></span>priority_queue<span style="color:#f92672">&lt;</span>time,vector<span style="color:#f92672">&lt;</span>time<span style="color:#f92672">&gt;</span>,greater<span style="color:#f92672">&lt;</span>time<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> allTime;<span style="color:#75715e">//所有时间点的数组
</span><span style="color:#75715e"></span>priority_queue<span style="color:#f92672">&lt;</span>event,vector<span style="color:#f92672">&lt;</span>event<span style="color:#f92672">&gt;</span>,greater<span style="color:#f92672">&lt;</span>event<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> person[<span style="color:#ae81ff">22</span>];<span style="color:#75715e">//每个人的事件
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span>event<span style="color:#f92672">&gt;</span> freeTime;<span style="color:#75715e">//存储一小段一小段能开会的时间
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> perCnt;<span style="color:#75715e">//人数
</span><span style="color:#75715e"></span>
event <span style="color:#a6e22e">readTime</span>()<span style="color:#75715e">//读入一个时间
</span><span style="color:#75715e"></span>{
    event tempEvent;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">6</span>;i<span style="color:#f92672">++</span>)
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,tempEvent.startTime.dataInfo<span style="color:#f92672">+</span>i);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">6</span>;i<span style="color:#f92672">++</span>)
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,tempEvent.endTime.dataInfo<span style="color:#f92672">+</span>i);
    <span style="color:#66d9ef">while</span>(getchar()<span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;\n&#39;</span>)<span style="color:#75715e">//去除后面没用的文字
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">continue</span>;
    <span style="color:#66d9ef">return</span> tempEvent;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">checkFree</span>(<span style="color:#66d9ef">int</span> ptr,<span style="color:#66d9ef">const</span> event<span style="color:#f92672">&amp;</span> curTime)<span style="color:#75715e">//检查一个人在一个时间段是不是有空的
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">if</span>(person[ptr].empty())<span style="color:#75715e">//什么事都没了
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    event curEvent <span style="color:#f92672">=</span> person[ptr].top();<span style="color:#75715e">//最靠前的事
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(curTime.endTime <span style="color:#f92672">&lt;=</span> curEvent.startTime)<span style="color:#75715e">//当前没有事
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">if</span>(curEvent.startTime<span style="color:#f92672">&lt;=</span>curTime.startTime<span style="color:#f92672">&amp;&amp;</span>curTime.endTime<span style="color:#f92672">&lt;=</span>curEvent.endTime)<span style="color:#75715e">//当前有事
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">if</span>(curEvent.endTime<span style="color:#f92672">&lt;=</span>curTime.startTime)<span style="color:#75715e">//当前的事已经干完了,取下一个事
</span><span style="color:#75715e"></span>    {
        person[ptr].pop();
        <span style="color:#66d9ef">return</span> checkFree(ptr,curTime);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">checkAllPerson</span>()<span style="color:#75715e">//检查所有人的时间情况
</span><span style="color:#75715e"></span>{
    event curEvent;<span style="color:#75715e">//当前时间段
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>allTime.empty())<span style="color:#75715e">//时间点不空
</span><span style="color:#75715e"></span>    {
        curEvent.startTime <span style="color:#f92672">=</span> allTime.top();
        allTime.pop();
        <span style="color:#66d9ef">if</span>(allTime.empty())
            <span style="color:#66d9ef">break</span>;
        curEvent.endTime <span style="color:#f92672">=</span> allTime.top();<span style="color:#75715e">//取两个时间点组成一个时间片段,检查时间片段内是否能开会
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(curEvent.startTime <span style="color:#f92672">==</span> curEvent.endTime)<span style="color:#75715e">//无效时间片段
</span><span style="color:#75715e"></span>        	<span style="color:#66d9ef">continue</span>;
        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>perCnt;i<span style="color:#f92672">++</span>)
            cnt<span style="color:#f92672">+=</span>checkFree(i,curEvent);<span style="color:#75715e">//有空人的个数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(cnt<span style="color:#f92672">&gt;=</span>perCnt<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&amp;&amp;</span>cnt<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">2</span>)<span style="color:#75715e">//能开会
</span><span style="color:#75715e"></span>            freeTime.push_back(curEvent);<span style="color:#75715e">//将开会时间片段放入freeTime
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printMin</span>(<span style="color:#66d9ef">const</span> time<span style="color:#f92672">&amp;</span> t,<span style="color:#66d9ef">int</span> i)<span style="color:#75715e">//输出时间的每一个小段
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">if</span>(t.dataInfo[i]<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">10</span>)
        printf(<span style="color:#e6db74">&#34;%d&#34;</span>,t.dataInfo[i]);
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(t.dataInfo[i]<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span><span style="color:#f92672">&amp;&amp;</span>t.dataInfo[i]<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)
        printf(<span style="color:#e6db74">&#34;0%d&#34;</span>,t.dataInfo[i]);
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(t.dataInfo[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        printf(<span style="color:#e6db74">&#34;00&#34;</span>);
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">printTime</span>(<span style="color:#66d9ef">const</span> time<span style="color:#f92672">&amp;</span> s)<span style="color:#75715e">//输出时间
</span><span style="color:#75715e"></span>{
    printMin(s,<span style="color:#ae81ff">1</span>);
    printf(<span style="color:#e6db74">&#34;/&#34;</span>);
    printMin(s,<span style="color:#ae81ff">2</span>);
    printf(<span style="color:#e6db74">&#34;/&#34;</span>);
    printMin(s,<span style="color:#ae81ff">0</span>);
    printf(<span style="color:#e6db74">&#34; &#34;</span>);
    printMin(s,<span style="color:#ae81ff">3</span>);
    printf(<span style="color:#e6db74">&#34;:&#34;</span>);
    printMin(s,<span style="color:#ae81ff">4</span>);
    printf(<span style="color:#e6db74">&#34;:&#34;</span>);
    printMin(s,<span style="color:#ae81ff">5</span>);
}
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">checkLimit</span>(time s,time e)<span style="color:#75715e">//检查时间段下限,时间要超过1h
</span><span style="color:#75715e"></span>{
    time newTime ;
    <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
    <span style="color:#66d9ef">if</span>(s.dataInfo[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">24</span>)
    {
        newTime.dataInfo[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">if</span>(s.dataInfo[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">31</span>)
        {
            newTime.dataInfo[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">if</span>(s.dataInfo[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">13</span>)
            {
                newTime.dataInfo[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                newTime.dataInfo[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> s.dataInfo[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
                t <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
            }
            <span style="color:#66d9ef">else</span>
            {
            	newTime.dataInfo[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> s.dataInfo[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
            	t<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
			}
        }
        <span style="color:#66d9ef">else</span>
        {
        	newTime.dataInfo[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> s.dataInfo[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
        	t<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
		}
    }
    <span style="color:#66d9ef">else</span> 
    	newTime.dataInfo[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> s.dataInfo[<span style="color:#ae81ff">3</span>]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;=</span>t;i<span style="color:#f92672">++</span>)
        newTime.dataInfo[i] <span style="color:#f92672">=</span> s.dataInfo[i];
    newTime.dataInfo[<span style="color:#ae81ff">4</span>]<span style="color:#f92672">=</span> s.dataInfo[<span style="color:#ae81ff">4</span>];
    newTime.dataInfo[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> s.dataInfo[<span style="color:#ae81ff">5</span>];
    <span style="color:#66d9ef">return</span> newTime<span style="color:#f92672">&lt;=</span>e;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">output</span>()
{
    event startEvent;
    event endEvent;
    time st;
    time et;
    <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//没有可用时间标置
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>freeTime.size();i<span style="color:#f92672">++</span>)
    {
        st <span style="color:#f92672">=</span> freeTime[i].startTime;
        et <span style="color:#f92672">=</span> freeTime[i].endTime;
        <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>freeTime.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//多个时间段可能是连着的,需要合成一个
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">if</span>(et <span style="color:#f92672">==</span> freeTime[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].startTime)<span style="color:#75715e">//头尾相连
</span><span style="color:#75715e"></span>                et<span style="color:#f92672">=</span>freeTime[<span style="color:#f92672">++</span>i].endTime;
            <span style="color:#66d9ef">else</span>
                <span style="color:#66d9ef">break</span>;
        }
        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>checkLimit(st,et))
            <span style="color:#66d9ef">continue</span>;
        flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//有可用时间
</span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;appointment possible from &#34;</span>);
        printTime(st);
        printf(<span style="color:#e6db74">&#34; to &#34;</span>);
        printTime(et);
        printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
    <span style="color:#66d9ef">if</span>(flag)
    	printf(<span style="color:#e6db74">&#34;no appointment possible</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>); 
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> t;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>t);
    <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>t;i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">if</span>(flag <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//输出格式
</span><span style="color:#75715e"></span>        {
            printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        }
        flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>perCnt);
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> c<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;c<span style="color:#f92672">&lt;</span>perCnt;c<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>person[c].empty()) 
            	person[c].pop();
        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>allTime.empty())
            allTime.pop();
        freeTime.clear();<span style="color:#75715e">//清空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> endCheck <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        time rbegin(<span style="color:#ae81ff">1800</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);<span style="color:#75715e">//总的开始时间
</span><span style="color:#75715e"></span>        time rend(<span style="color:#ae81ff">2200</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);<span style="color:#75715e">//总的结束时间
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>perCnt;j<span style="color:#f92672">++</span>)
        {
            <span style="color:#66d9ef">int</span> n;
            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> m<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;m<span style="color:#f92672">&lt;</span>n;m<span style="color:#f92672">++</span>)
            {
                event tempEve <span style="color:#f92672">=</span> readTime();
                person[j].push(tempEve);<span style="color:#75715e">//每个人的事件
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(tempEve.endTime <span style="color:#f92672">==</span> rend)
                    endCheck <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
                allTime.push(tempEve.startTime);<span style="color:#75715e">//每一个时间点
</span><span style="color:#75715e"></span>                allTime.push(tempEve.endTime);
            }
        }
        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>(allTime.top()<span style="color:#f92672">==</span>rbegin))<span style="color:#75715e">//重复插入,其实不用管
</span><span style="color:#75715e"></span>            allTime.push(rbegin);
        <span style="color:#66d9ef">if</span>(endCheck)
            allTime.push(rend);
        checkAllPerson();
        printf(<span style="color:#e6db74">&#34;Scenario #%d:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
        output();
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="总结-4">总结<a hidden class="anchor" aria-hidden="true" href="#总结-4">#</a></h3>
<p>这道题思路不麻烦,难的是代码的编写,这次写的非常丑,时间比较那里可以简化一下,同时可以把时间直接转换为秒,代码量更少.</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://xyfuture.github.io/tags/program/">Program</a></li>
      <li><a href="https://xyfuture.github.io/tags/homework/">homework</a></li>
    </ul>
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://xyfuture.github.io/">My New Hugo Site</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
