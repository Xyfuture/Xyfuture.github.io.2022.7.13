<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Program-week8-homework | My New Hugo Site</title>

<meta name="keywords" content="Program, homework" />
<meta name="description" content="homework A - 区间选点 II 题意 题面 题意很简单,就是给定一个区间,要求在每个区间内得取够给定个数的点(可以超过,但是不能少),问全局最少需要去多少个点
解法 本道题要求使用差分约束来解
差分约束首先要构建方程,找到用于一个表示X的量,这里使用一个数组dis,dis[i]代表从min到第i个点一共有多少个点(注意这里的min对应着题目中最小的区间端点),那么实际上我们求取的就是dis[max]的值(max代表给出的最大区间端点).
下面开始构建约束
对于给出的区间(i,j)要求k的点我们可以构建方程
$dis[j]-dis[i-1]\geq k$
除此之外为了使题目有意义我们得保证每个点只能被取0次或1次,因此需要方程约束
$0\leq dis[t]-dis[t-1]\leq 1$s
题目中使从0开的,我们给每个点都进行偏移,使整个数轴从1开始,那么我们还能知道$dis[0]=0\ or\ dis[min-1]=0$
综上我们知道了如下信息 $$ dis[min-1] =0\
dis[j]-dis[i]\geq k\
dis[t]-dis[t-1]\geq 0\
dis[t-1] - dis[t]\geq -1 $$ 我们要求的最少用多少个点,那么就是求取最大值最小,使用最长路求取,因为有负边权我们使用SPFA来求,鉴于本题一定有答案,不做负环的判断
求出最长路只需要换一下啊松弛条件就可以了
这道题复杂度同SPFA一样,O(KM)
code #include&lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;// #include &lt;algorithm&gt; #include &lt;queue&gt;#include &lt;cstring&gt; using namespace std; vector&lt;pair&lt;int,int&gt; &gt; G[50005];//图 queue&lt;int&gt; q;//队列 int dis[50005];//最大值,差分数组 int inque[50005];//是否在队列中 int main() { memset(dis,-128,sizeof(dis)); memset(inque,0,sizeof(inque)); int n; scanf(&#34;%d&#34;,&amp;n); int min = 50005,max = 0 ; for(int i=0;i&lt;n;i&#43;&#43;) { int a,b,c; scanf(&#34;%d%d%d&#34;,&amp;a,&amp;b,&amp;c); a&#43;=1,b&#43;=1;//把从0开始改为从1开始  if(a&lt;min) min = a;//起始位置  if(b&gt;max) max = b;//结束位置  G[a-1].">
<meta name="author" content="">
<link rel="canonical" href="https://xyfuture.github.io/posts/program-week8-homework/" />
<link href="/assets/css/stylesheet.min.5c4f6d85b7abfcfea458637c672d16a7a9c38c37f002753cfdc7f314b6d3c8f2.css" integrity="sha256-XE9thber/P6kWGN8Zy0Wp6nDjDfwAnU8/cfzFLbTyPI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://xyfuture.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xyfuture.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xyfuture.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xyfuture.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://xyfuture.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />


<meta property="og:title" content="Program-week8-homework" />
<meta property="og:description" content="homework A - 区间选点 II 题意 题面 题意很简单,就是给定一个区间,要求在每个区间内得取够给定个数的点(可以超过,但是不能少),问全局最少需要去多少个点
解法 本道题要求使用差分约束来解
差分约束首先要构建方程,找到用于一个表示X的量,这里使用一个数组dis,dis[i]代表从min到第i个点一共有多少个点(注意这里的min对应着题目中最小的区间端点),那么实际上我们求取的就是dis[max]的值(max代表给出的最大区间端点).
下面开始构建约束
对于给出的区间(i,j)要求k的点我们可以构建方程
$dis[j]-dis[i-1]\geq k$
除此之外为了使题目有意义我们得保证每个点只能被取0次或1次,因此需要方程约束
$0\leq dis[t]-dis[t-1]\leq 1$s
题目中使从0开的,我们给每个点都进行偏移,使整个数轴从1开始,那么我们还能知道$dis[0]=0\ or\ dis[min-1]=0$
综上我们知道了如下信息 $$ dis[min-1] =0\
dis[j]-dis[i]\geq k\
dis[t]-dis[t-1]\geq 0\
dis[t-1] - dis[t]\geq -1 $$ 我们要求的最少用多少个点,那么就是求取最大值最小,使用最长路求取,因为有负边权我们使用SPFA来求,鉴于本题一定有答案,不做负环的判断
求出最长路只需要换一下啊松弛条件就可以了
这道题复杂度同SPFA一样,O(KM)
code #include&lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;// #include &lt;algorithm&gt; #include &lt;queue&gt;#include &lt;cstring&gt; using namespace std; vector&lt;pair&lt;int,int&gt; &gt; G[50005];//图 queue&lt;int&gt; q;//队列 int dis[50005];//最大值,差分数组 int inque[50005];//是否在队列中 int main() { memset(dis,-128,sizeof(dis)); memset(inque,0,sizeof(inque)); int n; scanf(&#34;%d&#34;,&amp;n); int min = 50005,max = 0 ; for(int i=0;i&lt;n;i&#43;&#43;) { int a,b,c; scanf(&#34;%d%d%d&#34;,&amp;a,&amp;b,&amp;c); a&#43;=1,b&#43;=1;//把从0开始改为从1开始  if(a&lt;min) min = a;//起始位置  if(b&gt;max) max = b;//结束位置  G[a-1]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xyfuture.github.io/posts/program-week8-homework/" />
<meta property="article:published_time" content="2020-04-15T09:09:31+00:00" />
<meta property="article:modified_time" content="2020-04-15T09:09:31+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Program-week8-homework"/>
<meta name="twitter:description" content="homework A - 区间选点 II 题意 题面 题意很简单,就是给定一个区间,要求在每个区间内得取够给定个数的点(可以超过,但是不能少),问全局最少需要去多少个点
解法 本道题要求使用差分约束来解
差分约束首先要构建方程,找到用于一个表示X的量,这里使用一个数组dis,dis[i]代表从min到第i个点一共有多少个点(注意这里的min对应着题目中最小的区间端点),那么实际上我们求取的就是dis[max]的值(max代表给出的最大区间端点).
下面开始构建约束
对于给出的区间(i,j)要求k的点我们可以构建方程
$dis[j]-dis[i-1]\geq k$
除此之外为了使题目有意义我们得保证每个点只能被取0次或1次,因此需要方程约束
$0\leq dis[t]-dis[t-1]\leq 1$s
题目中使从0开的,我们给每个点都进行偏移,使整个数轴从1开始,那么我们还能知道$dis[0]=0\ or\ dis[min-1]=0$
综上我们知道了如下信息 $$ dis[min-1] =0\
dis[j]-dis[i]\geq k\
dis[t]-dis[t-1]\geq 0\
dis[t-1] - dis[t]\geq -1 $$ 我们要求的最少用多少个点,那么就是求取最大值最小,使用最长路求取,因为有负边权我们使用SPFA来求,鉴于本题一定有答案,不做负环的判断
求出最长路只需要换一下啊松弛条件就可以了
这道题复杂度同SPFA一样,O(KM)
code #include&lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;// #include &lt;algorithm&gt; #include &lt;queue&gt;#include &lt;cstring&gt; using namespace std; vector&lt;pair&lt;int,int&gt; &gt; G[50005];//图 queue&lt;int&gt; q;//队列 int dis[50005];//最大值,差分数组 int inque[50005];//是否在队列中 int main() { memset(dis,-128,sizeof(dis)); memset(inque,0,sizeof(inque)); int n; scanf(&#34;%d&#34;,&amp;n); int min = 50005,max = 0 ; for(int i=0;i&lt;n;i&#43;&#43;) { int a,b,c; scanf(&#34;%d%d%d&#34;,&amp;a,&amp;b,&amp;c); a&#43;=1,b&#43;=1;//把从0开始改为从1开始  if(a&lt;min) min = a;//起始位置  if(b&gt;max) max = b;//结束位置  G[a-1]."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Program-week8-homework",
  "name": "Program-week8-homework",
  "description": "homework A - 区间选点 II 题意 题面 题意很简单,就是给定一个区间,要求在每个区间内得取够给定个数的点(可以超过,但是不能少),问全局最少需要去多少个点\n解法 本道题要求使用差分约束来解\n差分约束首先要构建方程,找到用于一个表示X的量,这里使用一个数组dis,dis[i]代表从min到第i个点一共有多少个点(注意这里的min对应着题目中最小的 …",
  "keywords": [
    "Program", "homework"
  ],
  "articleBody": "homework A - 区间选点 II 题意 题面 题意很简单,就是给定一个区间,要求在每个区间内得取够给定个数的点(可以超过,但是不能少),问全局最少需要去多少个点\n解法 本道题要求使用差分约束来解\n差分约束首先要构建方程,找到用于一个表示X的量,这里使用一个数组dis,dis[i]代表从min到第i个点一共有多少个点(注意这里的min对应着题目中最小的区间端点),那么实际上我们求取的就是dis[max]的值(max代表给出的最大区间端点).\n下面开始构建约束\n对于给出的区间(i,j)要求k的点我们可以构建方程\n$dis[j]-dis[i-1]\\geq k$\n除此之外为了使题目有意义我们得保证每个点只能被取0次或1次,因此需要方程约束\n$0\\leq dis[t]-dis[t-1]\\leq 1$s\n题目中使从0开的,我们给每个点都进行偏移,使整个数轴从1开始,那么我们还能知道$dis[0]=0\\ or\\ dis[min-1]=0$\n综上我们知道了如下信息 $$ dis[min-1] =0\\\ndis[j]-dis[i]\\geq k\\\ndis[t]-dis[t-1]\\geq 0\\\ndis[t-1] - dis[t]\\geq -1 $$ 我们要求的最少用多少个点,那么就是求取最大值最小,使用最长路求取,因为有负边权我们使用SPFA来求,鉴于本题一定有答案,不做负环的判断\n求出最长路只需要换一下啊松弛条件就可以了\n这道题复杂度同SPFA一样,O(KM)\ncode #include#include #include // #include  #include #include  using namespace std; vectorpairint,int  G[50005];//图 queueint q;//队列 int dis[50005];//最大值,差分数组 int inque[50005];//是否在队列中 int main() { memset(dis,-128,sizeof(dis)); memset(inque,0,sizeof(inque)); int n; scanf(\"%d\",\u0026n); int min = 50005,max = 0 ; for(int i=0;in;i++) { int a,b,c; scanf(\"%d%d%d\",\u0026a,\u0026b,\u0026c); a+=1,b+=1;//把从0开始改为从1开始  if(amin) min = a;//起始位置  if(bmax) max = b;//结束位置  G[a-1].push_back(make_pair(b,c));//有向边  } for(int i=min-1;imax;i++) G[i].push_back(make_pair(i+1,0));//两点之差大于0  for(int i=min-1;imax;i++) G[i+1].push_back(make_pair(i,-1));//两点之差小于1  // dis[a]=0;  q.push(min-1);//从整个点开始遍历dis[min-1]  dis[min-1] = 0; while(!q.empty()) { int temp = q.front(); q.pop(); inque[temp] = 0; for(vectorpairint,int :: iterator i =G[temp].begin();i!=G[temp].end();i++) { if(dis[(*i).first]dis[temp]+(*i).second)//最长路  { dis[(*i).first] = dis[temp]+(*i).second;//更新最长  if(inque[(*i).first] == 1) continue; q.push((*i).first); inque[(*i).first] = 1; } } } printf(\"%d\\n\",dis[max]);//输出最终位置的值就是全局消耗 } 总结 这道题是一道简单的差分约束题目,差分约束的难点主要在寻找到约束变量,同时构建出约束关系,这个约束条件一般有两部分一部分是题目直接给出的,另一部分是为了使题目有意义,隐含构建的,最后还要确认一个起点,其他点都是以这个为基础.\nB - 猫猫向前冲 题意 这个就是求取一个拓扑序,但是要求拓扑序是最小字典序的,需要对队列进行操作\n解法 在拓扑排序的基础上,我们把正常用的队列改为最小堆,这样每次获得的0入度节点一定是字典序最小的点,其他的操作和正常的拓扑排序一致,首先找到入度为0的点,然后将其加入到堆,从堆取出一个节点,更新其邻接点入度,如果邻接点的入度为0了,就将邻接点加入到堆,重复循环直到堆空了.\n使用堆的拓扑排序复杂度O(NlogN+M)\ncode #include #include #include #include #include  using namespace std; vectorint G[505];//图 int edges[505];//入度 priority_queueint,vectorint,greaterint  q;//最小堆 int ans [505];//拓扑序列 int main() { int n,m; while(scanf(\"%d%d\",\u0026n,\u0026m)!=EOF) { memset(edges,0,sizeof(edges)); memset(ans,0,sizeof(ans)); for(int i=1;in;i++) G[i].clear(); for(int i=0;im;i++) { int p1,p2; scanf(\"%d%d\",\u0026p1,\u0026p2); edges[p2]++;//更新入度  G[p1].push_back(p2); } for(int i=1;in+1;i++)//找到所有入度为0的点  if(edges[i] == 0) q.push(i);//放入堆  int cnt = 0;//用于形成拓扑序  while(!q.empty()) { int temp = q.top(); q.pop(); ans[cnt++] = temp; for(auto i:G[temp])//更新邻接点  if(--edges[i] == 0)//邻接点的入度为0  q.push(i); } printf(\"%d\",ans[0]);//格式要求  for(int i=1;in;i++) printf(\" %d\",ans[i]); printf(\"\\n\"); } return 0; } 总结 拓扑序本质上还是一个贪心,比较好写,可能在取点时会有各种限制,注意一下\nC - 班长竞选 ###　题意\n题面 这个也是给定一个集合,然后求取传递闭包,问有多少个点能到达给定点,然后输出最多的点\n解法 之前求闭包用的是floyd,但是这个算法在这里不太行,因为数据是5e3,n^3^的话就超时了,因此需要优化,这里采用的办法是求取强连通分量然后进行缩点.\n求取强强联通分量的算法是Kosaraju,跑两遍dfs,时间复杂度是O(n+m),常数会大一些.\n具体操作是这样的,首先对全图跑一边dfs,同时记录dfs后续序列.然后根据将后续序列倒过来,按照逆后续序列再跑一遍dfs,这次在反图中进行,这次一个dfs中经过的点都做一样的标记,这样标记相同的点就在一个强连通分量中.\n得到了强连通分量,我们就可以进行缩点了,每个强连通分量都变成了一个点,遍历强连通分量中的点,能连接到其他的连通分量就在缩点后的图中加一条边(可能会有重复的边,但是不影响).\n我们可以得知每一强连通分量都是互通的,因此有n-1个点支持连通分量内的点(连通分量有n个点),除此之外缩点后的图中还会有其他的连通分量连接过来,因此还要算上他们\n这个我们使用dfs来求,缩点时我们添加边改为反向的,这样一个点能到的点都是支持他的.在缩点后的图中跑一边dfs就知道有多少个连通分量支持了,最终把所有支持的都加起来,取最大的那个就行了\ncode #include #include #include #include #include #include using namespace std; vectorint G[5005];//原始的图 vectorint Gr[5005];//反向的原始图 vectorint Gs[5005];//缩点后的图 int vote[5005];//最终一个点的票数 int group[5005];//强连通分量标记 int dfs[5005];//后dfs序 int vis[5005];//dfs访问记录 int dfsCnt;//用于记录后dfs序 int temp[5005];//记录每个强连通分量的节点个数 void firstDFS(int s)//第一遍后dfs序 { for(vectorint::iterator i=G[s].begin();i!=G[s].end();i++) if(vis[*i]==0) { vis[*i] = 1; firstDFS(*i); } dfs[dfsCnt++] = s;//后续 } void groupDFS(int s,int t)//分组 { group[s] = t;//都是一个标记  for(vectorint::iterator i=Gr[s].begin();i!=Gr[s].end();i++)//跑反图  if(group[*i]==0)//自带标记  groupDFS(*i,t); } int getNum(int vis[],int s)//缩点后的图中,一个连通分量与多少连通分量连接,返回所有连接分量的点的个数 { int tempAns=0; for(vectorint::iterator i=Gs[s].begin();i!=Gs[s].end();i++) if(vis[*i]==0) { vis[*i] = 1; tempAns+=getNum(vis,*i);//dfs  } return tempAns+temp[s];//加上自己的 } int main() { int t,n,m; scanf(\"%d\",\u0026t); for(int k=0;kt;k++) { dfsCnt = 0; scanf(\"%d%d\",\u0026n,\u0026m); for(int i=0;in+4;i++) vote[i]=0,group[i]=0,vis[i]=0,dfs[i]=0; for(int i=0;in;i++) { G[i].clear(); Gr[i].clear(); Gs[i].clear(); } //上述为清空  int a,b; for(int i=0;im;i++) { scanf(\"%d%d\",\u0026a,\u0026b); G[a].push_back(b); Gr[b].push_back(a);//反图  } for(int i=0;in;i++) if(vis[i] == 0)//第一次后dfs  { vis[i] = 1; firstDFS(i); } reverse(dfs,dfs+n);//反转  int color = 1;//染色  for(int i=0;in;i++) if(group[dfs[i]]==0) groupDFS(dfs[i],color++); memset(temp,0,sizeof(temp)); for(int i=0;in;i++) temp[group[i]]++;//记录每个强连通分量内点的个数  for(int i=0;in;i++)//缩点  for(vectorint::iterator t=G[i].begin();t!=G[i].end();t++) if(group[i]!=group[*t]) Gs[group[*t]].push_back(group[i]);//可能会重复,无所谓  int vis2[color+5];//访问标记  memset(vis2,0,sizeof(vis2)); for(int i=1;icolor;i++) if(vis2[i]==0) { memset(vis2,0,sizeof(vis2));//清空  vis2[i] = 1; // getNum(vis2,i);  vote[i] = getNum(vis2,i)-1;//最后减一因为自己不能给自己投  } int maxNum=0; for(int i=1;icolor;i++) if(vote[i]maxNum) maxNum = vote[i]; printf(\"Case %d: %d\\n\",k+1,maxNum); int i=0; for(;in;i++)//格式要求,少一个空格  if(vote[group[i]]==maxNum) { printf(\"%d\",i); break; } for(i++;in;i++) if(vote[group[i]]==maxNum) printf(\" %d\",i); printf(\"\\n\"); } } 总结 这道题还是有点难度的,开始调了好久,没有意识到自己的后dfs序求错了,改了后dfs序就正确了,有趣的是即便后dfs序是错误的,但是还是过了样例,看起来样例参考意义太小了\nCSP  这次CSP大翻车,直接爆零,情况十分惨烈\n第一题 这个确实错了,想的时候没有把情况想全,忽略了只有两个数的情况\n第二题 这个非常可惜,最后三分钟检查出了错误,没改完,明明是能拿满分的\n第三题 考场上基本想出做法了,两次二分,但是时间不太够,因此先写了个暴力前6个点,结果交错了,我居然把第2题的代码交到了第三题 哎\n HRZ的序列 题意 解法 我的 找出输入中最大的和最小的元素,然后遍历输入,如果这个这数等于最大或者最小直接继续,不等于看看(最大-最小)%2是不是0,是0判断看看输入是不是(最小+最大)/2,不是0则直接输出NO.\n另一个 用一个set来记录,两个元素的时候直接输出YES,三个元素时,判断三者关系,四个及以上输出NO\ncode #include #include #include #include #include  using namespace std; long long data [10005]; int main() { int t; memset(data,0,sizeof(data)); scanf(\"%d\",\u0026t); for(int i=0;it;i++) { int n; scanf(\"%d\",\u0026n); for(int j=0;jn;j++) scanf(\"%lld\",data+j); int flag = 0; long long Max = data[0],Min=data[0]; for(int t=0;tn;t++)//找到max min  { if(data[t]Max) Max = data[t]; if(data[t]Min) Min =data[t]; } for(int t=0;tn;t++) { if(!(data[t]==Max||data[t]==Min))//是不是max,min  { if((Max-Min)%2 == 1)//能不能/2,因为要求是整数,不会有小数  { flag =1; break; } if(data[t]!=Min+(Max-Min)/2)//不是平均的  { flag = 1; break; } } } if(flag == 1) printf(\"NO\\n\"); else printf(\"YES\\n\"); } return 0; } 总结 这类题感觉自己不是很会做,有点类似脑筋急转弯的感觉,难度不大,就是想不到,得多加联系\nHRZ学英语 题意 给定一个序列,让找到满足要求的区间,并且输出最小字典序\n解法 这里采取了类似尺取的做法,用一个数组vis记录26个字母对应在给定序列中的下标,一个r指针,一个l指针,每次先移动r指针到指定位置(正好确保l,r之间放满26个字母),每次移动记录r对应字母的下标,如果已经有了下标则代表重复,让l跳转到当前下标的下一个位置,同时l移动的同时把vis置0.然后为r重新设定目标位置,重新开始移动,直到移动到目标位置.\n输出要求最小字典序,因此首先l所在位置的字母指示的下标开始在输入序列中遍历,遇到?,去vis中找第一个为0的字母,输出它,同时标记vis.\ncode #include #include #include #include #include #include  using namespace std; char data[1000005];//存储输入 int vis[100];//26个字母对应下标  int main() { memset(data,0,sizeof(data)); memset(vis,0,sizeof(vis)); int i=1; while(scanf(\"%c\",data+i)!=EOF) if(data[i]!='\\n') i++; else break; if(i 26)//至少26个字母,i==27  { printf(\"-1\\n\"); return 0; } int l=1,r= 1;//左右指针  int lt=0,rt=26;//左右指针应该到达的位置  while(r-l  26)//r-l==26就满足条件了  { while(llt)//l最终到达lt+1,但是lt+1没有被清零  { if(data[l] == '?')//重置vis  vis[data[l]] = 0; l++; } while(rrt)//到达rt后l,r的距离就是26了  { if(data[r] != '?') if(vis[data[r]] == 0)//没有标记  vis[data[r]] = r; else { lt = vis[data[r]];//标记后就要移动l  rt = lt+26;//新的位置  break; } r++; } if(rt=i)//到达了末端  { flag = 1; break; } } if(flag == 1) printf(\"-1\\n\"); else//字典序最小  { for(int j=l;jr-1;j++) { if(data[j] != '?') printf(\"%c\",data[j]); else { for(char f='A';f'Z';f++)//找到vis第一个为0的输出  if(vis[f] == 0) { printf(\"%c\",f); vis[f] = 1;//标记  break; } } } } return 0; } 总结 这道题在赛场上没做出来太可惜了,思路是对了,但是最后没有判断好l和r的关系,没写好退出的条件,产生了错误,最终没有过\n咕咕东的奇妙序列 题意 这道题就是给定了一个规则,我们用这个规则生成了一个序列(当然不可能实际生成出来),求取序列中指定位置的点的值\n解法 使用两次二分来解\n第一次二分是找到要查找的元素在哪一个组(第i组是指123 … i-1 i 这个范围),找到那一组之后还要在二分查找在这一组的哪一个位置\n首先我们要知道第i组在序列中是什么位置(第i组结束的位置),我们可以观察规律,很容易发现如果是是第i组,1有i个,2有i-1个….10有i-9个,最终i有1个.然后每个数我们都是知道他们的位数的,现在又知道了个数,就很容易求出第i组的位置了.\n但是这样一个数一个数的求,效率比较低,我们可以直接把所有t位的数总个数一次求出了,比如2位的数(10-99)一共90个,然后10的个数到99的个数是一个等差数列,用就和公式直接求就行了,最后*2就是2位数占的位置,其他的类似.我们给出一个t位数,我们可以直接求出1-t-1位数总的数字数,然后用同样的方法求t位数的数字数.\n这样我们就能完全知道第i组数在序列中的位置了,然后使用二分求出第一个大于等于给定位置的组,再在组中进行操作.\n在组中也是要找到第k个数的位置,,这个简单多了,假设k用m位,从1-m-1位的数可以直接求出来,因为每个数的位数是知道的,每个数只出现一次,t位数有几个都知道(比如1位的9个,2位的一共90个,3位的900个).剩下解决m位有几个,k-(1em)+1就是个数了,乘上m算出数字个数了,全部加起来就是位置了\n同样我们也使用二分找到第一个大于等于给定位置的数,最终输出想要的哪一位就行了\n复杂度分析$O((log_{10}ST)^2logST)$大致应该是这个复杂度,ST是一个常数,因为每次固定从他开始找,因此是稳定的,第ST组数的结束位置已经大于了数据范围\ncode #include #include #include #include #include #include #define ST 800000000  using namespace std; int bits(long long num)//计算一个数有几位 { int ans = 0; for(;num0;num=num/10,ans++); return ans; } long long power(int i)//10的i次方 { long long ans = 1; for(int t=0;ti;t++) ans*=10; return ans; } long long curNum(long long n,long long s,long long e)//计算等差数列和,顺便乘上n { return n*(e+s)*(s-e+1)/2; } long long allNum(long long temp)//计算temp所在的位置 { int n = bits(temp);//有几位  long long ans = 0;//记录位置  for(int i=1;in;i++)//1~n-1位有多少个数字  { ans+=curNum(1ll*i,temp-power(i-1)+1,temp+1-power(i-1)-9*power(i-1)+1);//temp-xxx,表示的等差数列开始位置和结束的位置,这个是符合规律的  } ans+=curNum(n,temp-power(n-1)+1,1);//第n位有几个,也是用规律求的等差数列  return ans; } long long perNum(long long temp)//temp在组内的位置 { int n = bits(temp); long long ans = 0; for(int i=1;in;i++)//1~n-1  ans+= i*power(i-1)*9; ans+= n*(temp-power(n-1)+1); return ans; } int main() { int n; scanf(\"%d\",\u0026n); for(int t=0;tn;t++) { long long k; scanf(\"%lld\",\u0026k); long long l=0,r=ST;//ST是找的一个数,因为allNum(ST)已经超过了数据范围,ST可以降低复杂度  long long mid = (l+r)/2; long long tar = 0;//目标  while(lr) { if(allNum(mid)=k)//找第一个大于k的组  { r= mid-1;//右移  tar = mid; } else l=mid+1; mid = (l+r)/2; } l=0,r=tar;//下一次二分  k-=allNum(tar-1);//第tar组满足,减去allNum(tar-1)就是tar组内的位置了  mid = (l+r)/2; while(lr) { if(perNum(mid)=k)//找到tar组内,第一个大于k的数  { r=mid-1; tar = mid; } else l=mid+1; mid = (l+r)/2; } k-=perNum(tar-1);//减去之后就是在tar这个数内第几个数字了  stringstream s;//方便输出  star; string str; sstr; printf(\"%c\\n\",str[k-1]);//直接输出  } } 总结 这道题一开始写的暴力,结果交的时候硬是交成了第2题的代码,这是不可忍受的的,以后交的时候一定要检查!!!\n对于这道题来说找到了规律不算太难,当时看到这么大数据范围i基本上就能想到是二分这类log的算法了,但是码力不太够,不能在30min之内完全打出来,还是有待提升\n",
  "wordCount" : "846",
  "inLanguage": "en",
  "datePublished": "2020-04-15T09:09:31Z",
  "dateModified": "2020-04-15T09:09:31Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xyfuture.github.io/posts/program-week8-homework/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xyfuture.github.io/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xyfuture.github.io/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()"></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Program-week8-homework
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">April 15, 2020

    </div>
  </header> 

  <div class="post-content">
<h1 id="homework">homework<a hidden class="anchor" aria-hidden="true" href="#homework">#</a></h1>
<h2 id="a---区间选点-ii">A - 区间选点 II<a hidden class="anchor" aria-hidden="true" href="#a---区间选点-ii">#</a></h2>
<h3 id="题意">题意<a hidden class="anchor" aria-hidden="true" href="#题意">#</a></h3>
<h4 id="题面">题面<a hidden class="anchor" aria-hidden="true" href="#题面">#</a></h4>
<p><img src="https://i.loli.net/2020/04/15/ZlMCLTWAFiN5dKj.png" alt=""></p>
<p>题意很简单,就是给定一个区间,要求在每个区间内得取够给定个数的点(可以超过,但是不能少),问全局最少需要去多少个点</p>
<h3 id="解法">解法<a hidden class="anchor" aria-hidden="true" href="#解法">#</a></h3>
<p>本道题要求使用差分约束来解</p>
<p>差分约束首先要构建方程,找到用于一个表示X的量,这里使用一个数组dis,dis[i]代表从min到第i个点一共有多少个点(注意这里的min对应着题目中最小的区间端点),那么实际上我们求取的就是dis[max]的值(max代表给出的最大区间端点).</p>
<p>下面开始构建约束</p>
<p>对于给出的区间(i,j)要求k的点我们可以构建方程</p>
<p>$dis[j]-dis[i-1]\geq k$</p>
<p>除此之外为了使题目有意义我们得保证每个点只能被取0次或1次,因此需要方程约束</p>
<p>$0\leq dis[t]-dis[t-1]\leq 1$s</p>
<p>题目中使从0开的,我们给每个点都进行偏移,使整个数轴从1开始,那么我们还能知道$dis[0]=0\ or\ dis[min-1]=0$</p>
<p>综上我们知道了如下信息
$$
dis[min-1] =0\<br>
dis[j]-dis[i]\geq k\<br>
dis[t]-dis[t-1]\geq 0\<br>
dis[t-1] - dis[t]\geq -1
$$
我们要求的最少用多少个点,那么就是求取最大值最小,使用最长路求取,因为有负边权我们使用SPFA来求,鉴于本题一定有答案,不做负环的判断</p>
<p>求出最长路只需要换一下啊松弛条件就可以了</p>
<p>这道题复杂度同SPFA一样,O(KM)</p>
<h3 id="code">code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">// #include &lt;algorithm&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>

<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> G[<span style="color:#ae81ff">50005</span>];<span style="color:#75715e">//图
</span><span style="color:#75715e"></span>queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;<span style="color:#75715e">//队列
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dis[<span style="color:#ae81ff">50005</span>];<span style="color:#75715e">//最大值,差分数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> inque[<span style="color:#ae81ff">50005</span>];<span style="color:#75715e">//是否在队列中
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    memset(dis,<span style="color:#f92672">-</span><span style="color:#ae81ff">128</span>,<span style="color:#66d9ef">sizeof</span>(dis));
    memset(inque,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(inque));
    <span style="color:#66d9ef">int</span> n;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> <span style="color:#ae81ff">50005</span>,max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> ;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">int</span> a,b,c;
        scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>a,<span style="color:#f92672">&amp;</span>b,<span style="color:#f92672">&amp;</span>c);
        a<span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>,b<span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//把从0开始改为从1开始
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(a<span style="color:#f92672">&lt;</span>min)
            min <span style="color:#f92672">=</span> a;<span style="color:#75715e">//起始位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(b<span style="color:#f92672">&gt;</span>max)
            max <span style="color:#f92672">=</span> b;<span style="color:#75715e">//结束位置
</span><span style="color:#75715e"></span>        G[a<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>].push_back(make_pair(b,c));<span style="color:#75715e">//有向边
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>min<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>max;i<span style="color:#f92672">++</span>)
        G[i].push_back(make_pair(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>));<span style="color:#75715e">//两点之差大于0
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>min<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>max;i<span style="color:#f92672">++</span>)
        G[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>].push_back(make_pair(i,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>));<span style="color:#75715e">//两点之差小于1
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// dis[a]=0;
</span><span style="color:#75715e"></span>    q.push(min<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);<span style="color:#75715e">//从整个点开始遍历dis[min-1]
</span><span style="color:#75715e"></span>    dis[min<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty())
    {
        
        <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> q.front();
        q.pop();
        inque[temp] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span>(vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;::</span> iterator i <span style="color:#f92672">=</span>G[temp].begin();i<span style="color:#f92672">!=</span>G[temp].end();i<span style="color:#f92672">++</span>)
        {

            <span style="color:#66d9ef">if</span>(dis[(<span style="color:#f92672">*</span>i).first]<span style="color:#f92672">&lt;</span>dis[temp]<span style="color:#f92672">+</span>(<span style="color:#f92672">*</span>i).second)<span style="color:#75715e">//最长路
</span><span style="color:#75715e"></span>            {
                dis[(<span style="color:#f92672">*</span>i).first] <span style="color:#f92672">=</span> dis[temp]<span style="color:#f92672">+</span>(<span style="color:#f92672">*</span>i).second;<span style="color:#75715e">//更新最长
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(inque[(<span style="color:#f92672">*</span>i).first] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
                    <span style="color:#66d9ef">continue</span>;
                q.push((<span style="color:#f92672">*</span>i).first);
                inque[(<span style="color:#f92672">*</span>i).first] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            }
        }
    }
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,dis[max]);<span style="color:#75715e">//输出最终位置的值就是全局消耗
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>这道题是一道简单的差分约束题目,差分约束的难点主要在寻找到约束变量,同时构建出约束关系,这个约束条件一般有两部分一部分是题目直接给出的,另一部分是为了使题目有意义,隐含构建的,最后还要确认一个起点,其他点都是以这个为基础.</p>
<h2 id="b---猫猫向前冲">B - 猫猫向前冲<a hidden class="anchor" aria-hidden="true" href="#b---猫猫向前冲">#</a></h2>
<h3 id="题意-1">题意<a hidden class="anchor" aria-hidden="true" href="#题意-1">#</a></h3>
<p><img src="https://i.loli.net/2020/04/15/X58rIWbk7wFvsSZ.png" alt=""></p>
<p>这个就是求取一个拓扑序,但是要求拓扑序是最小字典序的,需要对队列进行操作</p>
<h3 id="解法-1">解法<a hidden class="anchor" aria-hidden="true" href="#解法-1">#</a></h3>
<p>在拓扑排序的基础上,我们把正常用的队列改为最小堆,这样每次获得的0入度节点一定是字典序最小的点,其他的操作和正常的拓扑排序一致,首先找到入度为0的点,然后将其加入到堆,从堆取出一个节点,更新其邻接点入度,如果邻接点的入度为0了,就将邻接点加入到堆,重复循环直到堆空了.</p>
<p>使用堆的拓扑排序复杂度O(NlogN+M)</p>
<h3 id="code-1">code<a hidden class="anchor" aria-hidden="true" href="#code-1">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> G[<span style="color:#ae81ff">505</span>];<span style="color:#75715e">//图
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> edges[<span style="color:#ae81ff">505</span>];<span style="color:#75715e">//入度
</span><span style="color:#75715e"></span>priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> q;<span style="color:#75715e">//最小堆
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> ans [<span style="color:#ae81ff">505</span>];<span style="color:#75715e">//拓扑序列
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> n,m;
    <span style="color:#66d9ef">while</span>(scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>n,<span style="color:#f92672">&amp;</span>m)<span style="color:#f92672">!=</span>EOF)
    {
        memset(edges,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(edges));
        memset(ans,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(ans));
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;=</span>n;i<span style="color:#f92672">++</span>)
            G[i].clear();
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>m;i<span style="color:#f92672">++</span>)
        {
            <span style="color:#66d9ef">int</span> p1,p2;
            scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>p1,<span style="color:#f92672">&amp;</span>p2);
            edges[p2]<span style="color:#f92672">++</span>;<span style="color:#75715e">//更新入度
</span><span style="color:#75715e"></span>            G[p1].push_back(p2);
        }
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//找到所有入度为0的点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(edges[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
                q.push(i);<span style="color:#75715e">//放入堆
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//用于形成拓扑序
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty())
        {
            <span style="color:#66d9ef">int</span> temp <span style="color:#f92672">=</span> q.top();
            q.pop();
            ans[cnt<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> temp;
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i:G[temp])<span style="color:#75715e">//更新邻接点
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">--</span>edges[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//邻接点的入度为0
</span><span style="color:#75715e"></span>                    q.push(i);
        }
        printf(<span style="color:#e6db74">&#34;%d&#34;</span>,ans[<span style="color:#ae81ff">0</span>]);<span style="color:#75715e">//格式要求
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
            printf(<span style="color:#e6db74">&#34; %d&#34;</span>,ans[i]);
        printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h3>
<p>拓扑序本质上还是一个贪心,比较好写,可能在取点时会有各种限制,注意一下</p>
<h2 id="c---班长竞选">C - 班长竞选<a hidden class="anchor" aria-hidden="true" href="#c---班长竞选">#</a></h2>
<p>###　题意</p>
<h4 id="题面-1">题面<a hidden class="anchor" aria-hidden="true" href="#题面-1">#</a></h4>
<p><img src="https://i.loli.net/2020/04/15/WEe5rOpKcRaqP24.png" alt=""></p>
<p>这个也是给定一个集合,然后求取传递闭包,问有多少个点能到达给定点,然后输出最多的点</p>
<h3 id="解法-2">解法<a hidden class="anchor" aria-hidden="true" href="#解法-2">#</a></h3>
<p>之前求闭包用的是floyd,但是这个算法在这里不太行,因为数据是5e3,n^3^的话就超时了,因此需要优化,这里采用的办法是求取强连通分量然后进行缩点.</p>
<p>求取强强联通分量的算法是Kosaraju,跑两遍dfs,时间复杂度是O(n+m),常数会大一些.</p>
<p>具体操作是这样的,首先对全图跑一边dfs,同时记录dfs后续序列.然后根据将后续序列倒过来,按照逆后续序列再跑一遍dfs,这次在反图中进行,这次一个dfs中经过的点都做一样的标记,这样标记相同的点就在一个强连通分量中.</p>
<p>得到了强连通分量,我们就可以进行缩点了,每个强连通分量都变成了一个点,遍历强连通分量中的点,能连接到其他的连通分量就在缩点后的图中加一条边(可能会有重复的边,但是不影响).</p>
<p>我们可以得知每一强连通分量都是互通的,因此有n-1个点支持连通分量内的点(连通分量有n个点),除此之外缩点后的图中还会有其他的连通分量连接过来,因此还要算上他们</p>
<p>这个我们使用dfs来求,缩点时我们添加边改为反向的,这样一个点能到的点都是支持他的.在缩点后的图中跑一边dfs就知道有多少个连通分量支持了,最终把所有支持的都加起来,取最大的那个就行了</p>
<h3 id="code-2">code<a hidden class="anchor" aria-hidden="true" href="#code-2">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> G[<span style="color:#ae81ff">5005</span>];<span style="color:#75715e">//原始的图
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> Gr[<span style="color:#ae81ff">5005</span>];<span style="color:#75715e">//反向的原始图
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> Gs[<span style="color:#ae81ff">5005</span>];<span style="color:#75715e">//缩点后的图
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> vote[<span style="color:#ae81ff">5005</span>];<span style="color:#75715e">//最终一个点的票数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> group[<span style="color:#ae81ff">5005</span>];<span style="color:#75715e">//强连通分量标记
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dfs[<span style="color:#ae81ff">5005</span>];<span style="color:#75715e">//后dfs序
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> vis[<span style="color:#ae81ff">5005</span>];<span style="color:#75715e">//dfs访问记录
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dfsCnt;<span style="color:#75715e">//用于记录后dfs序
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> temp[<span style="color:#ae81ff">5005</span>];<span style="color:#75715e">//记录每个强连通分量的节点个数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">firstDFS</span>(<span style="color:#66d9ef">int</span> s)<span style="color:#75715e">//第一遍后dfs序
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">for</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator i<span style="color:#f92672">=</span>G[s].begin();i<span style="color:#f92672">!=</span>G[s].end();i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span>(vis[<span style="color:#f92672">*</span>i]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
        {
            vis[<span style="color:#f92672">*</span>i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            firstDFS(<span style="color:#f92672">*</span>i);
        }
    dfs[dfsCnt<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> s;<span style="color:#75715e">//后续
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">groupDFS</span>(<span style="color:#66d9ef">int</span> s,<span style="color:#66d9ef">int</span> t)<span style="color:#75715e">//分组
</span><span style="color:#75715e"></span>{
    group[s] <span style="color:#f92672">=</span> t;<span style="color:#75715e">//都是一个标记
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator i<span style="color:#f92672">=</span>Gr[s].begin();i<span style="color:#f92672">!=</span>Gr[s].end();i<span style="color:#f92672">++</span>)<span style="color:#75715e">//跑反图
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(group[<span style="color:#f92672">*</span>i]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)<span style="color:#75715e">//自带标记
</span><span style="color:#75715e"></span>            groupDFS(<span style="color:#f92672">*</span>i,t);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getNum</span>(<span style="color:#66d9ef">int</span> vis[],<span style="color:#66d9ef">int</span> s)<span style="color:#75715e">//缩点后的图中,一个连通分量与多少连通分量连接,返回所有连接分量的点的个数
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> tempAns<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator i<span style="color:#f92672">=</span>Gs[s].begin();i<span style="color:#f92672">!=</span>Gs[s].end();i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span>(vis[<span style="color:#f92672">*</span>i]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>) 
        {
            vis[<span style="color:#f92672">*</span>i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            tempAns<span style="color:#f92672">+=</span>getNum(vis,<span style="color:#f92672">*</span>i);<span style="color:#75715e">//dfs
</span><span style="color:#75715e"></span>        }
    <span style="color:#66d9ef">return</span> tempAns<span style="color:#f92672">+</span>temp[s];<span style="color:#75715e">//加上自己的
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> t,n,m;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>t);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;k<span style="color:#f92672">&lt;</span>t;k<span style="color:#f92672">++</span>)
    {
        dfsCnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>n,<span style="color:#f92672">&amp;</span>m);
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>;i<span style="color:#f92672">++</span>)
            vote[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,group[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,vis[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,dfs[i]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
        {
            G[i].clear();
            Gr[i].clear();
            Gs[i].clear();
        }
        <span style="color:#75715e">//上述为清空
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> a,b;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>m;i<span style="color:#f92672">++</span>)
        {
            scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>a,<span style="color:#f92672">&amp;</span>b);
            G[a].push_back(b);
            Gr[b].push_back(a);<span style="color:#75715e">//反图
</span><span style="color:#75715e"></span>        }
    
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(vis[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//第一次后dfs
</span><span style="color:#75715e"></span>            {
                vis[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                firstDFS(i);
            }
        reverse(dfs,dfs<span style="color:#f92672">+</span>n);<span style="color:#75715e">//反转
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> color <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//染色
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(group[dfs[i]]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
                groupDFS(dfs[i],color<span style="color:#f92672">++</span>);
        memset(temp,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(temp));
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
            temp[group[i]]<span style="color:#f92672">++</span>;<span style="color:#75715e">//记录每个强连通分量内点的个数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//缩点
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator t<span style="color:#f92672">=</span>G[i].begin();t<span style="color:#f92672">!=</span>G[i].end();t<span style="color:#f92672">++</span>)
                <span style="color:#66d9ef">if</span>(group[i]<span style="color:#f92672">!=</span>group[<span style="color:#f92672">*</span>t])
                    Gs[group[<span style="color:#f92672">*</span>t]].push_back(group[i]);<span style="color:#75715e">//可能会重复,无所谓
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> vis2[color<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>];<span style="color:#75715e">//访问标记
</span><span style="color:#75715e"></span>        memset(vis2,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(vis2));
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>color;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(vis2[i]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
            {
                memset(vis2,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(vis2));<span style="color:#75715e">//清空
</span><span style="color:#75715e"></span>                vis2[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                <span style="color:#75715e">// getNum(vis2,i);
</span><span style="color:#75715e"></span>                vote[i] <span style="color:#f92672">=</span> getNum(vis2,i)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//最后减一因为自己不能给自己投
</span><span style="color:#75715e"></span>            }
        <span style="color:#66d9ef">int</span> maxNum<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>color;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(vote[i]<span style="color:#f92672">&gt;</span>maxNum)
                maxNum <span style="color:#f92672">=</span> vote[i];
        printf(<span style="color:#e6db74">&#34;Case %d: %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,maxNum);
        <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span>(;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//格式要求,少一个空格
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(vote[group[i]]<span style="color:#f92672">==</span>maxNum)
            {
                printf(<span style="color:#e6db74">&#34;%d&#34;</span>,i);
                <span style="color:#66d9ef">break</span>;
            }
        <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">++</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(vote[group[i]]<span style="color:#f92672">==</span>maxNum)
                printf(<span style="color:#e6db74">&#34; %d&#34;</span>,i);
        printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }   
}
</code></pre></div><h3 id="总结-2">总结<a hidden class="anchor" aria-hidden="true" href="#总结-2">#</a></h3>
<p>这道题还是有点难度的,开始调了好久,没有意识到自己的后dfs序求错了,改了后dfs序就正确了,有趣的是即便后dfs序是错误的,但是还是过了样例,看起来样例参考意义太小了</p>
<h1 id="csp">CSP<a hidden class="anchor" aria-hidden="true" href="#csp">#</a></h1>
<blockquote>
<p>这次CSP大翻车,直接爆零,情况十分惨烈</p>
<p>第一题 这个确实错了,想的时候没有把情况想全,忽略了只有两个数的情况</p>
<p>第二题 这个非常可惜,最后三分钟检查出了错误,没改完,明明是能拿满分的</p>
<p>第三题 考场上基本想出做法了,两次二分,但是时间不太够,因此先写了个暴力前6个点,结果<strong>交错了</strong>,我居然把第2题的代码交到了第三题 哎</p>
</blockquote>
<h2 id="hrz的序列">HRZ的序列<a hidden class="anchor" aria-hidden="true" href="#hrz的序列">#</a></h2>
<h3 id="题意-2">题意<a hidden class="anchor" aria-hidden="true" href="#题意-2">#</a></h3>
<p><img src="https://i.loli.net/2020/04/17/XQcdpziCewRNKlE.png" alt=""></p>
<h3 id="解法-3">解法<a hidden class="anchor" aria-hidden="true" href="#解法-3">#</a></h3>
<h4 id="我的">我的<a hidden class="anchor" aria-hidden="true" href="#我的">#</a></h4>
<p>找出输入中最大的和最小的元素,然后遍历输入,如果这个这数等于最大或者最小直接继续,不等于看看(最大-最小)%2是不是0,是0判断看看输入是不是(最小+最大)/2,不是0则直接输出NO.</p>
<h4 id="另一个">另一个<a hidden class="anchor" aria-hidden="true" href="#另一个">#</a></h4>
<p>用一个set来记录,两个元素的时候直接输出YES,三个元素时,判断三者关系,四个及以上输出NO</p>
<h3 id="code-3">code<a hidden class="anchor" aria-hidden="true" href="#code-3">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> data [<span style="color:#ae81ff">10005</span>];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> t;
    memset(data,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(data));
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>t);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>t;i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">int</span> n;
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>n;j<span style="color:#f92672">++</span>)
            scanf(<span style="color:#e6db74">&#34;%lld&#34;</span>,data<span style="color:#f92672">+</span>j);
        <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> Max <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">0</span>],Min<span style="color:#f92672">=</span>data[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;t<span style="color:#f92672">&lt;</span>n;t<span style="color:#f92672">++</span>)<span style="color:#75715e">//找到max min
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">if</span>(data[t]<span style="color:#f92672">&gt;</span>Max)
                Max <span style="color:#f92672">=</span> data[t];
            <span style="color:#66d9ef">if</span>(data[t]<span style="color:#f92672">&lt;</span>Min)
                Min <span style="color:#f92672">=</span>data[t];
        }

        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;t<span style="color:#f92672">&lt;</span>n;t<span style="color:#f92672">++</span>)
        {
            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>(data[t]<span style="color:#f92672">==</span>Max<span style="color:#f92672">||</span>data[t]<span style="color:#f92672">==</span>Min))<span style="color:#75715e">//是不是max,min
</span><span style="color:#75715e"></span>            {
                <span style="color:#66d9ef">if</span>((Max<span style="color:#f92672">-</span>Min)<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)<span style="color:#75715e">//能不能/2,因为要求是整数,不会有小数
</span><span style="color:#75715e"></span>                {
                    flag <span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
                    <span style="color:#66d9ef">break</span>;
                }
                <span style="color:#66d9ef">if</span>(data[t]<span style="color:#f92672">!=</span>Min<span style="color:#f92672">+</span>(Max<span style="color:#f92672">-</span>Min)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)<span style="color:#75715e">//不是平均的
</span><span style="color:#75715e"></span>                {
                    flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                    <span style="color:#66d9ef">break</span>;
                }
            }
        } 
        <span style="color:#66d9ef">if</span>(flag <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)
            printf(<span style="color:#e6db74">&#34;NO</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">else</span> 
            printf(<span style="color:#e6db74">&#34;YES</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="总结-3">总结<a hidden class="anchor" aria-hidden="true" href="#总结-3">#</a></h3>
<p>这类题感觉自己不是很会做,有点类似脑筋急转弯的感觉,难度不大,就是想不到,得多加联系</p>
<h2 id="hrz学英语">HRZ学英语<a hidden class="anchor" aria-hidden="true" href="#hrz学英语">#</a></h2>
<h3 id="题意-3">题意<a hidden class="anchor" aria-hidden="true" href="#题意-3">#</a></h3>
<p><img src="https://i.loli.net/2020/04/17/WTn6rmvF1ZQDsiI.png" alt=""></p>
<p>给定一个序列,让找到满足要求的区间,并且输出最小字典序</p>
<h3 id="解法-4">解法<a hidden class="anchor" aria-hidden="true" href="#解法-4">#</a></h3>
<p>这里采取了类似尺取的做法,用一个数组vis记录26个字母对应在给定序列中的下标,一个r指针,一个l指针,每次先移动r指针到指定位置(正好确保l,r之间放满26个字母),每次移动记录r对应字母的下标,如果已经有了下标则代表重复,让l跳转到当前下标的下一个位置,同时l移动的同时把vis置0.然后为r重新设定目标位置,重新开始移动,直到移动到目标位置.</p>
<p>输出要求最小字典序,因此首先l所在位置的字母指示的下标开始在输入序列中遍历,遇到?,去vis中找第一个为0的字母,输出它,同时标记vis.</p>
<h3 id="code-4">code<a hidden class="anchor" aria-hidden="true" href="#code-4">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">char</span> data[<span style="color:#ae81ff">1000005</span>];<span style="color:#75715e">//存储输入
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> vis[<span style="color:#ae81ff">100</span>];<span style="color:#75715e">//26个字母对应下标
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    memset(data,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(data));
    memset(vis,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(vis));
    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span>(scanf(<span style="color:#e6db74">&#34;%c&#34;</span>,data<span style="color:#f92672">+</span>i)<span style="color:#f92672">!=</span>EOF)
        <span style="color:#66d9ef">if</span>(data[i]<span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;\n&#39;</span>)
            i<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">else</span>
            <span style="color:#66d9ef">break</span>;
        
    <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">26</span>)<span style="color:#75715e">//至少26个字母,i==27
</span><span style="color:#75715e"></span>    {
        printf(<span style="color:#e6db74">&#34;-1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
    <span style="color:#66d9ef">int</span> l<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,r<span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//左右指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> lt<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,rt<span style="color:#f92672">=</span><span style="color:#ae81ff">26</span>;<span style="color:#75715e">//左右指针应该到达的位置
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(r<span style="color:#f92672">-</span>l <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">26</span>)<span style="color:#75715e">//r-l==26就满足条件了
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">while</span>(l<span style="color:#f92672">&lt;=</span>lt)<span style="color:#75715e">//l最终到达lt+1,但是lt+1没有被清零
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">if</span>(data[l] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;?&#39;</span>)<span style="color:#75715e">//重置vis
</span><span style="color:#75715e"></span>                vis[data[l]] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
            l<span style="color:#f92672">++</span>;
        }
        <span style="color:#66d9ef">while</span>(r<span style="color:#f92672">&lt;=</span>rt)<span style="color:#75715e">//到达rt后l,r的距离就是26了
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">if</span>(data[r] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;?&#39;</span>)
                <span style="color:#66d9ef">if</span>(vis[data[r]] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//没有标记
</span><span style="color:#75715e"></span>                    vis[data[r]] <span style="color:#f92672">=</span> r;
                <span style="color:#66d9ef">else</span>
                {
                    lt <span style="color:#f92672">=</span> vis[data[r]];<span style="color:#75715e">//标记后就要移动l
</span><span style="color:#75715e"></span>                    rt <span style="color:#f92672">=</span> lt<span style="color:#f92672">+</span><span style="color:#ae81ff">26</span>;<span style="color:#75715e">//新的位置
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">break</span>;
                }
            r<span style="color:#f92672">++</span>;
        }
        <span style="color:#66d9ef">if</span>(rt<span style="color:#f92672">&gt;=</span>i)<span style="color:#75715e">//到达了末端
</span><span style="color:#75715e"></span>        {
            flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">break</span>;
        }
    }

    <span style="color:#66d9ef">if</span>(flag <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)   
        printf(<span style="color:#e6db74">&#34;-1</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">else</span><span style="color:#75715e">//字典序最小
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>l;j<span style="color:#f92672">&lt;=</span>r<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">++</span>)
        {
            <span style="color:#66d9ef">if</span>(data[j] <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;?&#39;</span>)
                printf(<span style="color:#e6db74">&#34;%c&#34;</span>,data[j]);
            <span style="color:#66d9ef">else</span>
            {
                <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">char</span> f<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;A&#39;</span>;f<span style="color:#f92672">&lt;=</span><span style="color:#e6db74">&#39;Z&#39;</span>;f<span style="color:#f92672">++</span>)<span style="color:#75715e">//找到vis第一个为0的输出
</span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">if</span>(vis[f] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
                    {
                        printf(<span style="color:#e6db74">&#34;%c&#34;</span>,f);
                        vis[f] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//标记
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">break</span>;
                    }
            }
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="总结-4">总结<a hidden class="anchor" aria-hidden="true" href="#总结-4">#</a></h3>
<p>这道题在赛场上没做出来太可惜了,思路是对了,但是最后没有判断好l和r的关系,没写好退出的条件,产生了错误,最终没有过</p>
<h2 id="咕咕东的奇妙序列">咕咕东的奇妙序列<a hidden class="anchor" aria-hidden="true" href="#咕咕东的奇妙序列">#</a></h2>
<h3 id="题意-4">题意<a hidden class="anchor" aria-hidden="true" href="#题意-4">#</a></h3>
<p><img src="https://i.loli.net/2020/04/17/Xu3rDvcNzmELR1W.png" alt=""></p>
<p>这道题就是给定了一个规则,我们用这个规则生成了一个序列(当然不可能实际生成出来),求取序列中指定位置的点的值</p>
<h3 id="解法-5">解法<a hidden class="anchor" aria-hidden="true" href="#解法-5">#</a></h3>
<p>使用两次二分来解</p>
<p>第一次二分是找到要查找的元素在哪一个组(第i组是指123 &hellip; i-1 i 这个范围),找到那一组之后还要在二分查找在这一组的哪一个位置</p>
<p>首先我们要知道第i组在序列中是什么位置(第i组结束的位置),我们可以观察规律,很容易发现如果是是第i组,1有i个,2有i-1个&hellip;.10有i-9个,最终i有1个.然后每个数我们都是知道他们的位数的,现在又知道了个数,就很容易求出第i组的位置了.</p>
<p>但是这样一个数一个数的求,效率比较低,我们可以直接把所有t位的数总个数一次求出了,比如2位的数(10-99)一共90个,然后10的个数到99的个数是一个等差数列,用就和公式直接求就行了,最后*2就是2位数占的位置,其他的类似.我们给出一个t位数,我们可以直接求出1-t-1位数总的数字数,然后用同样的方法求t位数的数字数.</p>
<p>这样我们就能完全知道第i组数在序列中的位置了,然后使用二分求出第一个大于等于给定位置的组,再在组中进行操作.</p>
<p>在组中也是要找到第k个数的位置,,这个简单多了,假设k用m位,从1-m-1位的数可以直接求出来,因为每个数的位数是知道的,每个数只出现一次,t位数有几个都知道(比如1位的9个,2位的一共90个,3位的900个).剩下解决m位有几个,k-(1em)+1就是个数了,乘上m算出数字个数了,全部加起来就是位置了</p>
<p>同样我们也使用二分找到第一个大于等于给定位置的数,最终输出想要的哪一位就行了</p>
<p>复杂度分析$O((log_{10}ST)^2logST)$大致应该是这个复杂度,ST是一个常数,因为每次固定从他开始找,因此是稳定的,第ST组数的结束位置已经大于了数据范围</p>
<h3 id="code-5">code<a hidden class="anchor" aria-hidden="true" href="#code-5">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;sstream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#define ST 800000000
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bits</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> num)<span style="color:#75715e">//计算一个数有几位
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(;num<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>;num<span style="color:#f92672">=</span>num<span style="color:#f92672">/</span><span style="color:#ae81ff">10</span>,ans<span style="color:#f92672">++</span>);
    <span style="color:#66d9ef">return</span> ans;
}

<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">power</span>(<span style="color:#66d9ef">int</span> i)<span style="color:#75715e">//10的i次方
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;t<span style="color:#f92672">&lt;</span>i;t<span style="color:#f92672">++</span>)
        ans<span style="color:#f92672">*=</span><span style="color:#ae81ff">10</span>;
    <span style="color:#66d9ef">return</span> ans;
}   

<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">curNum</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> n,<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> s,<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> e)<span style="color:#75715e">//计算等差数列和,顺便乘上n
</span><span style="color:#75715e"></span>{ <span style="color:#66d9ef">return</span> n<span style="color:#f92672">*</span>(e<span style="color:#f92672">+</span>s)<span style="color:#f92672">*</span>(s<span style="color:#f92672">-</span>e<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>; }

<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">allNum</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> temp)<span style="color:#75715e">//计算temp所在的位置
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> bits(temp);<span style="color:#75715e">//有几位
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//记录位置
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//1~n-1位有多少个数字
</span><span style="color:#75715e"></span>    {
        ans<span style="color:#f92672">+=</span>curNum(<span style="color:#ae81ff">1ll</span><span style="color:#f92672">*</span>i,temp<span style="color:#f92672">-</span>power(i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,temp<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>power(i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">9</span><span style="color:#f92672">*</span>power(i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);<span style="color:#75715e">//temp-xxx,表示的等差数列开始位置和结束的位置,这个是符合规律的
</span><span style="color:#75715e"></span>    }
    ans<span style="color:#f92672">+=</span>curNum(n,temp<span style="color:#f92672">-</span>power(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);<span style="color:#75715e">//第n位有几个,也是用规律求的等差数列
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> ans;
}

<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">perNum</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> temp)<span style="color:#75715e">//temp在组内的位置
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> bits(temp);
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>  ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//1~n-1
</span><span style="color:#75715e"></span>        ans<span style="color:#f92672">+=</span> i<span style="color:#f92672">*</span>power(i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">9</span>;
    ans<span style="color:#f92672">+=</span> n<span style="color:#f92672">*</span>(temp<span style="color:#f92672">-</span>power(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">return</span> ans;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> n;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;t<span style="color:#f92672">&lt;</span>n;t<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> k;
        scanf(<span style="color:#e6db74">&#34;%lld&#34;</span>,<span style="color:#f92672">&amp;</span>k);
        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> l<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,r<span style="color:#f92672">=</span>ST;<span style="color:#75715e">//ST是找的一个数,因为allNum(ST)已经超过了数据范围,ST可以降低复杂度
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> mid <span style="color:#f92672">=</span> (l<span style="color:#f92672">+</span>r)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> tar <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//目标
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(l<span style="color:#f92672">&lt;=</span>r)
        {   
            <span style="color:#66d9ef">if</span>(allNum(mid)<span style="color:#f92672">&gt;=</span>k)<span style="color:#75715e">//找第一个大于k的组
</span><span style="color:#75715e"></span>            {
                r<span style="color:#f92672">=</span> mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//右移
</span><span style="color:#75715e"></span>                tar <span style="color:#f92672">=</span> mid;
            }    
            <span style="color:#66d9ef">else</span>
                l<span style="color:#f92672">=</span>mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
            mid <span style="color:#f92672">=</span> (l<span style="color:#f92672">+</span>r)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
        }
        l<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,r<span style="color:#f92672">=</span>tar;<span style="color:#75715e">//下一次二分
</span><span style="color:#75715e"></span>        k<span style="color:#f92672">-=</span>allNum(tar<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);<span style="color:#75715e">//第tar组满足,减去allNum(tar-1)就是tar组内的位置了
</span><span style="color:#75715e"></span>        mid <span style="color:#f92672">=</span> (l<span style="color:#f92672">+</span>r)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">while</span>(l<span style="color:#f92672">&lt;=</span>r)
        {
            <span style="color:#66d9ef">if</span>(perNum(mid)<span style="color:#f92672">&gt;=</span>k)<span style="color:#75715e">//找到tar组内,第一个大于k的数
</span><span style="color:#75715e"></span>            {
                r<span style="color:#f92672">=</span>mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
                tar <span style="color:#f92672">=</span> mid;
            }
            <span style="color:#66d9ef">else</span>
                l<span style="color:#f92672">=</span>mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
            mid <span style="color:#f92672">=</span> (l<span style="color:#f92672">+</span>r)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
        }
        k<span style="color:#f92672">-=</span>perNum(tar<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);<span style="color:#75715e">//减去之后就是在tar这个数内第几个数字了
</span><span style="color:#75715e"></span>        stringstream s;<span style="color:#75715e">//方便输出
</span><span style="color:#75715e"></span>        s<span style="color:#f92672">&lt;&lt;</span>tar;
        string str;
        s<span style="color:#f92672">&gt;&gt;</span>str;
        printf(<span style="color:#e6db74">&#34;%c</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,str[k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]);<span style="color:#75715e">//直接输出
</span><span style="color:#75715e"></span>    }
}
</code></pre></div><h3 id="总结-5">总结<a hidden class="anchor" aria-hidden="true" href="#总结-5">#</a></h3>
<p>这道题一开始写的暴力,结果交的时候硬是交成了第2题的代码,这是不可忍受的的,以后交的时候一定要检查!!!</p>
<p>对于这道题来说找到了规律不算太难,当时看到这么大数据范围i基本上就能想到是二分这类log的算法了,但是码力不太够,不能在30min之内完全打出来,还是有待提升</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://xyfuture.github.io/tags/program/">Program</a></li>
      <li><a href="https://xyfuture.github.io/tags/homework/">homework</a></li>
    </ul>
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://xyfuture.github.io/">My New Hugo Site</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
