<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Program-week9-homework | My New Hugo Site</title>

<meta name="keywords" content="Program, homework" />
<meta name="description" content="week9-homework A - 咕咕东的目录管理器 题意 题面 题目要求实现一个简单的目录管理器,主要是实现几个命令,建议还是去原题看看
解法 命令分为两种操作和询问,对于操作类型来说有一个undo 的操作,因此要使用一个栈来记录所有的操作型指令用于恢复.
首先我们设计文件树的存储(为啥用树?题目直接说了文件树 &hellip; )
这个树肯定是多个孩子的,我们可以用类似孩子链表的形式使用vector nodes存储所有节点,我们要求孩子顺序是字典序,因此使用map&lt;string,int&gt;存储孩子,string是文件名,int是vector种的下标.为了溯源存储一个int father,表示父节点的下标
剩下的几个变量都是为了题目实现而存储的信息.int allNodes代表的是以该节点为根的文件树的总节点数(每次插入或者删除节点向上溯源更新). string nodeName表示文件的当前节点的文件夹名.除此之外vector&lt;string&gt; ftree用来储存tree命令时前后的5个文件夹名.int change储存ftree是否应该发生改变,change=1表示文件结构被更新过,ftree不能用了.
下面讲解各个命令:
首先编写一个pushForward函数,用来从当前节点开始通过father向上更新整棵树,更新allNode和change.使用一个int curPosi记录当前操作的节点下标
mkdir: 首先检查新的文件名是否在children中存在,存在输出ERR.,不存在就新建,插入到nodes中,同时更新children,调用pushForward,将该次命令和操作的两个节点下标插入到栈history
rm: 首先检查children中有没有该文件,没有输出ERR,有就在children中删除(在nodes中不清除节点),调用pushForwad,将命令和操作的两个下标插入到history
cd: 遇到&quot;..&ldquo;直接返回到father,如果father是0(根节点)输出ERR.否则检查孩子中有没有想到的文件名,如果可以没有输出ERR,最后将命令和操作的下标插入到history
sz: 直接输出allNodes
ls: 首先看孩子个数,小于10,全部输出,大于10,输出前5个和后5个
tree: 该命令是比较难实现的,需要一定的记忆化 首先看当前节点的孩子个数,0个输出EMPTY,直接结束.其他情况首先递归实现以该节点为根的文件树通过先根遍历的方式更新ftree.更新时,更新过的节点change改为0表示无需再次更新.然后输出ftree前5个和后5个
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std; struct treeNode { string nodeName;//文件名  int father;//父节点下标  int allNodes;//总的孩子个数&#43;1 sz使用  vector&lt;string&gt; ftree;//tree命令使用的数组,前5个和后5个  int change;//ftree是否发生改变  map&lt;string,int&gt; children;//按字典序存孩子节点的文件名和下标  treeNode(string name,int father,int allNodes,int change):nodeName(name),father(father),allNodes(allNodes),change(change) {} treeNode(){} }; struct cmd { string command; int pwd; int newDir; }; vector&lt;treeNode&gt; nodes;//所有节点的数组,下标就是这里的 stack&lt;cmd&gt; history;//操作命令历史记录 int curPosi;//当前操作的位置的下标  void pushForward(int posi,int num)//从posi开始上溯 { nodes[posi].">
<meta name="author" content="">
<link rel="canonical" href="http://example.org/posts/program-week9-homework/" />
<link href="/assets/css/stylesheet.min.5c4f6d85b7abfcfea458637c672d16a7a9c38c37f002753cfdc7f314b6d3c8f2.css" integrity="sha256-XE9thber/P6kWGN8Zy0Wp6nDjDfwAnU8/cfzFLbTyPI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="http://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="http://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />


<meta property="og:title" content="Program-week9-homework" />
<meta property="og:description" content="week9-homework A - 咕咕东的目录管理器 题意 题面 题目要求实现一个简单的目录管理器,主要是实现几个命令,建议还是去原题看看
解法 命令分为两种操作和询问,对于操作类型来说有一个undo 的操作,因此要使用一个栈来记录所有的操作型指令用于恢复.
首先我们设计文件树的存储(为啥用树?题目直接说了文件树 &hellip; )
这个树肯定是多个孩子的,我们可以用类似孩子链表的形式使用vector nodes存储所有节点,我们要求孩子顺序是字典序,因此使用map&lt;string,int&gt;存储孩子,string是文件名,int是vector种的下标.为了溯源存储一个int father,表示父节点的下标
剩下的几个变量都是为了题目实现而存储的信息.int allNodes代表的是以该节点为根的文件树的总节点数(每次插入或者删除节点向上溯源更新). string nodeName表示文件的当前节点的文件夹名.除此之外vector&lt;string&gt; ftree用来储存tree命令时前后的5个文件夹名.int change储存ftree是否应该发生改变,change=1表示文件结构被更新过,ftree不能用了.
下面讲解各个命令:
首先编写一个pushForward函数,用来从当前节点开始通过father向上更新整棵树,更新allNode和change.使用一个int curPosi记录当前操作的节点下标
mkdir: 首先检查新的文件名是否在children中存在,存在输出ERR.,不存在就新建,插入到nodes中,同时更新children,调用pushForward,将该次命令和操作的两个节点下标插入到栈history
rm: 首先检查children中有没有该文件,没有输出ERR,有就在children中删除(在nodes中不清除节点),调用pushForwad,将命令和操作的两个下标插入到history
cd: 遇到&quot;..&ldquo;直接返回到father,如果father是0(根节点)输出ERR.否则检查孩子中有没有想到的文件名,如果可以没有输出ERR,最后将命令和操作的下标插入到history
sz: 直接输出allNodes
ls: 首先看孩子个数,小于10,全部输出,大于10,输出前5个和后5个
tree: 该命令是比较难实现的,需要一定的记忆化 首先看当前节点的孩子个数,0个输出EMPTY,直接结束.其他情况首先递归实现以该节点为根的文件树通过先根遍历的方式更新ftree.更新时,更新过的节点change改为0表示无需再次更新.然后输出ftree前5个和后5个
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std; struct treeNode { string nodeName;//文件名  int father;//父节点下标  int allNodes;//总的孩子个数&#43;1 sz使用  vector&lt;string&gt; ftree;//tree命令使用的数组,前5个和后5个  int change;//ftree是否发生改变  map&lt;string,int&gt; children;//按字典序存孩子节点的文件名和下标  treeNode(string name,int father,int allNodes,int change):nodeName(name),father(father),allNodes(allNodes),change(change) {} treeNode(){} }; struct cmd { string command; int pwd; int newDir; }; vector&lt;treeNode&gt; nodes;//所有节点的数组,下标就是这里的 stack&lt;cmd&gt; history;//操作命令历史记录 int curPosi;//当前操作的位置的下标  void pushForward(int posi,int num)//从posi开始上溯 { nodes[posi]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/program-week9-homework/" />
<meta property="article:published_time" content="2020-04-29T21:28:23+00:00" />
<meta property="article:modified_time" content="2020-04-29T21:28:23+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Program-week9-homework"/>
<meta name="twitter:description" content="week9-homework A - 咕咕东的目录管理器 题意 题面 题目要求实现一个简单的目录管理器,主要是实现几个命令,建议还是去原题看看
解法 命令分为两种操作和询问,对于操作类型来说有一个undo 的操作,因此要使用一个栈来记录所有的操作型指令用于恢复.
首先我们设计文件树的存储(为啥用树?题目直接说了文件树 &hellip; )
这个树肯定是多个孩子的,我们可以用类似孩子链表的形式使用vector nodes存储所有节点,我们要求孩子顺序是字典序,因此使用map&lt;string,int&gt;存储孩子,string是文件名,int是vector种的下标.为了溯源存储一个int father,表示父节点的下标
剩下的几个变量都是为了题目实现而存储的信息.int allNodes代表的是以该节点为根的文件树的总节点数(每次插入或者删除节点向上溯源更新). string nodeName表示文件的当前节点的文件夹名.除此之外vector&lt;string&gt; ftree用来储存tree命令时前后的5个文件夹名.int change储存ftree是否应该发生改变,change=1表示文件结构被更新过,ftree不能用了.
下面讲解各个命令:
首先编写一个pushForward函数,用来从当前节点开始通过father向上更新整棵树,更新allNode和change.使用一个int curPosi记录当前操作的节点下标
mkdir: 首先检查新的文件名是否在children中存在,存在输出ERR.,不存在就新建,插入到nodes中,同时更新children,调用pushForward,将该次命令和操作的两个节点下标插入到栈history
rm: 首先检查children中有没有该文件,没有输出ERR,有就在children中删除(在nodes中不清除节点),调用pushForwad,将命令和操作的两个下标插入到history
cd: 遇到&quot;..&ldquo;直接返回到father,如果father是0(根节点)输出ERR.否则检查孩子中有没有想到的文件名,如果可以没有输出ERR,最后将命令和操作的下标插入到history
sz: 直接输出allNodes
ls: 首先看孩子个数,小于10,全部输出,大于10,输出前5个和后5个
tree: 该命令是比较难实现的,需要一定的记忆化 首先看当前节点的孩子个数,0个输出EMPTY,直接结束.其他情况首先递归实现以该节点为根的文件树通过先根遍历的方式更新ftree.更新时,更新过的节点change改为0表示无需再次更新.然后输出ftree前5个和后5个
code #include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;map&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std; struct treeNode { string nodeName;//文件名  int father;//父节点下标  int allNodes;//总的孩子个数&#43;1 sz使用  vector&lt;string&gt; ftree;//tree命令使用的数组,前5个和后5个  int change;//ftree是否发生改变  map&lt;string,int&gt; children;//按字典序存孩子节点的文件名和下标  treeNode(string name,int father,int allNodes,int change):nodeName(name),father(father),allNodes(allNodes),change(change) {} treeNode(){} }; struct cmd { string command; int pwd; int newDir; }; vector&lt;treeNode&gt; nodes;//所有节点的数组,下标就是这里的 stack&lt;cmd&gt; history;//操作命令历史记录 int curPosi;//当前操作的位置的下标  void pushForward(int posi,int num)//从posi开始上溯 { nodes[posi]."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Program-week9-homework",
  "name": "Program-week9-homework",
  "description": "week9-homework A - 咕咕东的目录管理器 题意 题面 题目要求实现一个简单的目录管理器,主要是实现几个命令,建议还是去原题看看\n解法 命令分为两种操作和询问,对于操作类型来说有一个undo 的操作,因此要使用一个栈来记录所有的操作型指令用于恢复.\n首先我们设计文件树的存储(为啥用树?题目直接说了文件树 \u0026amp;hellip; )\n这个树肯定是多个孩 …",
  "keywords": [
    "Program", "homework"
  ],
  "articleBody": "week9-homework A - 咕咕东的目录管理器 题意 题面 题目要求实现一个简单的目录管理器,主要是实现几个命令,建议还是去原题看看\n解法 命令分为两种操作和询问,对于操作类型来说有一个undo 的操作,因此要使用一个栈来记录所有的操作型指令用于恢复.\n首先我们设计文件树的存储(为啥用树?题目直接说了文件树 … )\n这个树肯定是多个孩子的,我们可以用类似孩子链表的形式使用vector nodes存储所有节点,我们要求孩子顺序是字典序,因此使用map存储孩子,string是文件名,int是vector种的下标.为了溯源存储一个int father,表示父节点的下标\n剩下的几个变量都是为了题目实现而存储的信息.int allNodes代表的是以该节点为根的文件树的总节点数(每次插入或者删除节点向上溯源更新). string nodeName表示文件的当前节点的文件夹名.除此之外vector ftree用来储存tree命令时前后的5个文件夹名.int change储存ftree是否应该发生改变,change=1表示文件结构被更新过,ftree不能用了.\n下面讲解各个命令:\n首先编写一个pushForward函数,用来从当前节点开始通过father向上更新整棵树,更新allNode和change.使用一个int curPosi记录当前操作的节点下标\nmkdir: 首先检查新的文件名是否在children中存在,存在输出ERR.,不存在就新建,插入到nodes中,同时更新children,调用pushForward,将该次命令和操作的两个节点下标插入到栈history\nrm: 首先检查children中有没有该文件,没有输出ERR,有就在children中删除(在nodes中不清除节点),调用pushForwad,将命令和操作的两个下标插入到history\ncd: 遇到\"..“直接返回到father,如果father是0(根节点)输出ERR.否则检查孩子中有没有想到的文件名,如果可以没有输出ERR,最后将命令和操作的下标插入到history\nsz: 直接输出allNodes\nls: 首先看孩子个数,小于10,全部输出,大于10,输出前5个和后5个\ntree: 该命令是比较难实现的,需要一定的记忆化 首先看当前节点的孩子个数,0个输出EMPTY,直接结束.其他情况首先递归实现以该节点为根的文件树通过先根遍历的方式更新ftree.更新时,更新过的节点change改为0表示无需再次更新.然后输出ftree前5个和后5个\ncode #include #include #include #include #include #include #include #include using namespace std; struct treeNode { string nodeName;//文件名  int father;//父节点下标  int allNodes;//总的孩子个数+1 sz使用  vectorstring ftree;//tree命令使用的数组,前5个和后5个  int change;//ftree是否发生改变  mapstring,int children;//按字典序存孩子节点的文件名和下标  treeNode(string name,int father,int allNodes,int change):nodeName(name),father(father),allNodes(allNodes),change(change) {} treeNode(){} }; struct cmd { string command; int pwd; int newDir; }; vectortreeNode nodes;//所有节点的数组,下标就是这里的 stackcmd history;//操作命令历史记录 int curPosi;//当前操作的位置的下标  void pushForward(int posi,int num)//从posi开始上溯 { nodes[posi].allNodes +=num;//更新allNode  nodes[posi].change = 1;//ftree要重新改变  nodes[posi].ftree.clear();//清空(也可以不删)  if(nodes[posi].father == posi)//到达根节点  return ; else //继续更新父节点  pushForward(nodes[posi].father,num); } void mkdir() { string newDirName; cinnewDirName; if (nodes[curPosi].children.find(newDirName) != nodes[curPosi].children.end()) { cout\"ERR\\n\"; return ; } nodes.push_back(treeNode(newDirName,curPosi,1,1));//插入新节点  int newPosi = nodes.size() - 1; pushForward(curPosi,1);//向上更新  nodes[curPosi].children[newDirName] =newPosi;//孩子  history.push({\"mkdir\",curPosi,newPosi});//更新history  cout\"OK\\n\"; } void rm() { string delDirName; cindelDirName; if (nodes[curPosi].children.find(delDirName) == nodes[curPosi].children.end()) { cout\"ERR\\n\"; return ; } int ptr =nodes[curPosi].children[delDirName]; int cnt = nodes[ptr].allNodes; nodes[curPosi].children.erase(delDirName);//只删除孩子,不删除nodes  history.push({\"rm\",curPosi,ptr}); cout\"OK\\n\"; } void cd() { string newDirName; cinnewDirName; if(newDirName == \"..\")//father  { if(nodes[curPosi].father == curPosi) { cout\"ERR\\n\"; return ; } int newPosi = nodes[curPosi].father; history.push({\"cd\",curPosi,newPosi}); curPosi = newPosi; cout\"OK\\n\"; return ; } if(nodes[curPosi].children.find(newDirName) == nodes[curPosi].children.end()) { cout\"ERR\\n\"; return ; } int newPosi = nodes[curPosi].children[newDirName]; history.push({\"cd\",curPosi,newPosi}); curPosi = newPosi; cout\"OK\\n\"; } void sz() { int cnt = nodes[curPosi].allNodes; coutcntendl; } void ls() { int childSize = nodes[curPosi].children.size(); if(childSize == 0) cout\"EMPTY\\n\"; else if (childSize 10)//10个之内  { for(auto i:nodes[curPosi].children) couti.firstendl; // cout } else { mapstring,int::iterator front = nodes[curPosi].children.begin(); mapstring,int::iterator tail = nodes[curPosi].children.end(); for(int i=0;i5;i++,front++)//前5个  cout(*front).firstendl; // tail--;  cout\"...\\n\"; for(int i=0;i5;i++,tail--);//后5个  for(int i=0;i5;i++,tail++) cout(*tail).firstendl; // cout } } void undo() { if(history.size() == 0) { cout\"ERR\\n\"; return ; } cmd oldCmd = history.top(); history.pop(); if(oldCmd.command == \"mkdir\") { nodes[oldCmd.pwd].children.erase(nodes[oldCmd.newDir].nodeName);//去除孩子  int cnt = nodes[oldCmd.newDir].allNodes; pushForward(oldCmd.pwd,-1*cnt);//更新allnNodes  } else if(oldCmd.command == \"rm\") { nodes[oldCmd.pwd].children[nodes[oldCmd.newDir].nodeName] = oldCmd.newDir;//加回孩子  int cnt = nodes[oldCmd.newDir].allNodes; pushForward(oldCmd.pwd,cnt); } else if(oldCmd.command == \"cd\") { curPosi = oldCmd.pwd;//直接回退  } cout\"OK\\n\"; } void firstRoot(int ptr,int cur)//在allNodes小于10的时候直接先根遍历更新ftree就行了 { nodes[ptr].ftree.push_back(nodes[cur].nodeName); for(auto i:nodes[cur].children) firstRoot(ptr,i.second); } void begin_end(int ptr)//更新ftree { if(nodes[ptr].change == 0)//已经更新过了  return ; if(nodes[ptr].allNodes10)//10个节点及一下  { firstRoot(ptr,ptr); nodes[ptr].change = 0; return ; } else { for(auto i:nodes[ptr].children)//更新所有孩子的  begin_end(i.second); nodes[ptr].ftree.push_back(nodes[ptr].nodeName);//先放入自己  int cnt = 0; for(auto i:nodes[ptr].children)//前4个  { if(cnt=4) break; for(int t=0;tnodes[i.second].ftree.size();t++) if(cnt++4) nodes[ptr].ftree.push_back(nodes[i.second].ftree[t]); else break; } cnt = 0; for(mapstring,int::reverse_iterator it=nodes[ptr].children.rbegin();it!=nodes[ptr].children.rend();it++)//后5个  { if(cnt=5) break; for(int t=nodes[(*it).second].ftree.size()-1;t=0;t--)//倒着的  if(cnt++5) nodes[ptr].ftree.insert(nodes[ptr].ftree.begin()+5,nodes[(*it).second].ftree[t]); else break; } nodes[ptr].change = 0; } } void tree() { int childSize = nodes[curPosi].allNodes; if( childSize== 1 ) { cout\"EMPTY\\n\"; return ; } begin_end(curPosi); if(childSize10) for(auto i:nodes[curPosi].ftree) couti\"\\n\"; else { for(int i=0;i5;i++) coutnodes[curPosi].ftree[i]\"\\n\"; cout\"...\\n\";//输出... 仔细看提  for(int i=5;i10;i++) coutnodes[curPosi].ftree[i]\"\\n\"; } } int main() { treeNode rootNode (\"root\",0,1,1); string curCmd; int t=0; cint; for(int i=0;it;i++) { int q; nodes.clear();//空间释放!!!!  nodes.push_back(rootNode); while(!history.empty()) history.pop(); curPosi = 0; cinq; for(int j=0;jq;j++) { cincurCmd; if(curCmd == \"MKDIR\") mkdir(); else if(curCmd == \"RM\") rm(); else if(curCmd == \"CD\") cd(); else if(curCmd == \"SZ\") sz(); else if(curCmd == \"LS\") ls(); else if(curCmd == \"TREE\") tree(); else if(curCmd == \"UNDO\") undo(); } } } 总结 把本次模拟较为复杂,难点主要集中在tree的实现上,因为数据规模的原因直接进行前序遍历复杂度会超时,因此采取记忆化的操作,这样只在插入删除新的节点后才进行更新,其他情况直接使用存储的tree信息.\n除此之外stl的map使用也值得一看,直接实现了有序的查找,复杂度还低\nB - 东东学打牌 题意 和之前做过的那个发牌的题挺类似,使用类似搜索的方法\n解法 首先使用个结构体来handCard记录一个人的姓名和手牌,姓名使用string手牌使用vector,手牌转换为数字.使用一个handCard数组记录有所人的手牌.\n然后开8个vector,分别表示8种情况下的人,然后写8个函数,分别判断一个人的手牌是哪一种情况,然后分配到对应的vector\n针对这个8种情况编写几个排序函数,实现题目中要求的顺序,有几个排序方法使能复用的.\n在8个判断函数中,使用map实现对同一数字手牌个数的判断.\ncode #include #include #include #include #include #include #include #include #include  using namespace std;//手牌和人名  struct handCard { string name; vectorint cards; }; handCard allCard[1000];//所有人的情况 int exchanges[100];//将ascii码转换为对应的数字 int longshun[] = {1,10,11,12,13};//龙顺判断 // priority_queue,greater  ans[8]; vectorint ans[8];//8种类型  inline int getCardNum(int ptr,int i)//获取一张手牌 {return allCard[ptr].cards[i];} mapint,int getCnt(int ptr)//获得计数的字典 { mapint,int mp; for(int i=0;i5;i++) mp[allCard[ptr].cards[i]]++; return mp; } void distribute(int ptr)//判断一套牌属于哪一个类型 { mapint,int mp = getCnt(ptr); int i =0 ; {//龙顺  for(i=0;i5;i++) if(allCard[ptr].cards[i]!=longshun[i]) break; if(i == 5) { ans[7].push_back(ptr); return ; } } {//顺子  for(i=0;i4;i++) if(allCard[ptr].cards[i]+1!=allCard[ptr].cards[i+1]) break; if(i == 4) { ans[6].push_back(ptr); return ; } } {//炸弹  for(auto t:mp) if(t.second == 4) { ans[5].push_back(ptr); return; } } {//三带二  int flag = 1; for(auto t:mp) if(t.second!=3\u0026\u0026t.second!=2) { flag = 0; break; } if(flag) { ans[4].push_back(ptr); return; } } {//三个  for(auto t:mp) if(t.second == 3) { ans[3].push_back(ptr); return; } } {//两对  int flag =0 ; for(auto t:mp) if(t.second == 2) flag++; if(flag == 2) { ans[2].push_back(ptr); return; } } {//对子  for(auto t:mp) if(t.second == 2) { ans[1].push_back(ptr); return; } } ans[0].push_back(ptr);//大牌 } bool nameOrder(int a,int b)//比较大牌,实际上就是名字的字典序 {return allCard[a].nameallCard[b].name;} bool numOrder(int a,int b)//所有手牌和的大小,顺子比较直接使用,大数也直接使用 { int al=0,bl=0; for(int i=0;i5;i++) al+=allCard[a].cards[i],bl+=allCard[b].cards[i]; if(albl) return true; else if (al==bl) return nameOrder(a,b); return false; } bool cmp6(int a,int b)//炸弹 { if(getCardNum(a,1)getCardNum(b,1))//炸弹大小  return true; else if(getCardNum(a,1) == getCardNum(b,1)) return numOrder(a,b);//比较剩下的一张牌  return false; } bool cmp5(int a,int b)//三带二 { mapint,int mpa = getCnt(a); mapint,int mpb = getCnt(b); int al=0,bl=0; for(auto t:mpa) if(t.second == 3) al=t.first; for(auto t:mpb) if(t.second == 3) bl=t.first; if(albl)//比较三  return true; else if(al==bl)//比较二  return numOrder(a,b); return false; } //三个和三带二一样 bool cmp3(int a,int b)//两对 { int al[2]; int bl[2]; int i=0; mapint,int mpa = getCnt(a); mapint,int mpb = getCnt(b); for(auto t:mpa) if(t.second == 2)//两个对子  al[i++] = t.first; i=0; for(auto t:mpb) if(t.second == 2) bl[i++] = t.first; if(al[1]bl[1]) return true; else if(al[1]==bl[1]) if(al[0]bl[0]) return true; else if(al[0] == bl[0]) return numOrder(a,b);//比较剩下的那一个数  return false; } bool cmp2(int a,int b)//对子 { mapint,int mpa = getCnt(a); mapint,int mpb= getCnt(b); int al=0,bl=0; for(auto t:mpa) if(t.second == 2) al =t.first; for(auto t:mpb) if(t.second == 2) bl=t.first; if(albl) //比较唯一的一个对子  return true; else if(al == bl) return numOrder(a,b);//比较剩下的  return false; } void output() { sort(ans[0].begin(),ans[0].end(),numOrder);//排序  sort(ans[1].begin(),ans[1].end(),cmp2); sort(ans[2].begin(),ans[2].end(),cmp3); sort(ans[3].begin(),ans[3].end(),cmp5); sort(ans[4].begin(),ans[4].end(),cmp5); sort(ans[5].begin(),ans[5].end(),cmp6); sort(ans[6].begin(),ans[6].end(),numOrder); sort(ans[7].begin(),ans[7].end(),nameOrder); // sort(ans[0].begin(),ans[0].end(),);  for(int i=7;i=0;i--)//输出结果  for(vectorint::reverse_iterator it=ans[i].rbegin();it!=ans[i].rend();it++) coutallCard[*it].name\"\\n\"; } int readInt()//读入一个ascii转换为int { char temp; scanf(\"%c\",\u0026temp); if(temp == '1') { getchar(); return 10; } return change[temp]; } int main() { memset(change,0,sizeof(change)); int s=2; for(char i='2';i'9';i++,s++) change[i] = s; change['A'] = 1;//初始化  change['J'] = 11; change['Q'] = 12; change['K'] = 13; int k; while(scanf(\"%d\",\u0026k)!=EOF) { // getchar();  for(int i=0;ik;i++) allCard[i].cards.clear(); for(int i=0;i8;i++) ans[i].clear(); for(int i=0;ik;i++) { cinallCard[i].name; getchar(); for(int t=0;t5;t++) allCard[i].cards.push_back(readInt()); sort(allCard[i].cards.begin(),allCard[i].cards.end());//将每张手牌排序  } for(int i=0;ik;i++) distribute(i);//把每个人手牌的类型分类  output();//输出  } return 0; } 总结 这道题不是很难,主要是就是考虑题目中给出的几个情况的判断,判断同一个大小的牌数是一个比较麻烦的部分,使用map复杂度能低一些.另一个重要的地方是函数结构的设计,尽量提高的代码的复用率\nC - 签到题，独立思考哈 题面 这个题实际上就是一个分配的问题,如何分配使所有单位的最大值最大或者最小\n解法 首先最大值最小首先采取的方法就是平均值,一平均就是最小的,但是因为已经分配好的不能再懂了,如果现在的最大值比平均后的值大,说明加入y之后最小的最大值还是原来的最大值,如果最大值小于平均值,那么平均值就是最小最大值\n最大最大值就很简单了,直接在现在最大值的基础上加上y就行了\ncode #include #include #include #include #include  using namespace std; int data[105]; int main() { memset(data,0,sizeof(data)); int x,y; scanf(\"%d%d\",\u0026x,\u0026y); for(int i=0;ix;i++) scanf(\"%d\",data+i); int sum=0;//当前的总计,用于求平均数  int Max=0;//当前的最大值  for(int i=0;ix;i++) { sum+=data[i];//统计  if(data[i]Max) Max = data[i];//最大值  } int mn = ceil((sum+y)/(x*1.0));//加上y的平均数  if(mnMax)//当前最大值大于平均数  mn = Max;//取当前最大值  int mx = Max+y;///最大的最大值  printf(\"%d %d\",mn,mx); } 总结 这道题不难,主要是就把最小的最大值情况想全了就行\n",
  "wordCount" : "994",
  "inLanguage": "en",
  "datePublished": "2020-04-29T21:28:23Z",
  "dateModified": "2020-04-29T21:28:23Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://example.org/posts/program-week9-homework/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "http://example.org/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()"></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Program-week9-homework
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">April 29, 2020

    </div>
  </header> 

  <div class="post-content">
<h1 id="week9-homework">week9-homework<a hidden class="anchor" aria-hidden="true" href="#week9-homework">#</a></h1>
<h2 id="a---咕咕东的目录管理器httpsvjudgenetproblemkattis-directorymanagement"><a href="https://vjudge.net/problem/Kattis-directorymanagement">A - 咕咕东的目录管理器</a><a hidden class="anchor" aria-hidden="true" href="#a---咕咕东的目录管理器httpsvjudgenetproblemkattis-directorymanagement">#</a></h2>
<h3 id="题意">题意<a hidden class="anchor" aria-hidden="true" href="#题意">#</a></h3>
<h4 id="题面">题面<a hidden class="anchor" aria-hidden="true" href="#题面">#</a></h4>
<p><img src="https://i.loli.net/2020/05/04/CG9PtmcWDFk8oEp.png" alt=""></p>
<p>题目要求实现一个简单的目录管理器,主要是实现几个命令,建议还是去原题看看</p>
<h3 id="解法">解法<a hidden class="anchor" aria-hidden="true" href="#解法">#</a></h3>
<p>命令分为两种操作和询问,对于操作类型来说有一个undo 的操作,因此要使用一个栈来记录所有的操作型指令用于恢复.</p>
<p>首先我们设计文件树的存储(为啥用树?题目直接说了文件树 &hellip; )</p>
<p>这个树肯定是多个孩子的,我们可以用类似孩子链表的形式使用vector nodes存储所有节点,我们要求孩子顺序是字典序,因此使用map&lt;string,int&gt;存储孩子,string是文件名,int是vector种的下标.为了溯源存储一个int father,表示父节点的下标</p>
<p>剩下的几个变量都是为了题目实现而存储的信息.int allNodes代表的是以该节点为根的文件树的总节点数(每次插入或者删除节点向上溯源更新). string nodeName表示文件的当前节点的文件夹名.除此之外vector&lt;string&gt; ftree用来储存tree命令时前后的5个文件夹名.int change储存ftree是否应该发生改变,change=1表示文件结构被更新过,ftree不能用了.</p>
<p>下面讲解各个命令:</p>
<p>首先编写一个pushForward函数,用来从当前节点开始通过father向上更新整棵树,更新allNode和change.使用一个int curPosi记录当前操作的节点下标</p>
<p>mkdir: 首先检查新的文件名是否在children中存在,存在输出ERR.,不存在就新建,插入到nodes中,同时更新children,调用pushForward,将该次命令和操作的两个节点下标插入到栈history</p>
<p>rm: 首先检查children中有没有该文件,没有输出ERR,有就在children中删除(在nodes中不清除节点),调用pushForwad,将命令和操作的两个下标插入到history</p>
<p>cd: 遇到&quot;..&ldquo;直接返回到father,如果father是0(根节点)输出ERR.否则检查孩子中有没有想到的文件名,如果可以没有输出ERR,最后将命令和操作的下标插入到history</p>
<p>sz: 直接输出allNodes</p>
<p>ls: 首先看孩子个数,小于10,全部输出,大于10,输出前5个和后5个</p>
<p>tree: 该命令是比较难实现的,需要一定的记忆化
首先看当前节点的孩子个数,0个输出EMPTY,直接结束.其他情况首先递归实现以该节点为根的文件树通过先根遍历的方式更新ftree.更新时,更新过的节点change改为0表示无需再次更新.然后输出ftree前5个和后5个</p>
<h3 id="code">code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stack&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">treeNode</span>
{
    string nodeName;<span style="color:#75715e">//文件名
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> father;<span style="color:#75715e">//父节点下标
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> allNodes;<span style="color:#75715e">//总的孩子个数+1 sz使用
</span><span style="color:#75715e"></span>    vector<span style="color:#f92672">&lt;</span>string<span style="color:#f92672">&gt;</span> ftree;<span style="color:#75715e">//tree命令使用的数组,前5个和后5个
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> change;<span style="color:#75715e">//ftree是否发生改变
</span><span style="color:#75715e"></span>    map<span style="color:#f92672">&lt;</span>string,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> children;<span style="color:#75715e">//按字典序存孩子节点的文件名和下标
</span><span style="color:#75715e"></span>    treeNode(string name,<span style="color:#66d9ef">int</span> father,<span style="color:#66d9ef">int</span> allNodes,<span style="color:#66d9ef">int</span> change)<span style="color:#f92672">:</span>nodeName(name),father(father),allNodes(allNodes),change(change)
    {}
    treeNode(){}
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">cmd</span> 
{
    string command;
    <span style="color:#66d9ef">int</span> pwd;
    <span style="color:#66d9ef">int</span> newDir;
};

vector<span style="color:#f92672">&lt;</span>treeNode<span style="color:#f92672">&gt;</span> nodes;<span style="color:#75715e">//所有节点的数组,下标就是这里的
</span><span style="color:#75715e"></span>stack<span style="color:#f92672">&lt;</span>cmd<span style="color:#f92672">&gt;</span> history;<span style="color:#75715e">//操作命令历史记录
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> curPosi;<span style="color:#75715e">//当前操作的位置的下标
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">pushForward</span>(<span style="color:#66d9ef">int</span> posi,<span style="color:#66d9ef">int</span> num)<span style="color:#75715e">//从posi开始上溯
</span><span style="color:#75715e"></span>{
    
    nodes[posi].allNodes <span style="color:#f92672">+=</span>num;<span style="color:#75715e">//更新allNode
</span><span style="color:#75715e"></span>    nodes[posi].change <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//ftree要重新改变
</span><span style="color:#75715e"></span>    nodes[posi].ftree.clear();<span style="color:#75715e">//清空(也可以不删)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(nodes[posi].father <span style="color:#f92672">==</span> posi)<span style="color:#75715e">//到达根节点
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> ;
    <span style="color:#66d9ef">else</span> <span style="color:#75715e">//继续更新父节点
</span><span style="color:#75715e"></span>        pushForward(nodes[posi].father,num);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mkdir</span>()
{
    string newDirName;
    cin<span style="color:#f92672">&gt;&gt;</span>newDirName;
    <span style="color:#66d9ef">if</span> (nodes[curPosi].children.find(newDirName) <span style="color:#f92672">!=</span> nodes[curPosi].children.end())
    {
        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;ERR</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#66d9ef">return</span> ;
    }
    nodes.push_back(treeNode(newDirName,curPosi,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>));<span style="color:#75715e">//插入新节点
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> newPosi <span style="color:#f92672">=</span> nodes.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;

    pushForward(curPosi,<span style="color:#ae81ff">1</span>);<span style="color:#75715e">//向上更新
</span><span style="color:#75715e"></span>    nodes[curPosi].children[newDirName] <span style="color:#f92672">=</span>newPosi;<span style="color:#75715e">//孩子
</span><span style="color:#75715e"></span>    history.push({<span style="color:#e6db74">&#34;mkdir&#34;</span>,curPosi,newPosi});<span style="color:#75715e">//更新history
</span><span style="color:#75715e"></span>    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;OK</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">rm</span>()
{
    string delDirName;
    cin<span style="color:#f92672">&gt;&gt;</span>delDirName;
    <span style="color:#66d9ef">if</span> (nodes[curPosi].children.find(delDirName) <span style="color:#f92672">==</span> nodes[curPosi].children.end())
    {
        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;ERR</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#66d9ef">return</span> ;
    }
    <span style="color:#66d9ef">int</span> ptr <span style="color:#f92672">=</span>nodes[curPosi].children[delDirName];
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> nodes[ptr].allNodes;
    nodes[curPosi].children.erase(delDirName);<span style="color:#75715e">//只删除孩子,不删除nodes
</span><span style="color:#75715e"></span>    history.push({<span style="color:#e6db74">&#34;rm&#34;</span>,curPosi,ptr});
    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;OK</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cd</span>()
{
    string newDirName;
    cin<span style="color:#f92672">&gt;&gt;</span>newDirName;
    <span style="color:#66d9ef">if</span>(newDirName <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;..&#34;</span>)<span style="color:#75715e">//father
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">if</span>(nodes[curPosi].father <span style="color:#f92672">==</span> curPosi)
        {
            cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;ERR</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
            <span style="color:#66d9ef">return</span> ;
        }
        <span style="color:#66d9ef">int</span> newPosi <span style="color:#f92672">=</span> nodes[curPosi].father;
        history.push({<span style="color:#e6db74">&#34;cd&#34;</span>,curPosi,newPosi});
        curPosi <span style="color:#f92672">=</span> newPosi;
        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;OK</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#66d9ef">return</span> ;
    }
    <span style="color:#66d9ef">if</span>(nodes[curPosi].children.find(newDirName) <span style="color:#f92672">==</span> nodes[curPosi].children.end())
    {
        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;ERR</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#66d9ef">return</span> ;
    }
    <span style="color:#66d9ef">int</span> newPosi <span style="color:#f92672">=</span> nodes[curPosi].children[newDirName];
    history.push({<span style="color:#e6db74">&#34;cd&#34;</span>,curPosi,newPosi});
    curPosi <span style="color:#f92672">=</span> newPosi;
    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;OK</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sz</span>()
{
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> nodes[curPosi].allNodes;
    cout<span style="color:#f92672">&lt;&lt;</span>cnt<span style="color:#f92672">&lt;&lt;</span>endl;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ls</span>()
{
    <span style="color:#66d9ef">int</span> childSize <span style="color:#f92672">=</span> nodes[curPosi].children.size();
    <span style="color:#66d9ef">if</span>(childSize <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;EMPTY</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (childSize <span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">10</span>)<span style="color:#75715e">//10个之内
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i:nodes[curPosi].children)
            cout<span style="color:#f92672">&lt;&lt;</span>i.first<span style="color:#f92672">&lt;&lt;</span>endl;
        <span style="color:#75715e">// cout&lt;&lt;&#34;\n&#34;;
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">else</span>
    {
        map<span style="color:#f92672">&lt;</span>string,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator front <span style="color:#f92672">=</span> nodes[curPosi].children.begin();
        map<span style="color:#f92672">&lt;</span>string,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator tail <span style="color:#f92672">=</span> nodes[curPosi].children.end();
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span>;i<span style="color:#f92672">++</span>,front<span style="color:#f92672">++</span>)<span style="color:#75715e">//前5个
</span><span style="color:#75715e"></span>            cout<span style="color:#f92672">&lt;&lt;</span>(<span style="color:#f92672">*</span>front).first<span style="color:#f92672">&lt;&lt;</span>endl;
        <span style="color:#75715e">// tail--;
</span><span style="color:#75715e"></span>        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span>;i<span style="color:#f92672">++</span>,tail<span style="color:#f92672">--</span>);<span style="color:#75715e">//后5个
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span>;i<span style="color:#f92672">++</span>,tail<span style="color:#f92672">++</span>)
            cout<span style="color:#f92672">&lt;&lt;</span>(<span style="color:#f92672">*</span>tail).first<span style="color:#f92672">&lt;&lt;</span>endl;
        <span style="color:#75715e">// cout&lt;&lt;&#34;\n&#34;;
</span><span style="color:#75715e"></span>    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">undo</span>()
{
    <span style="color:#66d9ef">if</span>(history.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
    {
        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;ERR</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#66d9ef">return</span> ;
    }
    cmd oldCmd <span style="color:#f92672">=</span> history.top();
    history.pop();
    <span style="color:#66d9ef">if</span>(oldCmd.command <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;mkdir&#34;</span>)
    {
        nodes[oldCmd.pwd].children.erase(nodes[oldCmd.newDir].nodeName);<span style="color:#75715e">//去除孩子
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> nodes[oldCmd.newDir].allNodes;
        pushForward(oldCmd.pwd,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">*</span>cnt);<span style="color:#75715e">//更新allnNodes
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(oldCmd.command <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;rm&#34;</span>)
    {
        nodes[oldCmd.pwd].children[nodes[oldCmd.newDir].nodeName] <span style="color:#f92672">=</span> oldCmd.newDir;<span style="color:#75715e">//加回孩子
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> nodes[oldCmd.newDir].allNodes;
        pushForward(oldCmd.pwd,cnt);
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(oldCmd.command <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;cd&#34;</span>)
    {
        curPosi <span style="color:#f92672">=</span> oldCmd.pwd;<span style="color:#75715e">//直接回退
</span><span style="color:#75715e"></span>    }
    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;OK</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
}


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">firstRoot</span>(<span style="color:#66d9ef">int</span> ptr,<span style="color:#66d9ef">int</span> cur)<span style="color:#75715e">//在allNodes小于10的时候直接先根遍历更新ftree就行了
</span><span style="color:#75715e"></span>{
    nodes[ptr].ftree.push_back(nodes[cur].nodeName);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i:nodes[cur].children)
        firstRoot(ptr,i.second);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">begin_end</span>(<span style="color:#66d9ef">int</span> ptr)<span style="color:#75715e">//更新ftree
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">if</span>(nodes[ptr].change <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//已经更新过了
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> ;
    <span style="color:#66d9ef">if</span>(nodes[ptr].allNodes<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">10</span>)<span style="color:#75715e">//10个节点及一下
</span><span style="color:#75715e"></span>    {
        firstRoot(ptr,ptr);
        nodes[ptr].change <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span> ;
    }
    <span style="color:#66d9ef">else</span>
    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i:nodes[ptr].children)<span style="color:#75715e">//更新所有孩子的
</span><span style="color:#75715e"></span>            begin_end(i.second);
        nodes[ptr].ftree.push_back(nodes[ptr].nodeName);<span style="color:#75715e">//先放入自己
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i:nodes[ptr].children)<span style="color:#75715e">//前4个
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">if</span>(cnt<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">4</span>)
                <span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;t<span style="color:#f92672">&lt;</span>nodes[i.second].ftree.size();t<span style="color:#f92672">++</span>)
                <span style="color:#66d9ef">if</span>(cnt<span style="color:#f92672">++&lt;</span><span style="color:#ae81ff">4</span>)
                    nodes[ptr].ftree.push_back(nodes[i.second].ftree[t]);
                <span style="color:#66d9ef">else</span>
                    <span style="color:#66d9ef">break</span>;
        }
        cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span>(map<span style="color:#f92672">&lt;</span>string,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>reverse_iterator it<span style="color:#f92672">=</span>nodes[ptr].children.rbegin();it<span style="color:#f92672">!=</span>nodes[ptr].children.rend();it<span style="color:#f92672">++</span>)<span style="color:#75715e">//后5个
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">if</span>(cnt<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">5</span>)
                <span style="color:#66d9ef">break</span>;
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span>nodes[(<span style="color:#f92672">*</span>it).second].ftree.size()<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;t<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;t<span style="color:#f92672">--</span>)<span style="color:#75715e">//倒着的
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(cnt<span style="color:#f92672">++&lt;</span><span style="color:#ae81ff">5</span>)
                    nodes[ptr].ftree.insert(nodes[ptr].ftree.begin()<span style="color:#f92672">+</span><span style="color:#ae81ff">5</span>,nodes[(<span style="color:#f92672">*</span>it).second].ftree[t]);
                <span style="color:#66d9ef">else</span>
                    <span style="color:#66d9ef">break</span>;
        }
        nodes[ptr].change <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }
}


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">tree</span>()
{
    <span style="color:#66d9ef">int</span> childSize <span style="color:#f92672">=</span> nodes[curPosi].allNodes;
    <span style="color:#66d9ef">if</span>( childSize<span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> )
    {
        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;EMPTY</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        <span style="color:#66d9ef">return</span> ;
    } 
    begin_end(curPosi);
    <span style="color:#66d9ef">if</span>(childSize<span style="color:#f92672">&lt;=</span><span style="color:#ae81ff">10</span>)
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i:nodes[curPosi].ftree)
            cout<span style="color:#f92672">&lt;&lt;</span>i<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    <span style="color:#66d9ef">else</span> 
    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span>;i<span style="color:#f92672">++</span>)
            cout<span style="color:#f92672">&lt;&lt;</span>nodes[curPosi].ftree[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;<span style="color:#75715e">//输出... 仔细看提
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10</span>;i<span style="color:#f92672">++</span>)
            cout<span style="color:#f92672">&lt;&lt;</span>nodes[curPosi].ftree[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
    }   
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    treeNode rootNode (<span style="color:#e6db74">&#34;root&#34;</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);


    string curCmd;
    <span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    cin<span style="color:#f92672">&gt;&gt;</span>t;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>t;i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">int</span> q;
        nodes.clear();<span style="color:#75715e">//空间释放!!!!
</span><span style="color:#75715e"></span>        nodes.push_back(rootNode);
        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>history.empty())
            history.pop();
        curPosi <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        cin<span style="color:#f92672">&gt;&gt;</span>q;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>q;j<span style="color:#f92672">++</span>)
        {
            cin<span style="color:#f92672">&gt;&gt;</span>curCmd;
            <span style="color:#66d9ef">if</span>(curCmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;MKDIR&#34;</span>) mkdir();
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(curCmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;RM&#34;</span>) rm();
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(curCmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;CD&#34;</span>) cd();
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(curCmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;SZ&#34;</span>) sz();
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(curCmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;LS&#34;</span>) ls();
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(curCmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;TREE&#34;</span>) tree();
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(curCmd <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;UNDO&#34;</span>) undo();
        }
    }
}
</code></pre></div><h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>把本次模拟较为复杂,难点主要集中在tree的实现上,因为数据规模的原因直接进行前序遍历复杂度会超时,因此采取记忆化的操作,这样只在插入删除新的节点后才进行更新,其他情况直接使用存储的tree信息.</p>
<p>除此之外stl的map使用也值得一看,直接实现了有序的查找,复杂度还低</p>
<h2 id="b---东东学打牌httpsvjudgenetproblem计蒜客-41408"><a href="https://vjudge.net/problem/%E8%AE%A1%E8%92%9C%E5%AE%A2-41408">B - 东东学打牌</a><a hidden class="anchor" aria-hidden="true" href="#b---东东学打牌httpsvjudgenetproblem计蒜客-41408">#</a></h2>
<h3 id="题意-1">题意<a hidden class="anchor" aria-hidden="true" href="#题意-1">#</a></h3>
<p>和之前做过的那个发牌的题挺类似,使用类似搜索的方法</p>
<p><img src="https://i.loli.net/2020/05/04/mj8enzuLZFfSGKM.png" alt="image-20200504185524882"></p>
<h3 id="解法-1">解法<a hidden class="anchor" aria-hidden="true" href="#解法-1">#</a></h3>
<p>首先使用个结构体来handCard记录一个人的姓名和手牌,姓名使用string手牌使用vector,手牌转换为数字.使用一个handCard数组记录有所人的手牌.</p>
<p>然后开8个vector,分别表示8种情况下的人,然后写8个函数,分别判断一个人的手牌是哪一种情况,然后分配到对应的vector</p>
<p>针对这个8种情况编写几个排序函数,实现题目中要求的顺序,有几个排序方法使能复用的.</p>
<p>在8个判断函数中,使用map实现对同一数字手牌个数的判断.</p>
<h3 id="code-1">code<a hidden class="anchor" aria-hidden="true" href="#code-1">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;<span style="color:#75715e">//手牌和人名
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">handCard</span>
{
    string name;
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> cards;
};

handCard allCard[<span style="color:#ae81ff">1000</span>];<span style="color:#75715e">//所有人的情况
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> exchanges[<span style="color:#ae81ff">100</span>];<span style="color:#75715e">//将ascii码转换为对应的数字
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> longshun[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">11</span>,<span style="color:#ae81ff">12</span>,<span style="color:#ae81ff">13</span>};<span style="color:#75715e">//龙顺判断
</span><span style="color:#75715e">// priority_queue&lt;string,vector&lt;string&gt;,greater&lt;string&gt; &gt; ans[8];
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ans[<span style="color:#ae81ff">8</span>];<span style="color:#75715e">//8种类型
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getCardNum</span>(<span style="color:#66d9ef">int</span> ptr,<span style="color:#66d9ef">int</span> i)<span style="color:#75715e">//获取一张手牌
</span><span style="color:#75715e"></span>{<span style="color:#66d9ef">return</span> allCard[ptr].cards[i];}

map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> getCnt(<span style="color:#66d9ef">int</span> ptr)<span style="color:#75715e">//获得计数的字典
</span><span style="color:#75715e"></span>{
    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mp;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span>;i<span style="color:#f92672">++</span>)
        mp[allCard[ptr].cards[i]]<span style="color:#f92672">++</span>;
    <span style="color:#66d9ef">return</span> mp;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">distribute</span>(<span style="color:#66d9ef">int</span> ptr)<span style="color:#75715e">//判断一套牌属于哪一个类型
</span><span style="color:#75715e"></span>{
    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mp <span style="color:#f92672">=</span> getCnt(ptr);
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> ;
    {<span style="color:#75715e">//龙顺
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span>;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(allCard[ptr].cards[i]<span style="color:#f92672">!=</span>longshun[i])
                <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>)
        {
            ans[<span style="color:#ae81ff">7</span>].push_back(ptr);
            <span style="color:#66d9ef">return</span> ;
        }
    }
    {<span style="color:#75715e">//顺子
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>;i<span style="color:#f92672">++</span>)
            <span style="color:#66d9ef">if</span>(allCard[ptr].cards[i]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">!=</span>allCard[ptr].cards[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>])
                <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>)
        {
            ans[<span style="color:#ae81ff">6</span>].push_back(ptr);
            <span style="color:#66d9ef">return</span> ;
        }
    }
    {<span style="color:#75715e">//炸弹
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t:mp)
            <span style="color:#66d9ef">if</span>(t.second <span style="color:#f92672">==</span> <span style="color:#ae81ff">4</span>)
            {
                ans[<span style="color:#ae81ff">5</span>].push_back(ptr);
                <span style="color:#66d9ef">return</span>;
            }
    }
    {<span style="color:#75715e">//三带二
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t:mp)
            <span style="color:#66d9ef">if</span>(t.second<span style="color:#f92672">!=</span><span style="color:#ae81ff">3</span><span style="color:#f92672">&amp;&amp;</span>t.second<span style="color:#f92672">!=</span><span style="color:#ae81ff">2</span>)
            {
                flag <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
                <span style="color:#66d9ef">break</span>;
            }
        <span style="color:#66d9ef">if</span>(flag)
        {
            ans[<span style="color:#ae81ff">4</span>].push_back(ptr);
            <span style="color:#66d9ef">return</span>;
        }
    }
    {<span style="color:#75715e">//三个
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t:mp)
            <span style="color:#66d9ef">if</span>(t.second <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>)
            {
                ans[<span style="color:#ae81ff">3</span>].push_back(ptr);
                <span style="color:#66d9ef">return</span>;
            }
    }
    {<span style="color:#75715e">//两对
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> flag <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> ;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t:mp)
            <span style="color:#66d9ef">if</span>(t.second <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)
                flag<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">if</span>(flag <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)
        {
            ans[<span style="color:#ae81ff">2</span>].push_back(ptr);
            <span style="color:#66d9ef">return</span>;
        }
    }
    {<span style="color:#75715e">//对子
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t:mp)
            <span style="color:#66d9ef">if</span>(t.second <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)
            {
                ans[<span style="color:#ae81ff">1</span>].push_back(ptr);
                <span style="color:#66d9ef">return</span>;
            }
    }
    ans[<span style="color:#ae81ff">0</span>].push_back(ptr);<span style="color:#75715e">//大牌
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">nameOrder</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b)<span style="color:#75715e">//比较大牌,实际上就是名字的字典序
</span><span style="color:#75715e"></span>{<span style="color:#66d9ef">return</span> allCard[a].name<span style="color:#f92672">&gt;</span>allCard[b].name;}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">numOrder</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b)<span style="color:#75715e">//所有手牌和的大小,顺子比较直接使用,大数也直接使用
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> al<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,bl<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span>;i<span style="color:#f92672">++</span>)
        al<span style="color:#f92672">+=</span>allCard[a].cards[i],bl<span style="color:#f92672">+=</span>allCard[b].cards[i];
    <span style="color:#66d9ef">if</span>(al<span style="color:#f92672">&lt;</span>bl)
        <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (al<span style="color:#f92672">==</span>bl)
        <span style="color:#66d9ef">return</span> nameOrder(a,b);
    <span style="color:#66d9ef">return</span> false;
}
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp6</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b)<span style="color:#75715e">//炸弹
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">if</span>(getCardNum(a,<span style="color:#ae81ff">1</span>)<span style="color:#f92672">&lt;</span>getCardNum(b,<span style="color:#ae81ff">1</span>))<span style="color:#75715e">//炸弹大小
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(getCardNum(a,<span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> getCardNum(b,<span style="color:#ae81ff">1</span>))
        <span style="color:#66d9ef">return</span> numOrder(a,b);<span style="color:#75715e">//比较剩下的一张牌
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> false;
}
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp5</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b)<span style="color:#75715e">//三带二
</span><span style="color:#75715e"></span>{
    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mpa <span style="color:#f92672">=</span> getCnt(a);
    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mpb <span style="color:#f92672">=</span> getCnt(b);
    <span style="color:#66d9ef">int</span> al<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,bl<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t:mpa)
        <span style="color:#66d9ef">if</span>(t.second <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) al<span style="color:#f92672">=</span>t.first;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t:mpb)
        <span style="color:#66d9ef">if</span>(t.second <span style="color:#f92672">==</span> <span style="color:#ae81ff">3</span>) bl<span style="color:#f92672">=</span>t.first;
    <span style="color:#66d9ef">if</span>(al<span style="color:#f92672">&lt;</span>bl)<span style="color:#75715e">//比较三
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(al<span style="color:#f92672">==</span>bl)<span style="color:#75715e">//比较二
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> numOrder(a,b);
    <span style="color:#66d9ef">return</span> false;
}
<span style="color:#75715e">//三个和三带二一样
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp3</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b)<span style="color:#75715e">//两对
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> al[<span style="color:#ae81ff">2</span>];
    <span style="color:#66d9ef">int</span> bl[<span style="color:#ae81ff">2</span>];
    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mpa <span style="color:#f92672">=</span> getCnt(a);
    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mpb <span style="color:#f92672">=</span> getCnt(b);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t:mpa)
        <span style="color:#66d9ef">if</span>(t.second <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)<span style="color:#75715e">//两个对子
</span><span style="color:#75715e"></span>            al[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> t.first;
    i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t:mpb)
        <span style="color:#66d9ef">if</span>(t.second <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)
            bl[i<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> t.first;
    <span style="color:#66d9ef">if</span>(al[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">&lt;</span>bl[<span style="color:#ae81ff">1</span>]) <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(al[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">==</span>bl[<span style="color:#ae81ff">1</span>])
        <span style="color:#66d9ef">if</span>(al[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">&lt;</span>bl[<span style="color:#ae81ff">0</span>])
            <span style="color:#66d9ef">return</span> true;
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(al[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> bl[<span style="color:#ae81ff">0</span>])
            <span style="color:#66d9ef">return</span> numOrder(a,b);<span style="color:#75715e">//比较剩下的那一个数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">cmp2</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b)<span style="color:#75715e">//对子
</span><span style="color:#75715e"></span>{
    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mpa <span style="color:#f92672">=</span> getCnt(a);
    map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> mpb<span style="color:#f92672">=</span> getCnt(b);
    <span style="color:#66d9ef">int</span> al<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,bl<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t:mpa)
        <span style="color:#66d9ef">if</span>(t.second <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)   al <span style="color:#f92672">=</span>t.first;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> t:mpb)
        <span style="color:#66d9ef">if</span>(t.second <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)   bl<span style="color:#f92672">=</span>t.first;
    <span style="color:#66d9ef">if</span>(al<span style="color:#f92672">&lt;</span>bl) <span style="color:#75715e">//比较唯一的一个对子
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(al <span style="color:#f92672">==</span> bl)
        <span style="color:#66d9ef">return</span> numOrder(a,b);<span style="color:#75715e">//比较剩下的
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">output</span>()
{
    sort(ans[<span style="color:#ae81ff">0</span>].begin(),ans[<span style="color:#ae81ff">0</span>].end(),numOrder);<span style="color:#75715e">//排序
</span><span style="color:#75715e"></span>    sort(ans[<span style="color:#ae81ff">1</span>].begin(),ans[<span style="color:#ae81ff">1</span>].end(),cmp2);
    sort(ans[<span style="color:#ae81ff">2</span>].begin(),ans[<span style="color:#ae81ff">2</span>].end(),cmp3);
    sort(ans[<span style="color:#ae81ff">3</span>].begin(),ans[<span style="color:#ae81ff">3</span>].end(),cmp5);
    sort(ans[<span style="color:#ae81ff">4</span>].begin(),ans[<span style="color:#ae81ff">4</span>].end(),cmp5);
    sort(ans[<span style="color:#ae81ff">5</span>].begin(),ans[<span style="color:#ae81ff">5</span>].end(),cmp6);
    sort(ans[<span style="color:#ae81ff">6</span>].begin(),ans[<span style="color:#ae81ff">6</span>].end(),numOrder);
    sort(ans[<span style="color:#ae81ff">7</span>].begin(),ans[<span style="color:#ae81ff">7</span>].end(),nameOrder);
    <span style="color:#75715e">// sort(ans[0].begin(),ans[0].end(),);
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">7</span>;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>)<span style="color:#75715e">//输出结果
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>reverse_iterator it<span style="color:#f92672">=</span>ans[i].rbegin();it<span style="color:#f92672">!=</span>ans[i].rend();it<span style="color:#f92672">++</span>)
            cout<span style="color:#f92672">&lt;&lt;</span>allCard[<span style="color:#f92672">*</span>it].name<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">readInt</span>()<span style="color:#75715e">//读入一个ascii转换为int
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">char</span> temp;
    scanf(<span style="color:#e6db74">&#34;%c&#34;</span>,<span style="color:#f92672">&amp;</span>temp);
    <span style="color:#66d9ef">if</span>(temp <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;1&#39;</span>)
    {
        getchar();
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">10</span>;
    }
    <span style="color:#66d9ef">return</span> change[temp];
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    memset(change,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(change));
    <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">char</span> i<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;2&#39;</span>;i<span style="color:#f92672">&lt;=</span><span style="color:#e6db74">&#39;9&#39;</span>;i<span style="color:#f92672">++</span>,s<span style="color:#f92672">++</span>)
        change[i] <span style="color:#f92672">=</span> s;
    change[<span style="color:#e6db74">&#39;A&#39;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//初始化
</span><span style="color:#75715e"></span>    change[<span style="color:#e6db74">&#39;J&#39;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">11</span>;
    change[<span style="color:#e6db74">&#39;Q&#39;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">12</span>;
    change[<span style="color:#e6db74">&#39;K&#39;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">13</span>;
    
    <span style="color:#66d9ef">int</span> k;
    <span style="color:#66d9ef">while</span>(scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>k)<span style="color:#f92672">!=</span>EOF)
    {
        <span style="color:#75715e">// getchar();
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>k;i<span style="color:#f92672">++</span>)
            allCard[i].cards.clear();
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">8</span>;i<span style="color:#f92672">++</span>)
            ans[i].clear();
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>k;i<span style="color:#f92672">++</span>)
        {
            cin<span style="color:#f92672">&gt;&gt;</span>allCard[i].name;
            getchar();
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;t<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span>;t<span style="color:#f92672">++</span>)
                allCard[i].cards.push_back(readInt());
            sort(allCard[i].cards.begin(),allCard[i].cards.end());<span style="color:#75715e">//将每张手牌排序
</span><span style="color:#75715e"></span>        }    
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>k;i<span style="color:#f92672">++</span>)
            distribute(i);<span style="color:#75715e">//把每个人手牌的类型分类
</span><span style="color:#75715e"></span>        output();<span style="color:#75715e">//输出
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h3>
<p>这道题不是很难,主要是就是考虑题目中给出的几个情况的判断,判断同一个大小的牌数是一个比较麻烦的部分,使用map复杂度能低一些.另一个重要的地方是函数结构的设计,尽量提高的代码的复用率</p>
<h2 id="c---签到题独立思考哈httpsvjudgenetproblemcodeforces-1042a"><a href="https://vjudge.net/problem/CodeForces-1042A">C - 签到题，独立思考哈</a><a hidden class="anchor" aria-hidden="true" href="#c---签到题独立思考哈httpsvjudgenetproblemcodeforces-1042a">#</a></h2>
<h3 id="题面-1">题面<a hidden class="anchor" aria-hidden="true" href="#题面-1">#</a></h3>
<p><img src="https://i.loli.net/2020/05/04/MhjWDYoq5uE6TXR.png" alt=""></p>
<p>这个题实际上就是一个分配的问题,如何分配使所有单位的最大值最大或者最小</p>
<h3 id="解法-2">解法<a hidden class="anchor" aria-hidden="true" href="#解法-2">#</a></h3>
<p>首先最大值最小首先采取的方法就是平均值,一平均就是最小的,但是因为已经分配好的不能再懂了,如果现在的最大值比平均后的值大,说明加入y之后最小的最大值还是原来的最大值,如果最大值小于平均值,那么平均值就是最小最大值</p>
<p>最大最大值就很简单了,直接在现在最大值的基础上加上y就行了</p>
<h3 id="code-2">code<a hidden class="anchor" aria-hidden="true" href="#code-2">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> data[<span style="color:#ae81ff">105</span>];

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    memset(data,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(data));
    <span style="color:#66d9ef">int</span> x,y;
    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>x,<span style="color:#f92672">&amp;</span>y);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>x;i<span style="color:#f92672">++</span>)
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,data<span style="color:#f92672">+</span>i);
    <span style="color:#66d9ef">int</span> sum<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//当前的总计,用于求平均数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> Max<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//当前的最大值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>x;i<span style="color:#f92672">++</span>)
    {
        sum<span style="color:#f92672">+=</span>data[i];<span style="color:#75715e">//统计
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(data[i]<span style="color:#f92672">&gt;</span>Max) Max <span style="color:#f92672">=</span> data[i];<span style="color:#75715e">//最大值
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">int</span> mn <span style="color:#f92672">=</span> ceil((sum<span style="color:#f92672">+</span>y)<span style="color:#f92672">/</span>(x<span style="color:#f92672">*</span><span style="color:#ae81ff">1.0</span>));<span style="color:#75715e">//加上y的平均数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(mn<span style="color:#f92672">&lt;</span>Max)<span style="color:#75715e">//当前最大值大于平均数
</span><span style="color:#75715e"></span>        mn <span style="color:#f92672">=</span> Max;<span style="color:#75715e">//取当前最大值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> mx <span style="color:#f92672">=</span> Max<span style="color:#f92672">+</span>y;<span style="color:#75715e">///最大的最大值
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d %d&#34;</span>,mn,mx); 
}
</code></pre></div><h3 id="总结-2">总结<a hidden class="anchor" aria-hidden="true" href="#总结-2">#</a></h3>
<p>这道题不难,主要是就把最小的最大值情况想全了就行</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://example.org/tags/program/">Program</a></li>
      <li><a href="http://example.org/tags/homework/">homework</a></li>
    </ul>
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="http://example.org/">My New Hugo Site</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
