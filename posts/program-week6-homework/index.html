<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Program-week6-homework | My New Hugo Site</title>

<meta name="keywords" content="Program, homework" />
<meta name="description" content="week6-csp A - 掌握魔法の东东 II 题意 给定一组扑克牌,每张牌拥有两个属性,花色和大小,不存在完全相同的两张牌.首先取两张,了解其花色和大小,然后再取三张牌,问问总共的5张牌,在9种情况中各有多少
解法 这道题有两种解法,一种思路是搜索,用DFS搜索一遍,每次在5张牌时判断目前的五张牌是什么情况,对应的情况计数增加.第二种解法是直接用排列组合的方式直接计算出每种情况的个数.
这道题我是用第二种方法做的,首先写一个用于计算组合数的函数,用它来计算组合数.设牌的大小是1-n,花色有m种
 首先判断两张牌花色相同且相差不大于4,然后找到上下界,在上下界中找出大小为5的窗口有几个就行了 和上一个差不多,但是不判断花色了,然后后摸的三张牌颜色要进行组合最后要减去1的数量 判断两张牌的花色是否相同,相同的话,直接$C_{n-2}^3$就行了,最后减1中的 首先判断总的花色数,必须等于4,判断两张牌大小是否相等,相等的话只有一张牌是自由的,那么一共有(n-1)*m种可能,否则没有牌是自由的,只有两种可能 首先判断m是不是大于等于3,然后分成两类,一类是先摸的两张牌大小相同,这种情况下在分为先摸的牌为2和先摸的牌为3再次讨论,如果两张牌(A,B)大小不同则按A为2,B为3和A为3,B为2讨论,这两种情况是一样的,直接*2就行 这个也是先判断花色总数,然后分为先摸牌相等和不等两种情况,第二种情况下还要判断先摸的两张牌都是对,还是一个是1一个是对 注意这里的3张大小相同要求剩下的两张必须不同.同样先判断花色总数,之后分为先摸牌相等和不等讨论.在进一步的讨论中,还要分出3,1,1具体对应的是哪个 同样,2张相同的,3张不同的.剩下的方法也是相似的,看花色总数,分成先摸牌相等和不等讨论,进一步的讨论中分清楚2,1,1,1分别是那个 计算出总的情况数,减去上面的就行了  这种方法实在是太麻烦了,搜索的方法会简单很多,因为判断条件要比排列组合好写太多
code #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std; int ans[10];//1 start int A,B;//A是牌的总大小,B是牌的花色数 pair&lt;int,int&gt; curCard[2];//记录先摸的两张牌 int comb(int a,int b)//计算组合数 { int answer = 1; for(int i=0;i&lt;b;i&#43;&#43;) answer*=(a-i); for(int i=0;i&lt;b;i&#43;&#43;) answer/=(i&#43;1); if(answer&lt;0) return 0; return answer; } void con1() { if(curCard[0].second!=curCard[1].second||abs(curCard[0].first-curCard[1].first)&gt;4) return ; int max = curCard[0].first&gt;curCard[1].first?curCard[0].first:curCard[1].first;//取出两张牌中大的和小的  int min = curCard[0].">
<meta name="author" content="">
<link rel="canonical" href="http://example.org/posts/program-week6-homework/" />
<link href="/assets/css/stylesheet.min.5c4f6d85b7abfcfea458637c672d16a7a9c38c37f002753cfdc7f314b6d3c8f2.css" integrity="sha256-XE9thber/P6kWGN8Zy0Wp6nDjDfwAnU8/cfzFLbTyPI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="http://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="http://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />


<meta property="og:title" content="Program-week6-homework" />
<meta property="og:description" content="week6-csp A - 掌握魔法の东东 II 题意 给定一组扑克牌,每张牌拥有两个属性,花色和大小,不存在完全相同的两张牌.首先取两张,了解其花色和大小,然后再取三张牌,问问总共的5张牌,在9种情况中各有多少
解法 这道题有两种解法,一种思路是搜索,用DFS搜索一遍,每次在5张牌时判断目前的五张牌是什么情况,对应的情况计数增加.第二种解法是直接用排列组合的方式直接计算出每种情况的个数.
这道题我是用第二种方法做的,首先写一个用于计算组合数的函数,用它来计算组合数.设牌的大小是1-n,花色有m种
 首先判断两张牌花色相同且相差不大于4,然后找到上下界,在上下界中找出大小为5的窗口有几个就行了 和上一个差不多,但是不判断花色了,然后后摸的三张牌颜色要进行组合最后要减去1的数量 判断两张牌的花色是否相同,相同的话,直接$C_{n-2}^3$就行了,最后减1中的 首先判断总的花色数,必须等于4,判断两张牌大小是否相等,相等的话只有一张牌是自由的,那么一共有(n-1)*m种可能,否则没有牌是自由的,只有两种可能 首先判断m是不是大于等于3,然后分成两类,一类是先摸的两张牌大小相同,这种情况下在分为先摸的牌为2和先摸的牌为3再次讨论,如果两张牌(A,B)大小不同则按A为2,B为3和A为3,B为2讨论,这两种情况是一样的,直接*2就行 这个也是先判断花色总数,然后分为先摸牌相等和不等两种情况,第二种情况下还要判断先摸的两张牌都是对,还是一个是1一个是对 注意这里的3张大小相同要求剩下的两张必须不同.同样先判断花色总数,之后分为先摸牌相等和不等讨论.在进一步的讨论中,还要分出3,1,1具体对应的是哪个 同样,2张相同的,3张不同的.剩下的方法也是相似的,看花色总数,分成先摸牌相等和不等讨论,进一步的讨论中分清楚2,1,1,1分别是那个 计算出总的情况数,减去上面的就行了  这种方法实在是太麻烦了,搜索的方法会简单很多,因为判断条件要比排列组合好写太多
code #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std; int ans[10];//1 start int A,B;//A是牌的总大小,B是牌的花色数 pair&lt;int,int&gt; curCard[2];//记录先摸的两张牌 int comb(int a,int b)//计算组合数 { int answer = 1; for(int i=0;i&lt;b;i&#43;&#43;) answer*=(a-i); for(int i=0;i&lt;b;i&#43;&#43;) answer/=(i&#43;1); if(answer&lt;0) return 0; return answer; } void con1() { if(curCard[0].second!=curCard[1].second||abs(curCard[0].first-curCard[1].first)&gt;4) return ; int max = curCard[0].first&gt;curCard[1].first?curCard[0].first:curCard[1].first;//取出两张牌中大的和小的  int min = curCard[0]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/program-week6-homework/" />
<meta property="article:published_time" content="2020-03-28T22:38:31+00:00" />
<meta property="article:modified_time" content="2020-03-28T22:38:31+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Program-week6-homework"/>
<meta name="twitter:description" content="week6-csp A - 掌握魔法の东东 II 题意 给定一组扑克牌,每张牌拥有两个属性,花色和大小,不存在完全相同的两张牌.首先取两张,了解其花色和大小,然后再取三张牌,问问总共的5张牌,在9种情况中各有多少
解法 这道题有两种解法,一种思路是搜索,用DFS搜索一遍,每次在5张牌时判断目前的五张牌是什么情况,对应的情况计数增加.第二种解法是直接用排列组合的方式直接计算出每种情况的个数.
这道题我是用第二种方法做的,首先写一个用于计算组合数的函数,用它来计算组合数.设牌的大小是1-n,花色有m种
 首先判断两张牌花色相同且相差不大于4,然后找到上下界,在上下界中找出大小为5的窗口有几个就行了 和上一个差不多,但是不判断花色了,然后后摸的三张牌颜色要进行组合最后要减去1的数量 判断两张牌的花色是否相同,相同的话,直接$C_{n-2}^3$就行了,最后减1中的 首先判断总的花色数,必须等于4,判断两张牌大小是否相等,相等的话只有一张牌是自由的,那么一共有(n-1)*m种可能,否则没有牌是自由的,只有两种可能 首先判断m是不是大于等于3,然后分成两类,一类是先摸的两张牌大小相同,这种情况下在分为先摸的牌为2和先摸的牌为3再次讨论,如果两张牌(A,B)大小不同则按A为2,B为3和A为3,B为2讨论,这两种情况是一样的,直接*2就行 这个也是先判断花色总数,然后分为先摸牌相等和不等两种情况,第二种情况下还要判断先摸的两张牌都是对,还是一个是1一个是对 注意这里的3张大小相同要求剩下的两张必须不同.同样先判断花色总数,之后分为先摸牌相等和不等讨论.在进一步的讨论中,还要分出3,1,1具体对应的是哪个 同样,2张相同的,3张不同的.剩下的方法也是相似的,看花色总数,分成先摸牌相等和不等讨论,进一步的讨论中分清楚2,1,1,1分别是那个 计算出总的情况数,减去上面的就行了  这种方法实在是太麻烦了,搜索的方法会简单很多,因为判断条件要比排列组合好写太多
code #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;iostream&gt;using namespace std; int ans[10];//1 start int A,B;//A是牌的总大小,B是牌的花色数 pair&lt;int,int&gt; curCard[2];//记录先摸的两张牌 int comb(int a,int b)//计算组合数 { int answer = 1; for(int i=0;i&lt;b;i&#43;&#43;) answer*=(a-i); for(int i=0;i&lt;b;i&#43;&#43;) answer/=(i&#43;1); if(answer&lt;0) return 0; return answer; } void con1() { if(curCard[0].second!=curCard[1].second||abs(curCard[0].first-curCard[1].first)&gt;4) return ; int max = curCard[0].first&gt;curCard[1].first?curCard[0].first:curCard[1].first;//取出两张牌中大的和小的  int min = curCard[0]."/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Program-week6-homework",
  "name": "Program-week6-homework",
  "description": "week6-csp A - 掌握魔法の东东 II 题意 给定一组扑克牌,每张牌拥有两个属性,花色和大小,不存在完全相同的两张牌.首先取两张,了解其花色和大小,然后再取三张牌,问问总共的5张牌,在9种情况中各有多少\n解法 这道题有两种解法,一种思路是搜索,用DFS搜索一遍,每次在5张牌时判断目前的五张牌是什么情况,对应的情况计数增加.第二种解法是直接用排列组合 …",
  "keywords": [
    "Program", "homework"
  ],
  "articleBody": "week6-csp A - 掌握魔法の东东 II 题意 给定一组扑克牌,每张牌拥有两个属性,花色和大小,不存在完全相同的两张牌.首先取两张,了解其花色和大小,然后再取三张牌,问问总共的5张牌,在9种情况中各有多少\n解法 这道题有两种解法,一种思路是搜索,用DFS搜索一遍,每次在5张牌时判断目前的五张牌是什么情况,对应的情况计数增加.第二种解法是直接用排列组合的方式直接计算出每种情况的个数.\n这道题我是用第二种方法做的,首先写一个用于计算组合数的函数,用它来计算组合数.设牌的大小是1-n,花色有m种\n 首先判断两张牌花色相同且相差不大于4,然后找到上下界,在上下界中找出大小为5的窗口有几个就行了 和上一个差不多,但是不判断花色了,然后后摸的三张牌颜色要进行组合最后要减去1的数量 判断两张牌的花色是否相同,相同的话,直接$C_{n-2}^3$就行了,最后减1中的 首先判断总的花色数,必须等于4,判断两张牌大小是否相等,相等的话只有一张牌是自由的,那么一共有(n-1)*m种可能,否则没有牌是自由的,只有两种可能 首先判断m是不是大于等于3,然后分成两类,一类是先摸的两张牌大小相同,这种情况下在分为先摸的牌为2和先摸的牌为3再次讨论,如果两张牌(A,B)大小不同则按A为2,B为3和A为3,B为2讨论,这两种情况是一样的,直接*2就行 这个也是先判断花色总数,然后分为先摸牌相等和不等两种情况,第二种情况下还要判断先摸的两张牌都是对,还是一个是1一个是对 注意这里的3张大小相同要求剩下的两张必须不同.同样先判断花色总数,之后分为先摸牌相等和不等讨论.在进一步的讨论中,还要分出3,1,1具体对应的是哪个 同样,2张相同的,3张不同的.剩下的方法也是相似的,看花色总数,分成先摸牌相等和不等讨论,进一步的讨论中分清楚2,1,1,1分别是那个 计算出总的情况数,减去上面的就行了  这种方法实在是太麻烦了,搜索的方法会简单很多,因为判断条件要比排列组合好写太多\ncode #include #include #include #include using namespace std; int ans[10];//1 start int A,B;//A是牌的总大小,B是牌的花色数 pairint,int curCard[2];//记录先摸的两张牌 int comb(int a,int b)//计算组合数 { int answer = 1; for(int i=0;ib;i++) answer*=(a-i); for(int i=0;ib;i++) answer/=(i+1); if(answer0) return 0; return answer; } void con1() { if(curCard[0].second!=curCard[1].second||abs(curCard[0].first-curCard[1].first)4) return ; int max = curCard[0].firstcurCard[1].first?curCard[0].first:curCard[1].first;//取出两张牌中大的和小的  int min = curCard[0].firstcurCard[1].first?curCard[0].first:curCard[1].first; int up = min+4A-1?A-1:min+4;//上界  int down = max-40?0:max-4;//下界  ans[1] = up-down+1-5+1;//窗口的个数 } void con2() { if(curCard[0].first==curCard[1].first||abs(curCard[0].first-curCard[1].first)4)//不需要花色了,但是前两张牌大小不能相同  return; int max = curCard[0].firstcurCard[1].first?curCard[0].first:curCard[1].first; int min = curCard[0].firstcurCard[1].first?curCard[0].first:curCard[1].first; int up = min+4A-1?A-1:min+4; int down = max-40?0:max-4; ans[2] = (up-down+1-5+1)*B*B*B - ans[1];//容斥要求减掉共同部分 } void con3() { if(curCard[0].second!=curCard[1].second)//不同花色直接退出  return; ans[3] = comb(A-2,3)-ans[1];//要求花色相同,但是大小无限制 } void con4() { if(B4) { ans[4] = 0; return; } if(curCard[0].first==curCard[1].first) ans[4] =(A-1)*B;//后选的牌有两张和先摸的相同,剩下的一张随便  else ans[4] = 2;//只能于先摸的其中一张相同 } void con5() { if(B3) { ans[5] =0; return; } if(curCard[0].first==curCard[1].first) { ans[5]+= comb(B,2)*(A-1)*comb(B-2,1);//先摸的为3张,后摸的为2张  if(B==3)//后面抽的为3,前面为2,对于3种花色  ans[5]+=(A-1); if(B==4)//4种花色  ans[5]+=(A-1)*4; } else//抽到的牌不同  { if(B==3) ans[5]+=2*2*1;//2选1  if(B==4) ans[5]+=2*3*3;//3选2.3选1  } } void con6() { if(B2) { ans[6] = 0; return ; } if(curCard[0].first==curCard[1].first) { ans[6]+=comb(A-1,2)*B*comb(B,2)*2;//先摸的两两张必然是对,剩下的3张中出一个对  } else { ans[6]+=comb(A-2,1)*comb(B-1,1)*comb(B-1,1)*B+2*comb(A-2,1)*comb(B,2)*(B-1);//对子都在先抽的中,或者先抽的中只有一个对  } } void con7() { if(B3) { ans[7] = 0; return; } if(curCard[0].first==curCard[1].first) { ans[7]+=comb(A-1,2)*comb(B-2,1)*B*B;//只能是先摸的两张是3张  } else { ans[7]+=comb(A-2,1)*B*comb(B-1,2)*2+comb(A-2,1)*comb(B,3);//先摸的有一个是3张的,或者都不是  } } void con8() { if(B2) { ans[8] =0 ; return ; } if(curCard[0].first==curCard[1].first) { ans[8]+= comb(A-1,3)*B*B*B;//后抽的三张随便了  } else { ans[8]+= comb(A-2,2)*B*B*comb(B-1,1)*2+comb(A-2,2)*B*comb(B,2)*2;//先抽的两张中有一个是2,或者都不是2  } } void con9() { int all = comb(A*B-2,3)//总的情况数  for(int i=1;i9;i++) all -= ans[i];//去掉其他的  ans[9]= all; } int main() { memset(ans,0,sizeof(ans)); scanf(\"%d%d\",\u0026A,\u0026B); for(int i=0;i2;i++) scanf(\"%d%d\",\u0026curCard[i].first,\u0026curCard[i].second); con1(); con2(); con3(); con4(); con5(); con6(); con7(); con8(); con9(); for(int i=0;i9;i++) coutans[i+1]\" \"; return 0; } 总结 高中做题做习惯了,一看见这种形式就直接用排列组合了,但是在CPU中遍历方便的多,而且数据规模很小,不如直接遍历.直接遍历还不会出现排列组合没考虑全的情况,这道题写的有点麻烦了.\nweek6-homework A - 氪金带东 题意 本题的意思是求取一个数中任意一个点到离它最远的点的距离\nPS: 我觉得题中的说法稍微有点问题,应该指明没有回路,有回路的话一直绕圈不会有最长的路径,我做的时候是把这个图当成一个树来解决的.\n解法 首先我们有求取树的直径的方法,就是首先从任意一个点出发,用BFS,DFS(必须遍历一边,类似Dij的贪心算法是不行的,因为局部最优不等于全局最优)找到距离该点最远的一个点A,然后从A开始找到离A最远的点B,A,B之间的距离就是树的直径,这个可以用反正法进行证明.\n我们要做的是在这个基础上进行一些改动,从A到B的遍历中,记录每一个点距离A的最远距离,在从B开始一次遍历,记录其他点到B的最远距离,然后最远的距离是A,B中最远的哪一个.\ncode #include #include #include #include #include using namespace std; int one[10002];//记录到A的距离 int two[10002];//记录到B的距离 bool vis[10002];//记录访问情况 vectorpairint,int  G[10002];//邻接链表存储树  pairint,int A;//第一个是编号,第二个是最长距离 pairint,int B; void bfsFind()//第一次找到A { memset(vis,0,sizeof(vis));//务必初始化  queuepairint,int  q;//第一个是编号,第二个是最长距离  q.push(make_pair(0,0)); vis[0] = true; pairint,int maxPair(0,0); while(!q.empty())//BFS实现  { pairint,int temp = q.front(); q.pop(); if(temp.secondmaxPair.second)//最远的点  maxPair = {temp.first,temp.second}; for(auto i:G[temp.first]) { if(vis[i.first]==false) { vis[i.first] = true; q.push(make_pair(i.first,i.second+temp.second)); } } } A = {maxPair.first,0}; } void BFS1()//从A找到B { memset(vis,0,sizeof(vis));//初始化  queuepairint,int  q;//第一个是编号,第二个是最长距离  q.push(A); vis[A.first] = true; pairint,int maxPair(A.first,0); while(!q.empty()) { pairint,int temp = q.front(); q.pop(); if(temp.secondmaxPair.second) maxPair = {temp.first,temp.second}; one[temp.first] = temp.second;//每个点之访问一遍,这一边就是最远距离  for(auto i:G[temp.first]) { if(vis[i.first]==false) { vis[i.first] = true; q.push(make_pair(i.first,i.second+temp.second)); } } } B = {maxPair.first,0}; } void BFS2() { memset(vis,0,sizeof(vis));//初始化  queuepairint,int q;//第一个是编号,第二个是最长距离  q.push(make_pair(B.first,0)); vis[B.first] = true; while(!q.empty()) { pairint,int temp = q.front(); q.pop(); two[temp.first] = temp.second; for(auto i:G[temp.first]) { if(vis[i.first]==false) { vis[i.first] = true; q.push(make_pair(i.first,i.second+temp.second)); } } } } int main() { int n; while(scanf(\"%d\",\u0026n)!=EOF) { memset(one,0,sizeof(one)); memset(two,0,sizeof(two)); int point,weight; for(int i=1;in;i++) { scanf(\"%d%d\",\u0026point,\u0026weight); G[i].push_back(make_pair(point-1,weight)); G[point-1].push_back(make_pair(i,weight)); } bfsFind();//3遍BFS  BFS1(); BFS2(); for(int i=0;in;i++) printf(\"%d\\n\",one[i]two[i]?one[i]:two[i]);//选出最远的  for(int i=0;in;i++) G[i].clear(); } } 总结 这个题的实现方式上也有点意思,首先虽然是一个树,但是还是按照图存储的,访问的时候是记录vis,确保是一个连通无回路的树,相当于我们能把任意一个节点当成根节点,遍历整个树,纯的树一般是一种有向图,因此不能从任意一个点出发访问.\n一个连通图BFS一遍或者DFS一遍必定得到一个生成树.\nB - 戴好口罩！ 题意 给定n个数,然后给定m个集合,集合中的数字属于一个等价类,问和0同处一个等价类的元素有多少个\n解法 这道题直接用并查集解决就可以,同一个集合的是一类,不断合并,最终求出0号所在的集合,然后统计出属于整个集合的元素的个数\ncode #include #include #include #include #include using namespace std; int same[30002];//并查集所用的数组 int find(int i)//查询 { if(i!=same[i]) return same[i] = find(same[i]);//路径压缩  return i; } bool uni(int i,int j)//合并 { if(find(i) == find(j)) return false; same[find(j)] = find(i); return true; } int main() { int m,n; while(scanf(\"%d%d\",\u0026n,\u0026m)) { if(m==0\u0026\u0026n==0) return 0; for(int i=0;in;i++)//初始化  same[i] = i; for(int i=0;im;i++) { int num; scanf(\"%d\",\u0026num); int pre,temp; if(num0) scanf(\"%d\",\u0026pre); for(int t=1;tnum;t++) { scanf(\"%d\",\u0026temp); uni(pre,temp);//集合中合并  pre = temp; } } int count=0;//same中和0号同一个元素的个数  int tar = find(0);//0号所在的集合  for(int i=0;in;i++)//遍历一遍same  if(find(i) == tar) count++;//总数增加  printf(\"%d\\n\",count); } } 总结 并查集实现要加上路径压缩.\nC - 掌握魔法の东东 I 题意 现在有一个图,途中有n个点,现在让n个点上要有水,水可以是通过其他节点送得,需要边权的耗费,也可以是直接获得,需要$W_i$的耗费(题中给出),问最小耗费是多少\n解法 这道题需要抽象一下,首先直接获得或者其他节点送的都是要耗费,因此二者是等价的,我们开一个节点代表水,把每个点都和水连接,边权就是$W_i$,题意想要的就是每个点都与水联通,这个就是生成树的问题了,直接用最小生成树就行了\ncode #include #include #include #include #include using namespace std; //kruskal实现最小生成树 struct edge//边权 { int s; int e; int w; bool operator  (const edge \u0026 op) const {return wop.w;} }; vectorpairint,int  G[302];//图 int w[302];//水与每个点的权重  int same[302];//并查集 int find(int i) { if(i!=same[i]) return same[i] = find(same[i]); return i; } bool uni(int i,int j) { if(find(i) == find(j)) return false; same[find(j)] = find(i); return true; } int main() { int n; int temp; scanf(\"%d\",\u0026n); for(int i=0;in;i++) scanf(\"%d\",w+i); for(int i=0;in+1;i++)//初始化并查集  same[i] = i; for(int i=0;in;i++) { G[n].push_back(make_pair(i,w[i]));//第n个节点当作水,连接起来  G[i].push_back(make_pair(n,w[i])); // std::cout  } for(int i=0;in;i++)//构建图  for(int j=0;jn;j++) { scanf(\"%d\",\u0026temp); if(temp == 0) continue; G[i].push_back(make_pair(j,temp)); G[j].push_back(make_pair(i,temp)); } vectoredge e;//图的边  for(int i=0;in+1;i++) for(auto j : G[i]) e.push_back({i,j.first,j.second}); sort(e.begin(),e.end());//排序  int count=0;//边权  for(auto i:e) { // cout if(uni(i.s,i.e))//不是一类就能合并  count += i.w; } printf(\"%d\\n\",count); } 总结 这道题不难写但是比较难想,首先得把水和节点直接的路统一起来,然后直到每一个点都能连接到一个点最小权值的情况就是最小生成树.\nD - 数据中心 题意 图中有一个root节点,所有点都要到这个点,这样就能构成一个生成树,求取生成树中边权最大的边的最小值\n解法 二分: 从0和最大边权中开始二分,然后找到一条小于等于那个权值的边,把边连接的两个点加入队列开始BFS,看看能不能构成生成树\n最小瓶颈生成树: 最小生成树一定是最小瓶颈生成树,求个最小生成树,然后找出最大边\n简易证明(反证)\n设最小生成树中最大边A,B的权值为W,最小瓶颈生成树的最大边权值是K,设K那么我们完全可以将A,B拆分开,将B按照最小瓶颈生成树中的边连接,改造后的最小生成树总权值会变小,因此不对,所以最小生成树是最小瓶颈生成树.\ncode #include #include #include #include #include using namespace std; //只有边集,没有存完整的图结构 struct edge//边 { int s; int e; int weight; bool operator  (const edge \u0026 op) const{ return weightop.weight; } }; vectoredge G;//图 vectoredge ans;//生成树 int same[50002];//并查集 int find (int i) { if(same[i]!=i) return same[i] = find(same[i]);; return i; } bool uni(int i,int j) { if(find(i) == find (j)) return false; same[find(j)] = find(i); return true; } int main() { int m,n,root; scanf(\"%d%d%d\",\u0026m,\u0026n,\u0026root); int a,c,b; for(int i=0;im;i++) same[i] = i; for(int i=0;in;i++) { scanf(\"%d%d%d\",\u0026a,\u0026b,\u0026c);//只有边  G.push_back({a,b,c}); } sort(G.begin(),G.end());//排序  int len =0 ; for(auto i:G)//最小生成树  { if(uni(i.s,i.e)) ans.push_back(i); } sort(ans.begin(),ans.end(),[](edge\u0026 a,edge\u0026 b){return a.weightb.weight;});//输出最大值  printf(\"%d\",ans[0].weight); } 总结 最小生成树就是最小瓶颈生成树\n证明还是反证法居多.\nCSP模拟题 201512-3 画图 题意 这是一道较为基础的模拟题.\n现在给出一个m*n的图像,要求按照给定的规则画图\n初始化图像所有的点为'.'\n1.画线,可以画水平方向是或者竖直方向上的直线,会给出直线的起始坐标和坐标.横线为'-',竖线为'|‘当横线和竖线相交时,交点为’+'.\n2.填充.使用给定的字符填充这副图像.填充规则为,给定一个点的坐标,以这个点开始在上下左右4个方向上填充,直到遇到直线或者图像边界\n现在给出一个操作序列,要求按照顺序输出最终渲染的图像\n解法 设计4个函数,分别是画直线,填充,判断能不能填充和输出\n使用char data [][]来记录图像中的信息,但是输出时的坐标系和题目要求中的方向在y方向是反的,因此使用output反向输出,这样其他函数中可以把data[0][0]作为(0,0)使用\n画线分为横线和竖线两种情况,使用一个数组vis[][]来记录画过的点,画的竖线,vis设为1横线设为2,在画线的过程中遇到横线竖线相交的情况时,将data置为'+',vis置为3,之后这个点不会再发生改变\n填充操作使用BFS,开一个tempVis[][]记录访问过的点,队列中的每一个元素都改变data,然后在4个方向上使用check判断能不放入是否被访问过,满足条件加入队列,同时标记tempVis\ncheck函数判断一个点是否超出了边界或者已经有了直线,上述两种情况返回false,否则返回true\ncode #include #include #include #include using namespace std; int vis[102][102];//记录直线 bool tempVis[102][102];//BFS int m,n,q; char data[102][102];//图像 int dirX[4] ={0,0,-1,1};//4个方向 int dirY[4] ={1,-1,0,0}; void drwaLine(int x1,int y1,int x2,int y2) { if(x1 == x2)//竖线  { int high = max(y1,y2); int low = min(y1,y2); for(int i=low;ihigh;i++) { if(vis[x1][i] == 0)//没有直线  { data[x1][i] = '|'; vis[x1][i] = 1; } else if(vis[x1][i] == 2)//已经有横线  { data[x1][i] = '+'; vis[x1][i] = 3; } } } else//横线  { int high = max(x1,x2); int low = min(x1,x2); for(int i=low;ihigh;i++) { if(vis[i][y1] == 0)//没有直线  { data[i][y1] = '-'; vis[i][y1] = 2; } else if(vis[i][y1] == 1)//有了竖线  { data[i][y1] = '+'; vis[i][y1] = 3; } } } } bool check(int x,int y) { if(x0||y0||xm-1||yn-1)//边界  return false; if(vis[x][y] != 0)//直线  return false; return true; } void fillContent(int x,int y,char c) { memset(tempVis,0,sizeof(tempVis)); queuepairint,int  q; tempVis[x][y]=true; if (check(x,y)) q.push(make_pair(x,y)); while(!q.empty()) { pairint,int cur = q.front(); q.pop(); data[cur.first][cur.second] = c; for(int i=0;i4;i++) if(check(cur.first+dirX[i],cur.second+dirY[i])\u0026\u0026tempVis[cur.first+dirX[i] ][cur.second+dirY[i] ] == false)//可以放入  { q.push(make_pair(cur.first+dirX[i],cur.second+dirY[i])); tempVis[cur.first+dirX[i] ][cur.second+dirY[i] ] = true; } } } void output()//输出 { for(int i=n-1;i=0;i--)//y轴上反着  { for(int j=0;jm;j++) printf(\"%c\",data[j][i]); printf(\"\\n\"); } } int main() { memset(vis,0,sizeof(vis)); memset(tempVis,0,sizeof(tempVis)); memset(data,'.',sizeof(data));//初始化为'.'  scanf(\"%d%d%d\",\u0026m,\u0026n,\u0026q); int temp; for(int i=0;iq;i++) { scanf(\"%d\",\u0026temp); if(temp == 0) { int x1,y1,x2,y2; scanf(\"%d%d%d%d\",\u0026x1,\u0026y1,\u0026x2,\u0026y2); drwaLine(x1,y1,x2,y2); } else { int x,y; char c; scanf(\"%d%d %c\",\u0026x,\u0026y,\u0026c); fillContent(x,y,c); } } output(); return 0; } 总结 这道题交了3次,第一次BFS写的稍微有点问题,第二次没有考虑到在一个地方上多次画一种线的情况,我把多次画一种线也整成了'+'.\nCSP的模拟题看起来不是很难,但是拿全分数还是比较难,得多考虑几种情况.\n",
  "wordCount" : "1041",
  "inLanguage": "en",
  "datePublished": "2020-03-28T22:38:31Z",
  "dateModified": "2020-03-28T22:38:31Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://example.org/posts/program-week6-homework/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "http://example.org/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()"></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Program-week6-homework
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">March 28, 2020

    </div>
  </header> 

  <div class="post-content">
<h1 id="week6-csp">week6-csp<a hidden class="anchor" aria-hidden="true" href="#week6-csp">#</a></h1>
<h2 id="a---掌握魔法の东东-ii">A - 掌握魔法の东东 II<a hidden class="anchor" aria-hidden="true" href="#a---掌握魔法の东东-ii">#</a></h2>
<h3 id="题意">题意<a hidden class="anchor" aria-hidden="true" href="#题意">#</a></h3>
<p>给定一组扑克牌,每张牌拥有两个属性,花色和大小,不存在完全相同的两张牌.首先取两张,了解其花色和大小,然后再取三张牌,问问总共的5张牌,在9种情况中各有多少</p>
<p><img src="https://i.loli.net/2020/03/28/tdnqbSlCupaZhXr.png" alt=""></p>
<!-- raw HTML omitted -->
<h3 id="解法">解法<a hidden class="anchor" aria-hidden="true" href="#解法">#</a></h3>
<p>这道题有两种解法,一种思路是搜索,用DFS搜索一遍,每次在5张牌时判断目前的五张牌是什么情况,对应的情况计数增加.第二种解法是直接用排列组合的方式直接计算出每种情况的个数.</p>
<p>这道题我是用第二种方法做的,首先写一个用于计算组合数的函数,用它来计算组合数.设牌的大小是1-n,花色有m种</p>
<ol>
<li>首先判断两张牌花色相同且相差不大于4,然后找到上下界,在上下界中找出大小为5的窗口有几个就行了</li>
<li>和上一个差不多,但是不判断花色了,然后后摸的三张牌颜色要进行组合最后要减去1的数量</li>
<li>判断两张牌的花色是否相同,相同的话,直接$C_{n-2}^3$就行了,最后减1中的</li>
<li>首先判断总的花色数,必须等于4,判断两张牌大小是否相等,相等的话只有一张牌是自由的,那么一共有(n-1)*m种可能,否则没有牌是自由的,只有两种可能</li>
<li>首先判断m是不是大于等于3,然后分成两类,一类是先摸的两张牌大小相同,这种情况下在分为先摸的牌为2和先摸的牌为3再次讨论,如果两张牌(A,B)大小不同则按A为2,B为3和A为3,B为2讨论,这两种情况是一样的,直接*2就行</li>
<li>这个也是先判断花色总数,然后分为先摸牌相等和不等两种情况,第二种情况下还要判断先摸的两张牌都是对,还是一个是1一个是对</li>
<li>注意这里的3张大小相同要求剩下的两张必须不同.同样先判断花色总数,之后分为先摸牌相等和不等讨论.在进一步的讨论中,还要分出3,1,1具体对应的是哪个</li>
<li>同样,2张相同的,3张不同的.剩下的方法也是相似的,看花色总数,分成先摸牌相等和不等讨论,进一步的讨论中分清楚2,1,1,1分别是那个</li>
<li>计算出总的情况数,减去上面的就行了</li>
</ol>
<p>这种方法实在是太麻烦了,搜索的方法会简单很多,因为判断条件要比排列组合好写太多</p>
<h3 id="code">code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> ans[<span style="color:#ae81ff">10</span>];<span style="color:#75715e">//1 start
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> A,B;<span style="color:#75715e">//A是牌的总大小,B是牌的花色数
</span><span style="color:#75715e"></span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> curCard[<span style="color:#ae81ff">2</span>];<span style="color:#75715e">//记录先摸的两张牌
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">comb</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b)<span style="color:#75715e">//计算组合数
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> answer <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>b;i<span style="color:#f92672">++</span>)
        answer<span style="color:#f92672">*=</span>(a<span style="color:#f92672">-</span>i);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>b;i<span style="color:#f92672">++</span>)
        answer<span style="color:#f92672">/=</span>(i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">if</span>(answer<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>)
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">return</span> answer;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">con1</span>()
{
    <span style="color:#66d9ef">if</span>(curCard[<span style="color:#ae81ff">0</span>].second<span style="color:#f92672">!=</span>curCard[<span style="color:#ae81ff">1</span>].second<span style="color:#f92672">||</span>abs(curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">-</span>curCard[<span style="color:#ae81ff">1</span>].first)<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">4</span>)
        <span style="color:#66d9ef">return</span> ;
    <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">&gt;</span>curCard[<span style="color:#ae81ff">1</span>].first<span style="color:#f92672">?</span>curCard[<span style="color:#ae81ff">0</span>].first:curCard[<span style="color:#ae81ff">1</span>].first;<span style="color:#75715e">//取出两张牌中大的和小的
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">&lt;</span>curCard[<span style="color:#ae81ff">1</span>].first<span style="color:#f92672">?</span>curCard[<span style="color:#ae81ff">0</span>].first:curCard[<span style="color:#ae81ff">1</span>].first;
    <span style="color:#66d9ef">int</span> up <span style="color:#f92672">=</span> min<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;</span>A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">?</span>A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>min<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>;<span style="color:#75715e">//上界
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> down <span style="color:#f92672">=</span> max<span style="color:#f92672">-</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">?</span><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>max<span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>;<span style="color:#75715e">//下界
</span><span style="color:#75715e"></span>    ans[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> up<span style="color:#f92672">-</span>down<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span><span style="color:#ae81ff">5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//窗口的个数
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">con2</span>()
{
    <span style="color:#66d9ef">if</span>(curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">==</span>curCard[<span style="color:#ae81ff">1</span>].first<span style="color:#f92672">||</span>abs(curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">-</span>curCard[<span style="color:#ae81ff">1</span>].first)<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">4</span>)<span style="color:#75715e">//不需要花色了,但是前两张牌大小不能相同
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
    <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">&gt;</span>curCard[<span style="color:#ae81ff">1</span>].first<span style="color:#f92672">?</span>curCard[<span style="color:#ae81ff">0</span>].first:curCard[<span style="color:#ae81ff">1</span>].first;
    <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">&lt;</span>curCard[<span style="color:#ae81ff">1</span>].first<span style="color:#f92672">?</span>curCard[<span style="color:#ae81ff">0</span>].first:curCard[<span style="color:#ae81ff">1</span>].first;
    <span style="color:#66d9ef">int</span> up <span style="color:#f92672">=</span> min<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&gt;</span>A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">?</span>A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>min<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>;
    <span style="color:#66d9ef">int</span> down <span style="color:#f92672">=</span> max<span style="color:#f92672">-</span><span style="color:#ae81ff">4</span><span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">?</span><span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>max<span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>;
    ans[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> (up<span style="color:#f92672">-</span>down<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span><span style="color:#ae81ff">5</span><span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>B<span style="color:#f92672">*</span>B<span style="color:#f92672">*</span>B <span style="color:#f92672">-</span> ans[<span style="color:#ae81ff">1</span>];<span style="color:#75715e">//容斥要求减掉共同部分
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">con3</span>()
{
    <span style="color:#66d9ef">if</span>(curCard[<span style="color:#ae81ff">0</span>].second<span style="color:#f92672">!=</span>curCard[<span style="color:#ae81ff">1</span>].second)<span style="color:#75715e">//不同花色直接退出
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span>;
    ans[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> comb(A<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>)<span style="color:#f92672">-</span>ans[<span style="color:#ae81ff">1</span>];<span style="color:#75715e">//要求花色相同,但是大小无限制
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">con4</span>()
{
    <span style="color:#66d9ef">if</span>(B<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>)
    {
        ans[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span>;
    }
    <span style="color:#66d9ef">if</span>(curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">==</span>curCard[<span style="color:#ae81ff">1</span>].first)
        ans[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span>(A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>B;<span style="color:#75715e">//后选的牌有两张和先摸的相同,剩下的一张随便
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">else</span>
        ans[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;<span style="color:#75715e">//只能于先摸的其中一张相同
</span><span style="color:#75715e"></span>}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">con5</span>()
{
    <span style="color:#66d9ef">if</span>(B<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">3</span>)
    {
        ans[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span>;
    }
    <span style="color:#66d9ef">if</span>(curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">==</span>curCard[<span style="color:#ae81ff">1</span>].first)
    {
        ans[<span style="color:#ae81ff">5</span>]<span style="color:#f92672">+=</span> comb(B,<span style="color:#ae81ff">2</span>)<span style="color:#f92672">*</span>(A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>comb(B<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>);<span style="color:#75715e">//先摸的为3张,后摸的为2张
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(B<span style="color:#f92672">==</span><span style="color:#ae81ff">3</span>)<span style="color:#75715e">//后面抽的为3,前面为2,对于3种花色
</span><span style="color:#75715e"></span>            ans[<span style="color:#ae81ff">5</span>]<span style="color:#f92672">+=</span>(A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
        <span style="color:#66d9ef">if</span>(B<span style="color:#f92672">==</span><span style="color:#ae81ff">4</span>)<span style="color:#75715e">//4种花色
</span><span style="color:#75715e"></span>            ans[<span style="color:#ae81ff">5</span>]<span style="color:#f92672">+=</span>(A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">4</span>;
    }
    <span style="color:#66d9ef">else</span><span style="color:#75715e">//抽到的牌不同
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">if</span>(B<span style="color:#f92672">==</span><span style="color:#ae81ff">3</span>)
            ans[<span style="color:#ae81ff">5</span>]<span style="color:#f92672">+=</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//2选1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(B<span style="color:#f92672">==</span><span style="color:#ae81ff">4</span>)
            ans[<span style="color:#ae81ff">5</span>]<span style="color:#f92672">+=</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#ae81ff">3</span><span style="color:#f92672">*</span><span style="color:#ae81ff">3</span>;<span style="color:#75715e">//3选2.3选1
</span><span style="color:#75715e"></span>    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">con6</span>()
{
    <span style="color:#66d9ef">if</span>(B<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span>)
    {
        ans[<span style="color:#ae81ff">6</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span> ;
    }
    <span style="color:#66d9ef">if</span>(curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">==</span>curCard[<span style="color:#ae81ff">1</span>].first)
    {
        ans[<span style="color:#ae81ff">6</span>]<span style="color:#f92672">+=</span>comb(A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>)<span style="color:#f92672">*</span>B<span style="color:#f92672">*</span>comb(B,<span style="color:#ae81ff">2</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>;<span style="color:#75715e">//先摸的两两张必然是对,剩下的3张中出一个对
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">else</span> 
    {
        ans[<span style="color:#ae81ff">6</span>]<span style="color:#f92672">+=</span>comb(A<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>comb(B<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>comb(B<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>B<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span>comb(A<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>comb(B,<span style="color:#ae81ff">2</span>)<span style="color:#f92672">*</span>(B<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);<span style="color:#75715e">//对子都在先抽的中,或者先抽的中只有一个对
</span><span style="color:#75715e"></span>    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">con7</span>()
{
    <span style="color:#66d9ef">if</span>(B<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">3</span>)
    {
        ans[<span style="color:#ae81ff">7</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">return</span>;
    }
    <span style="color:#66d9ef">if</span>(curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">==</span>curCard[<span style="color:#ae81ff">1</span>].first)
    {
        ans[<span style="color:#ae81ff">7</span>]<span style="color:#f92672">+=</span>comb(A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>)<span style="color:#f92672">*</span>comb(B<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>B<span style="color:#f92672">*</span>B;<span style="color:#75715e">//只能是先摸的两张是3张
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">else</span>
    {
        ans[<span style="color:#ae81ff">7</span>]<span style="color:#f92672">+=</span>comb(A<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>B<span style="color:#f92672">*</span>comb(B<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span>comb(A<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>comb(B,<span style="color:#ae81ff">3</span>);<span style="color:#75715e">//先摸的有一个是3张的,或者都不是
</span><span style="color:#75715e"></span>    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">con8</span>()
{
    <span style="color:#66d9ef">if</span>(B<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span>)
    {
        ans[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> ;
        <span style="color:#66d9ef">return</span> ;
    }
    <span style="color:#66d9ef">if</span>(curCard[<span style="color:#ae81ff">0</span>].first<span style="color:#f92672">==</span>curCard[<span style="color:#ae81ff">1</span>].first)
    {
        ans[<span style="color:#ae81ff">8</span>]<span style="color:#f92672">+=</span> comb(A<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>)<span style="color:#f92672">*</span>B<span style="color:#f92672">*</span>B<span style="color:#f92672">*</span>B;<span style="color:#75715e">//后抽的三张随便了
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">else</span>
    {
        ans[<span style="color:#ae81ff">8</span>]<span style="color:#f92672">+=</span> comb(A<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>)<span style="color:#f92672">*</span>B<span style="color:#f92672">*</span>B<span style="color:#f92672">*</span>comb(B<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span><span style="color:#f92672">+</span>comb(A<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>)<span style="color:#f92672">*</span>B<span style="color:#f92672">*</span>comb(B,<span style="color:#ae81ff">2</span>)<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>;<span style="color:#75715e">//先抽的两张中有一个是2,或者都不是2
</span><span style="color:#75715e"></span>    }
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">con9</span>()
{
    <span style="color:#66d9ef">int</span> all <span style="color:#f92672">=</span> comb(A<span style="color:#f92672">*</span>B<span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>)<span style="color:#75715e">//总的情况数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">9</span>;i<span style="color:#f92672">++</span>)
        all <span style="color:#f92672">-=</span> ans[i];<span style="color:#75715e">//去掉其他的
</span><span style="color:#75715e"></span>    ans[<span style="color:#ae81ff">9</span>]<span style="color:#f92672">=</span> all;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    memset(ans,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(ans));
    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>A,<span style="color:#f92672">&amp;</span>B);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">2</span>;i<span style="color:#f92672">++</span>)
        scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>curCard[i].first,<span style="color:#f92672">&amp;</span>curCard[i].second);
    con1();
    con2();
    con3();
    con4();
    con5();
    con6();
    con7();
    con8();
    con9();
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">9</span>;i<span style="color:#f92672">++</span>)
        cout<span style="color:#f92672">&lt;&lt;</span>ans[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>高中做题做习惯了,一看见这种形式就直接用排列组合了,但是在CPU中遍历方便的多,而且数据规模很小,不如直接遍历.直接遍历还不会出现排列组合没考虑全的情况,这道题写的有点麻烦了.</p>
<h1 id="week6-homework">week6-homework<a hidden class="anchor" aria-hidden="true" href="#week6-homework">#</a></h1>
<h2 id="a---氪金带东">A - 氪金带东<a hidden class="anchor" aria-hidden="true" href="#a---氪金带东">#</a></h2>
<h3 id="题意-1">题意<a hidden class="anchor" aria-hidden="true" href="#题意-1">#</a></h3>
<p>本题的意思是求取一个数中任意一个点到离它最远的点的距离</p>
<p>PS: 我觉得题中的说法稍微有点问题,应该指明没有回路,有回路的话一直绕圈不会有最长的路径,我做的时候是把这个图当成一个树来解决的.</p>
<h3 id="解法-1">解法<a hidden class="anchor" aria-hidden="true" href="#解法-1">#</a></h3>
<p>首先我们有求取树的直径的方法,就是首先从任意一个点出发,用BFS,DFS(必须遍历一边,类似Dij的贪心算法是不行的,因为局部最优不等于全局最优)找到距离该点最远的一个点A,然后从A开始找到离A最远的点B,A,B之间的距离就是树的直径,这个可以用反正法进行证明.</p>
<p>我们要做的是在这个基础上进行一些改动,从A到B的遍历中,记录每一个点距离A的最远距离,在从B开始一次遍历,记录其他点到B的最远距离,然后最远的距离是A,B中最远的哪一个.</p>
<h3 id="code-1">code<a hidden class="anchor" aria-hidden="true" href="#code-1">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> one[<span style="color:#ae81ff">10002</span>];<span style="color:#75715e">//记录到A的距离
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> two[<span style="color:#ae81ff">10002</span>];<span style="color:#75715e">//记录到B的距离
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> vis[<span style="color:#ae81ff">10002</span>];<span style="color:#75715e">//记录访问情况
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> G[<span style="color:#ae81ff">10002</span>];<span style="color:#75715e">//邻接链表存储树
</span><span style="color:#75715e"></span>
pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> A;<span style="color:#75715e">//第一个是编号,第二个是最长距离
</span><span style="color:#75715e"></span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> B;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bfsFind</span>()<span style="color:#75715e">//第一次找到A
</span><span style="color:#75715e"></span>{
    memset(vis,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(vis));<span style="color:#75715e">//务必初始化
</span><span style="color:#75715e"></span>    queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> q;<span style="color:#75715e">//第一个是编号,第二个是最长距离
</span><span style="color:#75715e"></span>    q.push(make_pair(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>));
    vis[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> true;
    pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> maxPair(<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty())<span style="color:#75715e">//BFS实现
</span><span style="color:#75715e"></span>    {
        pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> temp <span style="color:#f92672">=</span> q.front();
        q.pop();
        <span style="color:#66d9ef">if</span>(temp.second<span style="color:#f92672">&gt;</span>maxPair.second)<span style="color:#75715e">//最远的点
</span><span style="color:#75715e"></span>            maxPair <span style="color:#f92672">=</span> {temp.first,temp.second};
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i:G[temp.first])
        {
            <span style="color:#66d9ef">if</span>(vis[i.first]<span style="color:#f92672">==</span>false)
            {
                vis[i.first] <span style="color:#f92672">=</span> true;
                q.push(make_pair(i.first,i.second<span style="color:#f92672">+</span>temp.second));
            }
        }
    }
    A <span style="color:#f92672">=</span> {maxPair.first,<span style="color:#ae81ff">0</span>};
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS1</span>()<span style="color:#75715e">//从A找到B
</span><span style="color:#75715e"></span>{
    memset(vis,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(vis));<span style="color:#75715e">//初始化
</span><span style="color:#75715e"></span>    queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> q;<span style="color:#75715e">//第一个是编号,第二个是最长距离
</span><span style="color:#75715e"></span>    q.push(A);
    vis[A.first] <span style="color:#f92672">=</span> true;
    pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> maxPair(A.first,<span style="color:#ae81ff">0</span>);
    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty())
    {
        pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> temp <span style="color:#f92672">=</span> q.front();
        q.pop();
        <span style="color:#66d9ef">if</span>(temp.second<span style="color:#f92672">&gt;</span>maxPair.second)
            maxPair <span style="color:#f92672">=</span> {temp.first,temp.second};
        one[temp.first] <span style="color:#f92672">=</span> temp.second;<span style="color:#75715e">//每个点之访问一遍,这一边就是最远距离
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i:G[temp.first])
        {
            <span style="color:#66d9ef">if</span>(vis[i.first]<span style="color:#f92672">==</span>false)
            {
                vis[i.first] <span style="color:#f92672">=</span> true;
                q.push(make_pair(i.first,i.second<span style="color:#f92672">+</span>temp.second));
            }
        }
    }
    B <span style="color:#f92672">=</span> {maxPair.first,<span style="color:#ae81ff">0</span>};
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS2</span>()
{
    memset(vis,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(vis));<span style="color:#75715e">//初始化
</span><span style="color:#75715e"></span>    queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span>q;<span style="color:#75715e">//第一个是编号,第二个是最长距离
</span><span style="color:#75715e"></span>    q.push(make_pair(B.first,<span style="color:#ae81ff">0</span>));
    vis[B.first] <span style="color:#f92672">=</span> true;
    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty())
    {
        pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> temp <span style="color:#f92672">=</span> q.front();
        q.pop();
        two[temp.first] <span style="color:#f92672">=</span> temp.second;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i:G[temp.first])
        {
            <span style="color:#66d9ef">if</span>(vis[i.first]<span style="color:#f92672">==</span>false)
            {
                vis[i.first] <span style="color:#f92672">=</span> true;
                q.push(make_pair(i.first,i.second<span style="color:#f92672">+</span>temp.second));
            }
        }
    }
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> n;
    <span style="color:#66d9ef">while</span>(scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n)<span style="color:#f92672">!=</span>EOF)
    {
        memset(one,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(one));
        memset(two,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(two));  
        <span style="color:#66d9ef">int</span> point,weight;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
        {
            scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>point,<span style="color:#f92672">&amp;</span>weight);
            G[i].push_back(make_pair(point<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,weight));
            G[point<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>].push_back(make_pair(i,weight));
        }
        bfsFind();<span style="color:#75715e">//3遍BFS
</span><span style="color:#75715e"></span>        BFS1();
        BFS2();
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
            printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,one[i]<span style="color:#f92672">&gt;</span>two[i]<span style="color:#f92672">?</span>one[i]<span style="color:#f92672">:</span>two[i]);<span style="color:#75715e">//选出最远的
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
            G[i].clear();
    }
}
</code></pre></div><h3 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h3>
<p>这个题的实现方式上也有点意思,首先虽然是一个树,但是还是按照图存储的,访问的时候是记录vis,确保是一个连通无回路的树,相当于我们能把任意一个节点当成根节点,遍历整个树,纯的树一般是一种有向图,因此不能从任意一个点出发访问.</p>
<p>一个连通图BFS一遍或者DFS一遍必定得到一个生成树.</p>
<h2 id="b---戴好口罩">B - 戴好口罩！<a hidden class="anchor" aria-hidden="true" href="#b---戴好口罩">#</a></h2>
<h3 id="题意-2">题意<a hidden class="anchor" aria-hidden="true" href="#题意-2">#</a></h3>
<p>给定n个数,然后给定m个集合,集合中的数字属于一个等价类,问和0同处一个等价类的元素有多少个</p>
<h3 id="解法-2">解法<a hidden class="anchor" aria-hidden="true" href="#解法-2">#</a></h3>
<p>这道题直接用并查集解决就可以,同一个集合的是一类,不断合并,最终求出0号所在的集合,然后统计出属于整个集合的元素的个数</p>
<h3 id="code-2">code<a hidden class="anchor" aria-hidden="true" href="#code-2">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> same[<span style="color:#ae81ff">30002</span>];<span style="color:#75715e">//并查集所用的数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> i)<span style="color:#75715e">//查询
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">!=</span>same[i])
        <span style="color:#66d9ef">return</span> same[i] <span style="color:#f92672">=</span> find(same[i]);<span style="color:#75715e">//路径压缩
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> i;
}
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">uni</span>(<span style="color:#66d9ef">int</span> i,<span style="color:#66d9ef">int</span> j)<span style="color:#75715e">//合并
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">if</span>(find(i) <span style="color:#f92672">==</span> find(j))
        <span style="color:#66d9ef">return</span> false;
    same[find(j)] <span style="color:#f92672">=</span> find(i);
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> m,n;
    <span style="color:#66d9ef">while</span>(scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>n,<span style="color:#f92672">&amp;</span>m))
    {
        <span style="color:#66d9ef">if</span>(m<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span><span style="color:#f92672">&amp;&amp;</span>n<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//初始化
</span><span style="color:#75715e"></span>            same[i] <span style="color:#f92672">=</span> i;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>m;i<span style="color:#f92672">++</span>)
        {
            <span style="color:#66d9ef">int</span> num;
            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>num);
            <span style="color:#66d9ef">int</span> pre,temp;
            <span style="color:#66d9ef">if</span>(num<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>)
                scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>pre);
            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> t<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;t<span style="color:#f92672">&lt;</span>num;t<span style="color:#f92672">++</span>)
            {
                scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>temp);
                uni(pre,temp);<span style="color:#75715e">//集合中合并
</span><span style="color:#75715e"></span>                pre <span style="color:#f92672">=</span> temp;
            }    
        }
        <span style="color:#66d9ef">int</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//same中和0号同一个元素的个数
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> tar <span style="color:#f92672">=</span> find(<span style="color:#ae81ff">0</span>);<span style="color:#75715e">//0号所在的集合
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//遍历一遍same
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(find(i) <span style="color:#f92672">==</span> tar)
                count<span style="color:#f92672">++</span>;<span style="color:#75715e">//总数增加
</span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,count);
    }
}
</code></pre></div><h3 id="总结-2">总结<a hidden class="anchor" aria-hidden="true" href="#总结-2">#</a></h3>
<p>并查集实现要加上路径压缩.</p>
<h2 id="c---掌握魔法の东东-i">C - 掌握魔法の东东 I<a hidden class="anchor" aria-hidden="true" href="#c---掌握魔法の东东-i">#</a></h2>
<h3 id="题意-3">题意<a hidden class="anchor" aria-hidden="true" href="#题意-3">#</a></h3>
<p>现在有一个图,途中有n个点,现在让n个点上要有水,水可以是通过其他节点送得,需要边权的耗费,也可以是直接获得,需要$W_i$的耗费(题中给出),问最小耗费是多少</p>
<h3 id="解法-3">解法<a hidden class="anchor" aria-hidden="true" href="#解法-3">#</a></h3>
<p>这道题需要抽象一下,首先直接获得或者其他节点送的都是要耗费,因此二者是等价的,我们开一个节点代表水,把每个点都和水连接,边权就是$W_i$,题意想要的就是每个点都与水联通,这个就是生成树的问题了,直接用最小生成树就行了</p>
<h3 id="code-3">code<a hidden class="anchor" aria-hidden="true" href="#code-3">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">//kruskal实现最小生成树
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">edge</span><span style="color:#75715e">//边权
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> s;
    <span style="color:#66d9ef">int</span> e;
    <span style="color:#66d9ef">int</span> w;
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> edge <span style="color:#f92672">&amp;</span> op) <span style="color:#66d9ef">const</span>
    {<span style="color:#66d9ef">return</span> w<span style="color:#f92672">&lt;</span>op.w;}
};
vector<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> G[<span style="color:#ae81ff">302</span>];<span style="color:#75715e">//图
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> w[<span style="color:#ae81ff">302</span>];<span style="color:#75715e">//水与每个点的权重
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> same[<span style="color:#ae81ff">302</span>];<span style="color:#75715e">//并查集
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> i)
{
    <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">!=</span>same[i])
        <span style="color:#66d9ef">return</span> same[i] <span style="color:#f92672">=</span> find(same[i]);
    <span style="color:#66d9ef">return</span> i;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">uni</span>(<span style="color:#66d9ef">int</span> i,<span style="color:#66d9ef">int</span> j)
{
    <span style="color:#66d9ef">if</span>(find(i) <span style="color:#f92672">==</span> find(j))
        <span style="color:#66d9ef">return</span> false;
    same[find(j)] <span style="color:#f92672">=</span> find(i);
    <span style="color:#66d9ef">return</span> true;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> n;
    <span style="color:#66d9ef">int</span> temp;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,w<span style="color:#f92672">+</span>i);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//初始化并查集
</span><span style="color:#75715e"></span>        same[i] <span style="color:#f92672">=</span> i;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
    {
        G[n].push_back(make_pair(i,w[i]));<span style="color:#75715e">//第n个节点当作水,连接起来
</span><span style="color:#75715e"></span>        G[i].push_back(make_pair(n,w[i]));
        <span style="color:#75715e">// std::cout &lt;&lt; &#34;w: &#34;&lt;&lt;w[i] &lt;&lt; std::endl;
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//构建图
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>n;j<span style="color:#f92672">++</span>)
        {
            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>temp);
            <span style="color:#66d9ef">if</span>(temp <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
                <span style="color:#66d9ef">continue</span>;
            G[i].push_back(make_pair(j,temp));
            G[j].push_back(make_pair(i,temp));
        }
    vector<span style="color:#f92672">&lt;</span>edge<span style="color:#f92672">&gt;</span> e;<span style="color:#75715e">//图的边
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> j : G[i])
            e.push_back({i,j.first,j.second});
    sort(e.begin(),e.end());<span style="color:#75715e">//排序
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//边权
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i:e)
    {
        <span style="color:#75715e">// cout&lt;&lt;&#34;p1: &#34;&lt;&lt;i.s&lt;&lt;&#34; p2: &#34;&lt;&lt;i.e&lt;&lt;endl;
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span>(uni(i.s,i.e))<span style="color:#75715e">//不是一类就能合并
</span><span style="color:#75715e"></span>            count <span style="color:#f92672">+=</span> i.w;
    }
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,count);
}
</code></pre></div><h3 id="总结-3">总结<a hidden class="anchor" aria-hidden="true" href="#总结-3">#</a></h3>
<p>这道题不难写但是比较难想,首先得把水和节点直接的路统一起来,然后直到每一个点都能连接到一个点最小权值的情况就是最小生成树.</p>
<h2 id="d---数据中心">D - 数据中心<a hidden class="anchor" aria-hidden="true" href="#d---数据中心">#</a></h2>
<h3 id="题意-4">题意<a hidden class="anchor" aria-hidden="true" href="#题意-4">#</a></h3>
<p>图中有一个root节点,所有点都要到这个点,这样就能构成一个生成树,求取生成树中边权最大的边的最小值</p>
<h3 id="解法-4">解法<a hidden class="anchor" aria-hidden="true" href="#解法-4">#</a></h3>
<h4 id="二分">二分:<a hidden class="anchor" aria-hidden="true" href="#二分">#</a></h4>
<p>从0和最大边权中开始二分,然后找到一条小于等于那个权值的边,把边连接的两个点加入队列开始BFS,看看能不能构成生成树</p>
<h4 id="最小瓶颈生成树">最小瓶颈生成树:<a hidden class="anchor" aria-hidden="true" href="#最小瓶颈生成树">#</a></h4>
<p>最小生成树一定是最小瓶颈生成树,求个最小生成树,然后找出最大边</p>
<p>简易证明(反证)</p>
<p>设最小生成树中最大边A,B的权值为W,最小瓶颈生成树的最大边权值是K,设K&lt;W</p>
<p>那么我们完全可以将A,B拆分开,将B按照最小瓶颈生成树中的边连接,改造后的最小生成树总权值会变小,因此不对,所以最小生成树是最小瓶颈生成树.</p>
<h3 id="code-4">code<a hidden class="anchor" aria-hidden="true" href="#code-4">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">//只有边集,没有存完整的图结构
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">edge</span><span style="color:#75715e">//边
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> s;
    <span style="color:#66d9ef">int</span> e;
    <span style="color:#66d9ef">int</span> weight;
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span> <span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> edge <span style="color:#f92672">&amp;</span> op) <span style="color:#66d9ef">const</span>{
        <span style="color:#66d9ef">return</span> weight<span style="color:#f92672">&lt;</span>op.weight;
    }
};

vector<span style="color:#f92672">&lt;</span>edge<span style="color:#f92672">&gt;</span> G;<span style="color:#75715e">//图
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span>edge<span style="color:#f92672">&gt;</span> ans;<span style="color:#75715e">//生成树
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> same[<span style="color:#ae81ff">50002</span>];<span style="color:#75715e">//并查集
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span> (<span style="color:#66d9ef">int</span> i)
{
    <span style="color:#66d9ef">if</span>(same[i]<span style="color:#f92672">!=</span>i)
        <span style="color:#66d9ef">return</span> same[i] <span style="color:#f92672">=</span> find(same[i]);;
    <span style="color:#66d9ef">return</span> i;
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">uni</span>(<span style="color:#66d9ef">int</span> i,<span style="color:#66d9ef">int</span> j)
{
    <span style="color:#66d9ef">if</span>(find(i) <span style="color:#f92672">==</span> find (j))
        <span style="color:#66d9ef">return</span> false;
    same[find(j)] <span style="color:#f92672">=</span> find(i);
    <span style="color:#66d9ef">return</span> true;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> m,n,root;
    scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>m,<span style="color:#f92672">&amp;</span>n,<span style="color:#f92672">&amp;</span>root);
    <span style="color:#66d9ef">int</span> a,c,b;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>m;i<span style="color:#f92672">++</span>)
        same[i] <span style="color:#f92672">=</span> i;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
    {
        scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>a,<span style="color:#f92672">&amp;</span>b,<span style="color:#f92672">&amp;</span>c);<span style="color:#75715e">//只有边
</span><span style="color:#75715e"></span>        G.push_back({a,b,c});
    }
    sort(G.begin(),G.end());<span style="color:#75715e">//排序
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> ;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i:G)<span style="color:#75715e">//最小生成树
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">if</span>(uni(i.s,i.e))
            ans.push_back(i);
    }
    sort(ans.begin(),ans.end(),[](edge<span style="color:#f92672">&amp;</span> a,edge<span style="color:#f92672">&amp;</span> b){<span style="color:#66d9ef">return</span> a.weight<span style="color:#f92672">&gt;</span>b.weight;});<span style="color:#75715e">//输出最大值
</span><span style="color:#75715e"></span>    printf(<span style="color:#e6db74">&#34;%d&#34;</span>,ans[<span style="color:#ae81ff">0</span>].weight);
}
</code></pre></div><h3 id="总结-4">总结<a hidden class="anchor" aria-hidden="true" href="#总结-4">#</a></h3>
<p>最小生成树就是最小瓶颈生成树</p>
<p>证明还是反证法居多.</p>
<h1 id="csp模拟题-201512-3">CSP模拟题 201512-3<a hidden class="anchor" aria-hidden="true" href="#csp模拟题-201512-3">#</a></h1>
<h2 id="画图">画图<a hidden class="anchor" aria-hidden="true" href="#画图">#</a></h2>
<h3 id="题意-5">题意<a hidden class="anchor" aria-hidden="true" href="#题意-5">#</a></h3>
<p>这是一道较为基础的模拟题.</p>
<p>现在给出一个m*n的图像,要求按照给定的规则画图</p>
<p>初始化图像所有的点为'.'</p>
<p>1.画线,可以画水平方向是或者竖直方向上的直线,会给出直线的起始坐标和坐标.横线为'-',竖线为'|&lsquo;当横线和竖线相交时,交点为&rsquo;+'.</p>
<p>2.填充.使用给定的字符填充这副图像.填充规则为,给定一个点的坐标,以这个点开始在上下左右4个方向上填充,直到遇到直线或者图像边界</p>
<p>现在给出一个操作序列,要求按照顺序输出最终渲染的图像</p>
<h3 id="解法-5">解法<a hidden class="anchor" aria-hidden="true" href="#解法-5">#</a></h3>
<p>设计4个函数,分别是画直线,填充,判断能不能填充和输出</p>
<p>使用<code>char data [][]</code>来记录图像中的信息,但是输出时的坐标系和题目要求中的方向在y方向是反的,因此使用output反向输出,这样其他函数中可以把<code>data[0][0]</code>作为(0,0)使用</p>
<p>画线分为横线和竖线两种情况,使用一个数组<code>vis[][]</code>来记录画过的点,画的竖线,vis设为1横线设为2,在画线的过程中遇到横线竖线相交的情况时,将data置为'+',vis置为3,之后这个点不会再发生改变</p>
<p>填充操作使用BFS,开一个<code>tempVis[][]</code>记录访问过的点,队列中的每一个元素都改变data,然后在4个方向上使用check判断能不放入是否被访问过,满足条件加入队列,同时标记tempVis</p>
<p>check函数判断一个点是否超出了边界或者已经有了直线,上述两种情况返回false,否则返回true</p>
<h3 id="code-5">code<a hidden class="anchor" aria-hidden="true" href="#code-5">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> vis[<span style="color:#ae81ff">102</span>][<span style="color:#ae81ff">102</span>];<span style="color:#75715e">//记录直线
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> tempVis[<span style="color:#ae81ff">102</span>][<span style="color:#ae81ff">102</span>];<span style="color:#75715e">//BFS
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> m,n,q;
<span style="color:#66d9ef">char</span> data[<span style="color:#ae81ff">102</span>][<span style="color:#ae81ff">102</span>];<span style="color:#75715e">//图像
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dirX[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span>{<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>};<span style="color:#75715e">//4个方向
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> dirY[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span>{<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">drwaLine</span>(<span style="color:#66d9ef">int</span> x1,<span style="color:#66d9ef">int</span> y1,<span style="color:#66d9ef">int</span> x2,<span style="color:#66d9ef">int</span> y2)
{
    <span style="color:#66d9ef">if</span>(x1 <span style="color:#f92672">==</span> x2)<span style="color:#75715e">//竖线
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">int</span> high <span style="color:#f92672">=</span> max(y1,y2);
        <span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> min(y1,y2);
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>low;i<span style="color:#f92672">&lt;=</span>high;i<span style="color:#f92672">++</span>)
        {
            <span style="color:#66d9ef">if</span>(vis[x1][i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//没有直线
</span><span style="color:#75715e"></span>            {
                data[x1][i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;|&#39;</span>;
                vis[x1][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
            }
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(vis[x1][i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>)<span style="color:#75715e">//已经有横线
</span><span style="color:#75715e"></span>            {
                data[x1][i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;+&#39;</span>;
                vis[x1][i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
            }
        }
    }
    <span style="color:#66d9ef">else</span><span style="color:#75715e">//横线
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">int</span> high <span style="color:#f92672">=</span> max(x1,x2);
        <span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> min(x1,x2);
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>low;i<span style="color:#f92672">&lt;=</span>high;i<span style="color:#f92672">++</span>)
        {
            <span style="color:#66d9ef">if</span>(vis[i][y1] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//没有直线
</span><span style="color:#75715e"></span>            {
                data[i][y1] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;-&#39;</span>;
                vis[i][y1] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
            }
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(vis[i][y1] <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>)<span style="color:#75715e">//有了竖线
</span><span style="color:#75715e"></span>            {
                data[i][y1] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;+&#39;</span>;
                vis[i][y1] <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
            }
        }
    }
}

<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> y)
{
    <span style="color:#66d9ef">if</span>(x<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>y<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>x<span style="color:#f92672">&gt;</span>m<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">||</span>y<span style="color:#f92672">&gt;</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//边界
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
    <span style="color:#66d9ef">if</span>(vis[x][y] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//直线
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> false;
    <span style="color:#66d9ef">return</span> true;
}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fillContent</span>(<span style="color:#66d9ef">int</span> x,<span style="color:#66d9ef">int</span> y,<span style="color:#66d9ef">char</span> c)
{ 
    memset(tempVis,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(tempVis));
    queue<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> q;
    tempVis[x][y]<span style="color:#f92672">=</span>true;
    <span style="color:#66d9ef">if</span> (check(x,y))
        q.push(make_pair(x,y));
    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty())
    {
        pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> cur <span style="color:#f92672">=</span> q.front();
        q.pop();
        data[cur.first][cur.second] <span style="color:#f92672">=</span> c;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>;i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span>(check(cur.first<span style="color:#f92672">+</span>dirX[i],cur.second<span style="color:#f92672">+</span>dirY[i])<span style="color:#f92672">&amp;&amp;</span>tempVis[cur.first<span style="color:#f92672">+</span>dirX[i] ][cur.second<span style="color:#f92672">+</span>dirY[i] ] <span style="color:#f92672">==</span> false)<span style="color:#75715e">//可以放入
</span><span style="color:#75715e"></span>            {
                q.push(make_pair(cur.first<span style="color:#f92672">+</span>dirX[i],cur.second<span style="color:#f92672">+</span>dirY[i]));
                tempVis[cur.first<span style="color:#f92672">+</span>dirX[i] ][cur.second<span style="color:#f92672">+</span>dirY[i] ] <span style="color:#f92672">=</span> true;
            }
    }

}
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">output</span>()<span style="color:#75715e">//输出
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>)<span style="color:#75715e">//y轴上反着
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>m;j<span style="color:#f92672">++</span>)
            printf(<span style="color:#e6db74">&#34;%c&#34;</span>,data[j][i]);
        printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    memset(vis,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(vis));
    memset(tempVis,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(tempVis));
    memset(data,<span style="color:#e6db74">&#39;.&#39;</span>,<span style="color:#66d9ef">sizeof</span>(data));<span style="color:#75715e">//初始化为&#39;.&#39;
</span><span style="color:#75715e"></span>   
    scanf(<span style="color:#e6db74">&#34;%d%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>m,<span style="color:#f92672">&amp;</span>n,<span style="color:#f92672">&amp;</span>q);
    
    <span style="color:#66d9ef">int</span> temp;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>q;i<span style="color:#f92672">++</span>)
    {
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>temp);
        <span style="color:#66d9ef">if</span>(temp <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
        {
            <span style="color:#66d9ef">int</span> x1,y1,x2,y2;
            scanf(<span style="color:#e6db74">&#34;%d%d%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>x1,<span style="color:#f92672">&amp;</span>y1,<span style="color:#f92672">&amp;</span>x2,<span style="color:#f92672">&amp;</span>y2);
            drwaLine(x1,y1,x2,y2);
        }
        <span style="color:#66d9ef">else</span>
        {
            <span style="color:#66d9ef">int</span> x,y;
            <span style="color:#66d9ef">char</span> c;
            scanf(<span style="color:#e6db74">&#34;%d%d %c&#34;</span>,<span style="color:#f92672">&amp;</span>x,<span style="color:#f92672">&amp;</span>y,<span style="color:#f92672">&amp;</span>c);
            fillContent(x,y,c);
        }
    }
    output();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="总结-5">总结<a hidden class="anchor" aria-hidden="true" href="#总结-5">#</a></h3>
<p>这道题交了3次,第一次BFS写的稍微有点问题,第二次没有考虑到在一个地方上多次画一种线的情况,我把多次画一种线也整成了'+'.</p>
<p>CSP的模拟题看起来不是很难,但是拿全分数还是比较难,得多考虑几种情况.</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://example.org/tags/program/">Program</a></li>
      <li><a href="http://example.org/tags/homework/">homework</a></li>
    </ul>
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="http://example.org/">My New Hugo Site</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
