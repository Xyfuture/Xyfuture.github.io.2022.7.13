<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Program-week4-homework | My New Hugo Site</title>

<meta name="keywords" content="Program, homework" />
<meta name="description" content="week3-CSP A-咕咕东的奇遇 题意 该题算是一个贪心问题,在一个环(26个数)上布置有序的数字,环上有一个指针,然后给定一个数字序列,要求转动圆环,使得指针指向给定的数字,要求总的转动的次数最少.题目中的不是数字而是字母,不过无所谓,ascii直接转换就行
解法 我们使用贪心的方案,每一次都找到从当前位置到指定位置的最短路径,最短路径只有两种可能,顺时针转过去或者逆时针转过去.在环上本身就是mod26系统,因此让大数减小数是一种,小数加26减大数是另一种,那个小取那个
code #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std; int main() { char s [10002];//数组开大 	memset(s,0,sizeof(s)); scanf(&#34;%s&#34;,s); int count=0;//总和 	int i = 0; char temp; int posi = 0; int maxShift = 0; while((temp=s[i])!=&#39;\0&#39;)//判断截止 	{ int cur = temp-&#39;a&#39;; if(cur&gt;posi) { int left = cur- posi;//一种方向 	int right = posi&#43;26 -cur;//另一种方向 	count&#43;=(left&gt;right? right:left);//取最小 	} if(cur&lt;=posi) { int left = cur&#43;26 - posi; int right = posi-cur; count&#43;= (left&gt;right?">
<meta name="author" content="">
<link rel="canonical" href="http://example.org/posts/program-week4-homework/" />
<link href="/assets/css/stylesheet.min.5c4f6d85b7abfcfea458637c672d16a7a9c38c37f002753cfdc7f314b6d3c8f2.css" integrity="sha256-XE9thber/P6kWGN8Zy0Wp6nDjDfwAnU8/cfzFLbTyPI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="http://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="http://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />


<meta property="og:title" content="Program-week4-homework" />
<meta property="og:description" content="week3-CSP A-咕咕东的奇遇 题意 该题算是一个贪心问题,在一个环(26个数)上布置有序的数字,环上有一个指针,然后给定一个数字序列,要求转动圆环,使得指针指向给定的数字,要求总的转动的次数最少.题目中的不是数字而是字母,不过无所谓,ascii直接转换就行
解法 我们使用贪心的方案,每一次都找到从当前位置到指定位置的最短路径,最短路径只有两种可能,顺时针转过去或者逆时针转过去.在环上本身就是mod26系统,因此让大数减小数是一种,小数加26减大数是另一种,那个小取那个
code #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std; int main() { char s [10002];//数组开大 	memset(s,0,sizeof(s)); scanf(&#34;%s&#34;,s); int count=0;//总和 	int i = 0; char temp; int posi = 0; int maxShift = 0; while((temp=s[i])!=&#39;\0&#39;)//判断截止 	{ int cur = temp-&#39;a&#39;; if(cur&gt;posi) { int left = cur- posi;//一种方向 	int right = posi&#43;26 -cur;//另一种方向 	count&#43;=(left&gt;right? right:left);//取最小 	} if(cur&lt;=posi) { int left = cur&#43;26 - posi; int right = posi-cur; count&#43;= (left&gt;right?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/program-week4-homework/" />
<meta property="article:published_time" content="2020-03-15T11:06:08+00:00" />
<meta property="article:modified_time" content="2020-03-15T11:06:08+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Program-week4-homework"/>
<meta name="twitter:description" content="week3-CSP A-咕咕东的奇遇 题意 该题算是一个贪心问题,在一个环(26个数)上布置有序的数字,环上有一个指针,然后给定一个数字序列,要求转动圆环,使得指针指向给定的数字,要求总的转动的次数最少.题目中的不是数字而是字母,不过无所谓,ascii直接转换就行
解法 我们使用贪心的方案,每一次都找到从当前位置到指定位置的最短路径,最短路径只有两种可能,顺时针转过去或者逆时针转过去.在环上本身就是mod26系统,因此让大数减小数是一种,小数加26减大数是另一种,那个小取那个
code #include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std; int main() { char s [10002];//数组开大 	memset(s,0,sizeof(s)); scanf(&#34;%s&#34;,s); int count=0;//总和 	int i = 0; char temp; int posi = 0; int maxShift = 0; while((temp=s[i])!=&#39;\0&#39;)//判断截止 	{ int cur = temp-&#39;a&#39;; if(cur&gt;posi) { int left = cur- posi;//一种方向 	int right = posi&#43;26 -cur;//另一种方向 	count&#43;=(left&gt;right? right:left);//取最小 	} if(cur&lt;=posi) { int left = cur&#43;26 - posi; int right = posi-cur; count&#43;= (left&gt;right?"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Program-week4-homework",
  "name": "Program-week4-homework",
  "description": "week3-CSP A-咕咕东的奇遇 题意 该题算是一个贪心问题,在一个环(26个数)上布置有序的数字,环上有一个指针,然后给定一个数字序列,要求转动圆环,使得指针指向给定的数字,要求总的转动的次数最少.题目中的不是数字而是字母,不过无所谓,ascii直接转换就行\n解法 我们使用贪心的方案,每一次都找到从当前位置到指定位置的最短路径,最短路径只有两种可能,顺 …",
  "keywords": [
    "Program", "homework"
  ],
  "articleBody": "week3-CSP A-咕咕东的奇遇 题意 该题算是一个贪心问题,在一个环(26个数)上布置有序的数字,环上有一个指针,然后给定一个数字序列,要求转动圆环,使得指针指向给定的数字,要求总的转动的次数最少.题目中的不是数字而是字母,不过无所谓,ascii直接转换就行\n解法 我们使用贪心的方案,每一次都找到从当前位置到指定位置的最短路径,最短路径只有两种可能,顺时针转过去或者逆时针转过去.在环上本身就是mod26系统,因此让大数减小数是一种,小数加26减大数是另一种,那个小取那个\ncode #include #include #include #include #include using namespace std; int main() { char s [10002];//数组开大 \tmemset(s,0,sizeof(s)); scanf(\"%s\",s); int count=0;//总和 \tint i = 0; char temp; int posi = 0; int maxShift = 0; while((temp=s[i])!='\\0')//判断截止 \t{ int cur = temp-'a'; if(curposi) { int left = cur- posi;//一种方向 \tint right = posi+26 -cur;//另一种方向 \tcount+=(leftright? right:left);//取最小 \t} if(curposi) { int left = cur+26 - posi; int right = posi-cur; count+= (leftright? right:left); } posi = cur; i++; } printf(\"%d\\n\",count);\treturn 0; } 总结 这道题比较简单,主要就是提升速度,这道题大约耗费了20min,争取减少到10min左右\nB-咕咕东想吃饭 题意 这道题算是一道模拟.\n有人在n天时间内都吃东西,每天买多少个是给出的,但是卖东西的用两种策略,一个是1次卖2个.另一种是今天卖一个,明天送一个.这个人的目的是n天结束后不能有剩下的东西,也就是说最后一天不能用第二个策略,问问在给定情况下能不能实现不剩东西.\n解法  这道题我是按照模拟题做的,然后过了,不过当时没有给出有效的证明,还是有点险\n 购买的策略,首先两个两个的买,直到当天剩下一个或者没有,剩下的一个用第二种策略,买完了要在第二天减去一个.一直这样循环下去,检查退出的时候是否还要减去第二天的哪一个.如果还需要就是就不行,否则可行,除此之外如果有一天买的比昨天送的还少也不行.\n简略证明 假设我们有一个能完成任务的方法,我们可以将其转换为上述提出的方法,比如当天k个1策略,m个2策略,我们只关注2策略,m是偶数,则可以直接用1策略代替,如果m是奇数,则m-1是偶数,我们用1策略替代m-1个2策略,剩下的一个2策略保持,这样就成了上述的方法\ncode #include #include using namespace std; int data [100005];//存第i天的量 int main() { memset (data,0,sizeof(data)); int n; scanf(\"%d\",\u0026n); for(int i=0;in;i++) scanf(\"%d\",data+i); int ticket = 0;//送的那一个 \tint curSize= 0;//今天实际的量,减去昨天送的 \tfor(int i=0;in;i++) { curSize = data[i] -ticket; if(curSize0)//如果今天买的比送的还少也不行 \t{ printf(\"NO\\n\"); return 0; } if(curSize%2 == 0) ticket =0 ; else ticket = 1; } if(ticket == 0)//还有送的就不行 \tprintf(\"YES\\n\"); else printf(\"NO\\n\"); }\t总结 这道题大约花了30min,主要的难点我觉得还是证明上,不过赛场上还是没能严格的证出来,只是感觉差不多了,有时候也只能这样,感觉个差不多就交一发,做做后面的题在回来看看.这道题的证明和贪心类似,都是转化最优而来,这种证法还会用在很多的地方\nC-可怕的宇宙射线  比较难\n 题意 粗看是一道模拟题,但是不能纯模拟,得用bfs标记解决\n题意大致是光线分裂,一条光线在坐标系下按照指定步数移动几步,然后分裂为2,左右45°方向,然后继续走指定步数,再次分裂为4….最后问光线一共占据多少个坐标\n解法 这道题一上来我就傻傻的写了最简单的模拟,把$2^n$的情况全模拟了,而且因为语法上的问题,负数不能取模,最终差了1min没有交上.不过即便交上了也就能过1,2个点那不全分.\n正确做法: 单纯模拟bfs的复杂度是$2^n$,显然是不对的,因此在bfs上进行优化,这里的剪枝的方式是用vis数组进行标记 我们开一个vis数组bool vis[x][y][8][32]8代表8个方向,32代表最多30次分裂 我们开一个队列,将起始点放进去,在取队列中一个节点,然后我们让光线从起始开始直接走完分裂前的路程,同时标记走过的点,计数走过的点,然后进行分裂,获得到分裂后新的光线的起始坐标,把这个坐标用vis记录,同时包含他的方向和分裂层数,这样就能避免重复走一样的分裂路线,如果这个点没被走过就放入队列.开始循环直到队空\n这个题最终的复杂度应该是vis数组的大小,因为全访问过一次后就不在重复访问了\ncode #include #include #include #include #include #include using namespace std; bool vis [400][400][8][35];//bfs中剪枝 bool posi [400][400];//标记走过的点  struct moves//记录每次分裂的起始点的位置 { int x; int y; int level;//第几层  int angle;//方向 }; int change[8][2]= { {0,1}, {1,1}, {1,0},{1,-1},{0,-1},{-1,-1},{-1,0},{-1,1} };//不同方向 移动的数组  queuemoves q; int main() { long long count=0; int moveData [40];//存储第几层需要移动几次 \tint n; scanf(\"%d\",\u0026n); memset(moveData,0,sizeof(moveData)); memset(posi,0,sizeof(posi)); memset(vis,0,sizeof(vis)); for(int i=0;in;i++) scanf(\"%d\",moveData+i); moves firstNode = {200,200,0,0}; q.push(firstNode); vis[200][200][0][0]= true;//起始点0,0标记  while(!q.empty()) { moves curPoint = q.front(); int x = curPoint.x,y=curPoint.y,angle = curPoint.angle; q.pop(); for(int i=0;imoveData[curPoint.level];i++)//从起始点直接到分裂位置,一次完成一层  { if(posi[x+change[angle][0]*i][y+change[angle][1]*i] == false)//路过的点没被标记则计数增加  { count ++; posi[x+change[angle][0]*i][y+change[angle][1]*i] = true; } } int angle1=(curPoint.angle+1)%8;//新的点的两个角度  int angle2=(curPoint.angle+7)%8; int i = moveData[curPoint.level] - 1;//到达最后的层就不在继续了  if (curPoint.level == n-1) continue; moves newPoint1 = {x+change[angle][0]*i+change[angle1][0],y+change[angle1][1]+change[angle][1]*i, curPoint.level+1,angle1};//分裂后的起始点  moves newPoint2 = {x+change[angle2][0]+change[angle][0]*i,y+change[angle2][1]+change[angle][1]*i, curPoint.level+1,angle2}; if (vis[newPoint1.x][newPoint1.y][newPoint1.level][newPoint1.angle] == false)//标记了就不走了,没标记就入队走一遍  { q.push(newPoint1); vis[newPoint1.x][newPoint1.y][newPoint1.level][newPoint1.angle] = true; } if (vis[newPoint2.x][newPoint2.y][newPoint2.level][newPoint2.angle] == false) { q.push(newPoint2); vis[newPoint2.x][newPoint2.y][newPoint2.level][newPoint2.angle] = true; } } printf(\"%d\\n\",count); } 总结 这道题在赛场上没有做出来,赛上想的太简单了,直接忽略了指数增加的问题\nbfs在使用时也得注意剪枝的情况,想这道题一次就直接剪枝一半,极大降低复杂度,最大的复杂度就是遍历一遍vis数组$O(xyn)$x,y是坐标系的大小,n是步数,还有个常数8忽略了,因为全被标记后就不可能再入队了,直接退出了.\nweek4-homework A-DDL的恐惧 题意 有一组任务,有每个任务超时的惩罚,还有每个任务的ddl,求最少的惩罚是多少\n解法 这道题是贪心问题,助教在课上讲的是按时完成的奖励,这里是超时的惩罚,思路是差不多的.首先按照超时惩罚排序,得到降序序列,然后将惩罚最大的先安排在能安排的离ddl最近的位置,将这个位置标记,然后循环取出,没有可安排的时间则计入惩罚.\ncode #include #include #include  using namespace std; int time[2000];//时间记录 pairint,int task[1002];//first是惩罚,second是ddl int main() { int count; // int ddl[1002],score[1002];  scanf(\"%d\",\u0026count); for (int i = 0; i  count; i++) { int n; int score = 0; memset(task,0,sizeof(task)); memset(time,0,sizeof(time)); scanf(\"%d\",\u0026n); for(int j=0;jn;j++) scanf(\"%d\",\u0026task[j].second); for(int j=0;jn;j++) scanf(\"%d\",\u0026task[j].first); sort(task,task+n);//排序,这里是升序,因此反着循环  for(int j=n-1;j=0;j--) { int t = task[j].second; for(t;t0;t--)//找一个时间安排任务  if(time[t] == 0) { time[t] = 1; break; } if(t == 0)//无法安排则计入惩罚  score+=task[j].first; } printf(\"%d\\n\",score); } } 总结 贪心问题,证明方法还是常用等效转换的方式,证明其和最优解是等价的.\nB-四个数列 题意 有四个等长的数列,然后从这四个数列中各自取一个数,使其和为0,求问有多少种可能取法\n解法 这是道二分的问题,课上已经讲过了.\n如果直接暴力是$O(n^4)$,肯定是不行的,然后进行分组,两个数列一组,先$O(n^2)$让组内组合,然后确定一个组,在另一个组内二分找答案\n注意这个二分是找起始位置和结束位置,因为可能有多个相同的值,都是一种可能\n总的复杂度就是$O(n^2logn)$\ncode #include #include #include #include  using namespace std; int data[4][4002]; int ans1[16000002]; int ans2[16000002]; int main() { memset(data,0,sizeof(data)); memset(ans1,0,sizeof(ans1)); memset(ans2,0,sizeof(ans2)); int count = 0; int n; scanf(\"%d\",\u0026n); for (int i=0;in;i++)//读入  for (int j=0;j4;j++) scanf(\"%d\",\u0026data[j][i]); for(int i=0;in;i++)//计算两组的加和  for(int j=0;jn;j++) ans1[i*n+j] = data[0][i]+data[1][j]; for(int i=0;in;i++) for(int j=0;jn;j++) ans2[i*n+j] = data[2][i]+data[3][j]; int t = n*n; int min = 0,max =t; sort(ans1,ans1+t); sort(ans2,ans2+t); for(int i=0;it;i++)//n^2的循环  { int target = -ans1[i]; int left = 0,right = t-1; while(leftright)//二分找到起始点  { int middle = (right+left)/2; if(ans2[middle] = target) { min = middle; right = middle - 1; } else left = middle+1; } if (ans2[min]!=target) continue; left = 0; right = t-1; while(leftright)//二分找到终点  { int middle = (right+left)/2; if(ans2[middle]target) { max = middle; left = middle+1; } else { right = middle-1; } } count+=max-min+1; } printf(\"%d\",count); } 总结 二分用来找东西方便,但是一定要有序,记得sort\nC- TT的神秘礼物 题意 给定一个含n个元素的数组A,运用A数组生成一个B数组,B中的元素为abs(A[i] - A[j])，1 解法 这道题也是课上讲过的,核心思路是二分,而且是两个二分.\n首先我们求中位数必然是在一个有序数列中,满足二分的条件,首先对a排序,因为构造b的时候有abs,因此不影响中位数,然后找出b的最小值0(注意这里的最小值是0不是a[1]-a[0]),和最大值a[n-1]-a[0],让这两个最为边界进行二分,获得中间值mid.之后判断mid与中位数的情况,这里的判断是计算mid的名次,计算b中第一个大于mid的数前面有几个数,因为中位数的名次是知道的$(n*(n-1)/4+1)$.如果大于等于中位数则让max=mid,否则min=mid+1,然后这样循环下去直到max如何求mid是第几个数成了新的问题,这里的解决方法还是二分,因为b中的元素是abs(A[i] - A[j]),则固定一个i,通过二分寻找第一个a[j]-a[i]大于mid的j,然后我们对i进行一次遍历就得到了mid是第几个元素,和给定的中位数名次比较就能操作max和min了.\n严谨一些的证明 上述的描述虽然给出了解题的思路但是还没有给出一个比较严谨的证明.\n对于第二部分二分来查找名次就不过多进行描述了,这就是最简单的那种二分,找一个端点,但是第一部分直接二分出答案还是需要稍微证明一下.\n首先中位数的名次是固定的,但是和中位数相等的数可能有多个,同时在二分中会出现b中没有的数,下面讨论一下啊是如何准确二分到准确的答案的.\n上图中x是中位数实际的值,还有一些二分出来的在b中不存在但是和x同名次的数.因为查找排名的原因,实际的x排名是大于中位数的排名的,因此存在一个问题,永远不会有mid名次就是中位数名次的事情.但是在二分中,我们是在mid=中位数时,更新max和ans(最终的答案),否则更新min,那么min (因为x位置大于中位数,然后mid=x更新max,比x小的一个数名次小于中位数,min会变大),max=x(这个情况是对于mid未等于x前),这样一直迭代下去无论怎么更新都是满足上述条件的,最终max和min会向x靠近,最终max=min = x然后下一步max会小于min退出循环,最终ans必然等于x.不存在的数在右边,mid是向左边靠的,所以ans不会等于不存在的数.\n后来又想了一下,还是学长上课讲的方法比较简单,我们提供一个check()函数,这个函数返回0或1,0代表mid名次小于中位数,1代表mid名次大于等于中位数名次,这样在0,1交界的位置的1就是我们要找的中位数,不存在的那些数虽然也是1,但是都是在中位数后面,不在交界位置\n复杂度 最终的复杂度也是比较高的,check()函数的复杂度是$O(nlogn)$,在外面的那层二分的复杂度是$O(logB_{max})$,两者相乘是$O(nlogn\\ logB_{max})$,因为数据范围比较大,读入需要用scanf\ncode #include #include #include #include using namespace std; int cat[100002]; inline int check(int cur,int tar,int n)//排名,tar是中位数名次,cur是mid的值 { int s=0,e=0; for(int i=0;in;i++) { int left =i+1,right= n-1; while(leftright)//二分找排名  { int mid = (left+right)/2; if(cur=(cat[mid]-cat[i])) left = mid+1; else right = mid-1; } e += left-i-1; } if(e=tar)//大于等于返回1  return 1; else//小于返回0  return 0; } int main() { int n; while(scanf(\"%d\",\u0026n)!=EOF) { for (int i = 0; i  n; i++) scanf(\"%d\",cat+i); sort(cat,cat+n); int min = 0;//最小值  int max = cat[n-1] - cat[0]; int mid = (min+max)/2; int target = (((n*(n-1))/2)+1)/2;//中位数位置  int ans = 0; while(maxmin)//结束条件  { mid = (min+max)/2; if(check(mid,target,n)) ans = mid,max = mid;//max不能减1因为退出条件是max else min = mid+1; } printf(\"%d\\n\",ans); } } 总结 这道题我觉得出的非常好,让我对二分有了更深刻的理解,二分的left和right始终在一个条件附近徘徊,最终逼近这个答案,当leftright退出时ans就满足了条件了.\n",
  "wordCount" : "675",
  "inLanguage": "en",
  "datePublished": "2020-03-15T11:06:08Z",
  "dateModified": "2020-03-15T11:06:08Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://example.org/posts/program-week4-homework/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "http://example.org/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://example.org/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()"></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Program-week4-homework
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">March 15, 2020

    </div>
  </header> 

  <div class="post-content">
<h1 id="week3-csp">week3-CSP<a hidden class="anchor" aria-hidden="true" href="#week3-csp">#</a></h1>
<h2 id="a-咕咕东的奇遇">A-咕咕东的奇遇<a hidden class="anchor" aria-hidden="true" href="#a-咕咕东的奇遇">#</a></h2>
<h3 id="题意">题意<a hidden class="anchor" aria-hidden="true" href="#题意">#</a></h3>
<p>该题算是一个贪心问题,在一个环(26个数)上布置有序的数字,环上有一个指针,然后给定一个数字序列,要求转动圆环,使得指针指向给定的数字,要求总的转动的次数最少.题目中的不是数字而是字母,不过无所谓,ascii直接转换就行</p>
<h3 id="解法">解法<a hidden class="anchor" aria-hidden="true" href="#解法">#</a></h3>
<p>我们使用贪心的方案,每一次都找到从当前位置到指定位置的最短路径,最短路径只有两种可能,顺时针转过去或者逆时针转过去.在环上本身就是mod26系统,因此让<strong>大数减小数</strong>是一种,<strong>小数加26减大数</strong>是另一种,那个小取那个</p>
<h3 id="code">code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">char</span> s [<span style="color:#ae81ff">10002</span>];<span style="color:#75715e">//数组开大
</span><span style="color:#75715e"></span>	memset(s,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(s));
	scanf(<span style="color:#e6db74">&#34;%s&#34;</span>,s);
	<span style="color:#66d9ef">int</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;<span style="color:#75715e">//总和
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">char</span> temp;
	<span style="color:#66d9ef">int</span> posi <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> maxShift <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">while</span>((temp<span style="color:#f92672">=</span>s[i])<span style="color:#f92672">!=</span><span style="color:#e6db74">&#39;\0&#39;</span>)<span style="color:#75715e">//判断截止
</span><span style="color:#75715e"></span>	{
		<span style="color:#66d9ef">int</span> cur <span style="color:#f92672">=</span> temp<span style="color:#f92672">-</span><span style="color:#e6db74">&#39;a&#39;</span>;
		<span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">&gt;</span>posi)
		{
			<span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> cur<span style="color:#f92672">-</span> posi;<span style="color:#75715e">//一种方向
</span><span style="color:#75715e"></span>			<span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> posi<span style="color:#f92672">+</span><span style="color:#ae81ff">26</span> <span style="color:#f92672">-</span>cur;<span style="color:#75715e">//另一种方向
</span><span style="color:#75715e"></span>			count<span style="color:#f92672">+=</span>(left<span style="color:#f92672">&gt;</span>right<span style="color:#f92672">?</span> right:left);<span style="color:#75715e">//取最小
</span><span style="color:#75715e"></span>		}
		<span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">&lt;=</span>posi)
		{
			<span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> cur<span style="color:#f92672">+</span><span style="color:#ae81ff">26</span> <span style="color:#f92672">-</span> posi;
			<span style="color:#66d9ef">int</span> right <span style="color:#f92672">=</span> posi<span style="color:#f92672">-</span>cur;
			count<span style="color:#f92672">+=</span> (left<span style="color:#f92672">&gt;</span>right<span style="color:#f92672">?</span> right:left);
		}
		posi <span style="color:#f92672">=</span> cur;
		i<span style="color:#f92672">++</span>;
	}
	printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,count);	
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>这道题比较简单,主要就是提升速度,这道题大约耗费了20min,争取减少到10min左右</p>
<h2 id="b-咕咕东想吃饭">B-咕咕东想吃饭<a hidden class="anchor" aria-hidden="true" href="#b-咕咕东想吃饭">#</a></h2>
<h3 id="题意-1">题意<a hidden class="anchor" aria-hidden="true" href="#题意-1">#</a></h3>
<p>这道题算是一道模拟.</p>
<p>有人在n天时间内都吃东西,每天买多少个是给出的,但是卖东西的用两种策略,一个是1次卖2个.另一种是今天卖一个,明天送一个.这个人的目的是n天结束后不能有剩下的东西,也就是说最后一天不能用第二个策略,问问在给定情况下能不能实现不剩东西.</p>
<h3 id="解法-1">解法<a hidden class="anchor" aria-hidden="true" href="#解法-1">#</a></h3>
<blockquote>
<p>这道题我是按照模拟题做的,然后过了,不过当时没有给出有效的证明,还是有点险</p>
</blockquote>
<p>购买的策略,首先两个两个的买,直到当天剩下一个或者没有,剩下的一个用第二种策略,买完了要在第二天减去一个.一直这样循环下去,检查退出的时候是否还要减去第二天的哪一个.如果还需要就是就不行,否则可行,除此之外如果有一天买的比昨天送的还少也不行.</p>
<h4 id="简略证明">简略证明<a hidden class="anchor" aria-hidden="true" href="#简略证明">#</a></h4>
<p>假设我们有一个能完成任务的方法,我们可以将其转换为上述提出的方法,比如当天k个1策略,m个2策略,我们只关注2策略,m是偶数,则可以直接用1策略代替,如果m是奇数,则m-1是偶数,我们用1策略替代m-1个2策略,剩下的一个2策略保持,这样就成了上述的方法</p>
<h3 id="code-1">code<a hidden class="anchor" aria-hidden="true" href="#code-1">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> data [<span style="color:#ae81ff">100005</span>];<span style="color:#75715e">//存第i天的量
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	memset (data,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(data));
	<span style="color:#66d9ef">int</span> n;
	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
		scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,data<span style="color:#f92672">+</span>i);
	
	<span style="color:#66d9ef">int</span> ticket <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//送的那一个
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> curSize<span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//今天实际的量,减去昨天送的
</span><span style="color:#75715e"></span>	
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
	{
		curSize <span style="color:#f92672">=</span> data[i] <span style="color:#f92672">-</span>ticket;
		<span style="color:#66d9ef">if</span>(curSize<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>)<span style="color:#75715e">//如果今天买的比送的还少也不行
</span><span style="color:#75715e"></span>		{
			printf(<span style="color:#e6db74">&#34;NO</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
			<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
		}
		<span style="color:#66d9ef">if</span>(curSize<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
			ticket <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span> ;
		<span style="color:#66d9ef">else</span>
			ticket <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	}
	<span style="color:#66d9ef">if</span>(ticket <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//还有送的就不行
</span><span style="color:#75715e"></span>		printf(<span style="color:#e6db74">&#34;YES</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
	<span style="color:#66d9ef">else</span>
		printf(<span style="color:#e6db74">&#34;NO</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
}	
</code></pre></div><h3 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h3>
<p>这道题大约花了30min,主要的难点我觉得还是证明上,不过赛场上还是没能严格的证出来,只是感觉差不多了,有时候也只能这样,感觉个差不多就交一发,做做后面的题在回来看看.这道题的证明和贪心类似,都是转化最优而来,这种证法还会用在很多的地方</p>
<h2 id="c-可怕的宇宙射线">C-可怕的宇宙射线<a hidden class="anchor" aria-hidden="true" href="#c-可怕的宇宙射线">#</a></h2>
<blockquote>
<p>比较难</p>
</blockquote>
<h3 id="题意-2">题意<a hidden class="anchor" aria-hidden="true" href="#题意-2">#</a></h3>
<p>粗看是一道模拟题,但是不能纯模拟,得用bfs标记解决</p>
<p>题意大致是光线分裂,一条光线在坐标系下按照指定步数移动几步,然后分裂为2,左右45°方向,然后继续走指定步数,再次分裂为4&hellip;.最后问光线一共占据多少个坐标</p>
<h3 id="解法-2">解法<a hidden class="anchor" aria-hidden="true" href="#解法-2">#</a></h3>
<p>这道题一上来我就傻傻的写了最简单的模拟,把$2^n$的情况全模拟了,而且因为语法上的问题,负数不能取模,最终差了1min没有交上.不过即便交上了也就能过1,2个点那不全分.</p>
<p>正确做法:
单纯模拟bfs的复杂度是$2^n$,显然是不对的,因此在bfs上进行优化,这里的剪枝的方式是用vis数组进行标记
我们开一个vis数组<code>bool vis[x][y][8][32]</code>8代表8个方向,32代表最多30次分裂
我们开一个队列,将起始点放进去,在取队列中一个节点,然后我们让光线从起始开始直接走完分裂前的路程,同时标记走过的点,计数走过的点,然后进行分裂,获得到分裂后新的光线的起始坐标,把这个坐标用vis记录,同时包含他的方向和分裂层数,这样就能避免重复走一样的分裂路线,如果这个点没被走过就放入队列.开始循环直到队空</p>
<p>这个题最终的复杂度应该是vis数组的大小,因为全访问过一次后就不在重复访问了</p>
<h3 id="code-2">code<a hidden class="anchor" aria-hidden="true" href="#code-2">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;unordered_map&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">bool</span> vis [<span style="color:#ae81ff">400</span>][<span style="color:#ae81ff">400</span>][<span style="color:#ae81ff">8</span>][<span style="color:#ae81ff">35</span>];<span style="color:#75715e">//bfs中剪枝
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> posi [<span style="color:#ae81ff">400</span>][<span style="color:#ae81ff">400</span>];<span style="color:#75715e">//标记走过的点
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">moves</span><span style="color:#75715e">//记录每次分裂的起始点的位置
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> x;
    <span style="color:#66d9ef">int</span> y;
    <span style="color:#66d9ef">int</span> level;<span style="color:#75715e">//第几层
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> angle;<span style="color:#75715e">//方向
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">int</span> change[<span style="color:#ae81ff">8</span>][<span style="color:#ae81ff">2</span>]<span style="color:#f92672">=</span>
{
	{<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">1</span>},
	{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>},
	{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>},{<span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>},{<span style="color:#ae81ff">0</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>},{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>},{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">0</span>},{<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>}
};<span style="color:#75715e">//不同方向 移动的数组
</span><span style="color:#75715e"></span>
queue<span style="color:#f92672">&lt;</span>moves<span style="color:#f92672">&gt;</span> q;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> count<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> moveData [<span style="color:#ae81ff">40</span>];<span style="color:#75715e">//存储第几层需要移动几次
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> n;
	scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
	memset(moveData,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(moveData));
    memset(posi,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(posi));
    memset(vis,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(vis));
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
		scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,moveData<span style="color:#f92672">+</span>i);
    moves firstNode <span style="color:#f92672">=</span> {<span style="color:#ae81ff">200</span>,<span style="color:#ae81ff">200</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>};
    q.push(firstNode);
    vis[<span style="color:#ae81ff">200</span>][<span style="color:#ae81ff">200</span>][<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">=</span> true;<span style="color:#75715e">//起始点0,0标记
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty())
    {
        moves curPoint <span style="color:#f92672">=</span> q.front();
        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> curPoint.x,y<span style="color:#f92672">=</span>curPoint.y,angle <span style="color:#f92672">=</span> curPoint.angle;
        q.pop();
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>moveData[curPoint.level];i<span style="color:#f92672">++</span>)<span style="color:#75715e">//从起始点直接到分裂位置,一次完成一层
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">if</span>(posi[x<span style="color:#f92672">+</span>change[angle][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>i][y<span style="color:#f92672">+</span>change[angle][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>i] <span style="color:#f92672">==</span> false)<span style="color:#75715e">//路过的点没被标记则计数增加
</span><span style="color:#75715e"></span>            {
                count <span style="color:#f92672">++</span>;
                posi[x<span style="color:#f92672">+</span>change[angle][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>i][y<span style="color:#f92672">+</span>change[angle][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>i] <span style="color:#f92672">=</span> true;
            }
        }
        <span style="color:#66d9ef">int</span> angle1<span style="color:#f92672">=</span>(curPoint.angle<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span><span style="color:#ae81ff">8</span>;<span style="color:#75715e">//新的点的两个角度
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> angle2<span style="color:#f92672">=</span>(curPoint.angle<span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>)<span style="color:#f92672">%</span><span style="color:#ae81ff">8</span>;
        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> moveData[curPoint.level] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//到达最后的层就不在继续了
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (curPoint.level <span style="color:#f92672">==</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
            <span style="color:#66d9ef">continue</span>;
        moves newPoint1 <span style="color:#f92672">=</span> {x<span style="color:#f92672">+</span>change[angle][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>i<span style="color:#f92672">+</span>change[angle1][<span style="color:#ae81ff">0</span>],y<span style="color:#f92672">+</span>change[angle1][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>change[angle][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>i,
                    curPoint.level<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,angle1};<span style="color:#75715e">//分裂后的起始点
</span><span style="color:#75715e"></span>        moves newPoint2 <span style="color:#f92672">=</span> {x<span style="color:#f92672">+</span>change[angle2][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">+</span>change[angle][<span style="color:#ae81ff">0</span>]<span style="color:#f92672">*</span>i,y<span style="color:#f92672">+</span>change[angle2][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>change[angle][<span style="color:#ae81ff">1</span>]<span style="color:#f92672">*</span>i,
                    curPoint.level<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,angle2};
        <span style="color:#66d9ef">if</span> (vis[newPoint1.x][newPoint1.y][newPoint1.level][newPoint1.angle] <span style="color:#f92672">==</span> false)<span style="color:#75715e">//标记了就不走了,没标记就入队走一遍
</span><span style="color:#75715e"></span>        {
            q.push(newPoint1);
            vis[newPoint1.x][newPoint1.y][newPoint1.level][newPoint1.angle] <span style="color:#f92672">=</span> true;
        }
        <span style="color:#66d9ef">if</span> (vis[newPoint2.x][newPoint2.y][newPoint2.level][newPoint2.angle] <span style="color:#f92672">==</span> false)
        {
            q.push(newPoint2);
            vis[newPoint2.x][newPoint2.y][newPoint2.level][newPoint2.angle] <span style="color:#f92672">=</span> true;
        }
    }
    printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,count);
}

</code></pre></div><h3 id="总结-2">总结<a hidden class="anchor" aria-hidden="true" href="#总结-2">#</a></h3>
<p>这道题在赛场上没有做出来,赛上想的太简单了,直接忽略了指数增加的问题</p>
<p>bfs在使用时也得注意剪枝的情况,想这道题一次就直接剪枝一半,极大降低复杂度,最大的复杂度就是遍历一遍vis数组$O(x<em>y</em>n)$x,y是坐标系的大小,n是步数,还有个常数8忽略了,因为全被标记后就不可能再入队了,直接退出了.</p>
<h1 id="week4-homework">week4-homework<a hidden class="anchor" aria-hidden="true" href="#week4-homework">#</a></h1>
<h2 id="a-ddl的恐惧">A-DDL的恐惧<a hidden class="anchor" aria-hidden="true" href="#a-ddl的恐惧">#</a></h2>
<h3 id="题意-3">题意<a hidden class="anchor" aria-hidden="true" href="#题意-3">#</a></h3>
<p>有一组任务,有每个任务超时的惩罚,还有每个任务的ddl,求最少的惩罚是多少</p>
<h3 id="解法-3">解法<a hidden class="anchor" aria-hidden="true" href="#解法-3">#</a></h3>
<p>这道题是贪心问题,助教在课上讲的是按时完成的奖励,这里是超时的惩罚,思路是差不多的.首先按照超时惩罚排序,得到降序序列,然后将惩罚最大的先安排在能安排的离ddl最近的位置,将这个位置标记,然后循环取出,没有可安排的时间则计入惩罚.</p>
<h3 id="code-3">code<a hidden class="anchor" aria-hidden="true" href="#code-3">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> time[<span style="color:#ae81ff">2000</span>];<span style="color:#75715e">//时间记录
</span><span style="color:#75715e"></span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> task[<span style="color:#ae81ff">1002</span>];<span style="color:#75715e">//first是惩罚,second是ddl
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> count;
    <span style="color:#75715e">// int ddl[1002],score[1002];
</span><span style="color:#75715e"></span>    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>count);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> count; i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">int</span> n;
        <span style="color:#66d9ef">int</span> score <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        memset(task,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(task));
        memset(time,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(time));
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>n;j<span style="color:#f92672">++</span>)
            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>task[j].second);
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>n;j<span style="color:#f92672">++</span>)
            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>task[j].first);
        sort(task,task<span style="color:#f92672">+</span>n);<span style="color:#75715e">//排序,这里是升序,因此反着循环
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">--</span>)
        {
            <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> task[j].second;
            <span style="color:#66d9ef">for</span>(t;t<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>;t<span style="color:#f92672">--</span>)<span style="color:#75715e">//找一个时间安排任务
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span>(time[t] <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
                {
                    time[t] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                    <span style="color:#66d9ef">break</span>;
                }
            <span style="color:#66d9ef">if</span>(t <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)<span style="color:#75715e">//无法安排则计入惩罚
</span><span style="color:#75715e"></span>                score<span style="color:#f92672">+=</span>task[j].first;
        }
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,score);
    }   
}
</code></pre></div><h3 id="总结-3">总结<a hidden class="anchor" aria-hidden="true" href="#总结-3">#</a></h3>
<p>贪心问题,证明方法还是常用等效转换的方式,证明其和最优解是等价的.</p>
<h2 id="b-四个数列">B-四个数列<a hidden class="anchor" aria-hidden="true" href="#b-四个数列">#</a></h2>
<h3 id="题意-4">题意<a hidden class="anchor" aria-hidden="true" href="#题意-4">#</a></h3>
<p>有四个等长的数列,然后从这四个数列中各自取一个数,使其和为0,求问有多少种可能取法</p>
<h3 id="解法-4">解法<a hidden class="anchor" aria-hidden="true" href="#解法-4">#</a></h3>
<p>这是道二分的问题,课上已经讲过了.</p>
<p>如果直接暴力是$O(n^4)$,肯定是不行的,然后进行分组,两个数列一组,先$O(n^2)$让组内组合,然后确定一个组,在另一个组内二分找答案</p>
<p>注意这个二分是找起始位置和结束位置,因为可能有多个相同的值,都是一种可能</p>
<p>总的复杂度就是$O(n^2logn)$</p>
<h3 id="code-4">code<a hidden class="anchor" aria-hidden="true" href="#code-4">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> data[<span style="color:#ae81ff">4</span>][<span style="color:#ae81ff">4002</span>];

<span style="color:#66d9ef">int</span> ans1[<span style="color:#ae81ff">16000002</span>];
<span style="color:#66d9ef">int</span> ans2[<span style="color:#ae81ff">16000002</span>];
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    memset(data,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(data));
    memset(ans1,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(ans1));
    memset(ans2,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(ans2));
    <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">int</span> n;
    scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//读入
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>;j<span style="color:#f92672">++</span>)
            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>data[j][i]);
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//计算两组的加和
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>n;j<span style="color:#f92672">++</span>)
            ans1[i<span style="color:#f92672">*</span>n<span style="color:#f92672">+</span>j] <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">0</span>][i]<span style="color:#f92672">+</span>data[<span style="color:#ae81ff">1</span>][j];
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">&lt;</span>n;j<span style="color:#f92672">++</span>)
            ans2[i<span style="color:#f92672">*</span>n<span style="color:#f92672">+</span>j] <span style="color:#f92672">=</span> data[<span style="color:#ae81ff">2</span>][i]<span style="color:#f92672">+</span>data[<span style="color:#ae81ff">3</span>][j];
    <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> n<span style="color:#f92672">*</span>n;
    <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,max <span style="color:#f92672">=</span>t;
    sort(ans1,ans1<span style="color:#f92672">+</span>t);
    sort(ans2,ans2<span style="color:#f92672">+</span>t);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>t;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//n^2的循环
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">int</span> target <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>ans1[i];
        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,right <span style="color:#f92672">=</span> t<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span>(left<span style="color:#f92672">&lt;=</span>right)<span style="color:#75715e">//二分找到起始点
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">int</span> middle <span style="color:#f92672">=</span> (right<span style="color:#f92672">+</span>left)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
            <span style="color:#66d9ef">if</span>(ans2[middle] <span style="color:#f92672">&gt;=</span> target)
            {
                min <span style="color:#f92672">=</span> middle;
                right <span style="color:#f92672">=</span> middle <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
            }
            <span style="color:#66d9ef">else</span>
                left <span style="color:#f92672">=</span> middle<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
        }
        <span style="color:#66d9ef">if</span> (ans2[min]<span style="color:#f92672">!=</span>target)
            <span style="color:#66d9ef">continue</span>;
        left <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        right <span style="color:#f92672">=</span> t<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span>(left<span style="color:#f92672">&lt;=</span>right)<span style="color:#75715e">//二分找到终点
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">int</span> middle <span style="color:#f92672">=</span> (right<span style="color:#f92672">+</span>left)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
            <span style="color:#66d9ef">if</span>(ans2[middle]<span style="color:#f92672">&lt;=</span>target)
            {
                max <span style="color:#f92672">=</span> middle;
                left <span style="color:#f92672">=</span> middle<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
            }
            <span style="color:#66d9ef">else</span>
            {
                right <span style="color:#f92672">=</span> middle<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
            }
        }
        count<span style="color:#f92672">+=</span>max<span style="color:#f92672">-</span>min<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
    }   
    printf(<span style="color:#e6db74">&#34;%d&#34;</span>,count);
}
</code></pre></div><h3 id="总结-4">总结<a hidden class="anchor" aria-hidden="true" href="#总结-4">#</a></h3>
<p>二分用来找东西方便,但是一定要有序,<strong>记得sort</strong></p>
<h2 id="c--tt的神秘礼物">C- TT的神秘礼物<a hidden class="anchor" aria-hidden="true" href="#c--tt的神秘礼物">#</a></h2>
<h3 id="题意-5">题意<a hidden class="anchor" aria-hidden="true" href="#题意-5">#</a></h3>
<p>给定一个含n个元素的数组A,运用A数组生成一个B数组,B中的元素为abs(A[i] - A[j])，1 &lt;= i &lt; j &lt;= n,然后找出B数组的中位数输出这个中位数</p>
<h3 id="解法-5">解法<a hidden class="anchor" aria-hidden="true" href="#解法-5">#</a></h3>
<p>这道题也是课上讲过的,核心思路是二分,而且是两个二分.</p>
<p>首先我们求中位数必然是在一个有序数列中,满足二分的条件,首先<strong>对a排序</strong>,因为构造b的时候有abs,因此不影响中位数,然后找出b的<strong>最小值0</strong>(注意这里的最小值是0不是a[1]-a[0]),和<strong>最大值a[n-1]-a[0]</strong>,让这两个最为边界进行二分,获得中间值mid.之后判断mid与中位数的情况,这里的判断是计算mid的名次,计算b中第一个大于mid的数前面有几个数,因为中位数的名次是知道的$(n*(n-1)/4+1)$.如果大于等于中位数则让max=mid,否则min=mid+1,然后这样循环下去直到max&lt;min.</p>
<p>如何求mid是第几个数成了新的问题,这里的解决方法还是二分,因为b中的元素是abs(A[i] - A[j]),则固定一个i,通过二分寻找第一个a[j]-a[i]大于mid的j,然后我们对i进行一次遍历就得到了mid是第几个元素,和给定的中位数名次比较就能操作max和min了.</p>
<h4 id="严谨一些的证明">严谨一些的证明<a hidden class="anchor" aria-hidden="true" href="#严谨一些的证明">#</a></h4>
<p>上述的描述虽然给出了解题的思路但是还没有给出一个比较严谨的证明.</p>
<p>对于第二部分二分来查找名次就不过多进行描述了,这就是最简单的那种二分,找一个端点,但是第一部分直接二分出答案还是需要稍微证明一下.</p>
<p>首先中位数的名次是固定的,但是和中位数相等的数可能有多个,同时在二分中会出现b中没有的数,下面讨论一下啊是如何准确二分到准确的答案的.</p>
<p><img src="https://i.loli.net/2020/03/17/sQkcSOUWyEn2q9N.png" alt=""></p>
<p>上图中x是中位数实际的值,还有一些二分出来的在b中不存在但是和x同名次的数.因为查找排名的原因,实际的x排名是大于中位数的排名的,因此存在一个问题,永远不会有mid名次就是中位数名次的事情.但是在二分中,我们是在mid&gt;=中位数时,更新max和ans(最终的答案),否则更新min,那么<strong>min&lt;=x</strong> <em>(因为x位置大于中位数,然后mid=x更新max,比x小的一个数名次小于中位数,min会变大)</em>,<strong>max&gt;=x</strong>(这个情况是对于mid未等于x前),这样一直迭代下去无论怎么更新都是满足上述条件的,最终max和min会向x靠近,最终max=min = x然后下一步max会小于min退出循环,最终ans必然等于x.不存在的数在右边,mid是向左边靠的,所以ans不会等于不存在的数.</p>
<p>后来又想了一下,还是学长上课讲的方法比较简单,我们提供一个check()函数,这个函数返回0或1,0代表mid名次小于中位数,1代表mid名次大于等于中位数名次,这样在0,1交界的位置的1就是我们要找的中位数,不存在的那些数虽然也是1,但是都是在中位数后面,不在交界位置</p>
<h4 id="复杂度">复杂度<a hidden class="anchor" aria-hidden="true" href="#复杂度">#</a></h4>
<p>最终的复杂度也是比较高的,check()函数的复杂度是$O(nlogn)$,在外面的那层二分的复杂度是$O(logB_{max})$,两者相乘是$O(nlogn\ logB_{max})$,因为数据范围比较大,读入需要用scanf</p>
<h3 id="code-5">code<a hidden class="anchor" aria-hidden="true" href="#code-5">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;algorithm&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> cat[<span style="color:#ae81ff">100002</span>];
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">int</span> cur,<span style="color:#66d9ef">int</span> tar,<span style="color:#66d9ef">int</span> n)<span style="color:#75715e">//排名,tar是中位数名次,cur是mid的值
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> s<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,e<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span>i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,right<span style="color:#f92672">=</span> n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">while</span>(left<span style="color:#f92672">&lt;=</span>right)<span style="color:#75715e">//二分找排名
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (left<span style="color:#f92672">+</span>right)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
            <span style="color:#66d9ef">if</span>(cur<span style="color:#f92672">&gt;=</span>(cat[mid]<span style="color:#f92672">-</span>cat[i]))
                left <span style="color:#f92672">=</span> mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
            <span style="color:#66d9ef">else</span>
                right <span style="color:#f92672">=</span> mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        }
        e <span style="color:#f92672">+=</span> left<span style="color:#f92672">-</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">if</span>(e<span style="color:#f92672">&gt;=</span>tar)<span style="color:#75715e">//大于等于返回1
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">else</span><span style="color:#75715e">//小于返回0
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> n;
    <span style="color:#66d9ef">while</span>(scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n)<span style="color:#f92672">!=</span>EOF)
    {  
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>)
            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,cat<span style="color:#f92672">+</span>i);
        sort(cat,cat<span style="color:#f92672">+</span>n);
        <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//最小值
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> cat[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> cat[<span style="color:#ae81ff">0</span>];
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (min<span style="color:#f92672">+</span>max)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">int</span> target <span style="color:#f92672">=</span> (((n<span style="color:#f92672">*</span>(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>))<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;<span style="color:#75715e">//中位数位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">while</span>(max<span style="color:#f92672">&gt;</span>min)<span style="color:#75715e">//结束条件
</span><span style="color:#75715e"></span>        {   
            mid <span style="color:#f92672">=</span> (min<span style="color:#f92672">+</span>max)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;      
            <span style="color:#66d9ef">if</span>(check(mid,target,n))
                ans <span style="color:#f92672">=</span> mid,max <span style="color:#f92672">=</span> mid;<span style="color:#75715e">//max不能减1因为退出条件是max&lt;=min,更新ans
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">else</span>
                min <span style="color:#f92672">=</span> mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>; 
        }
        printf(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,ans);
    }
}
</code></pre></div><h3 id="总结-5">总结<a hidden class="anchor" aria-hidden="true" href="#总结-5">#</a></h3>
<p>这道题我觉得出的非常好,让我对二分有了更深刻的理解,二分的left和right始终在一个条件附近徘徊,最终逼近这个答案,当left&gt;right退出时ans就满足了条件了.</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://example.org/tags/program/">Program</a></li>
      <li><a href="http://example.org/tags/homework/">homework</a></li>
    </ul>
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="http://example.org/">My New Hugo Site</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
