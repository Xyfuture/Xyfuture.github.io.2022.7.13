<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Program-week5-homework | My New Hugo Site</title>

<meta name="keywords" content="Program, homework" />
<meta name="description" content="week5-homework A-最大矩形 题意 给定一个直方图,求取直方图中规则的矩形的最大面积,其中直方图中间隔都是1,每个间隔的高度都是现场给定的.
解法 使用单调栈
对于每个间隔p,我们都在左边和右边找到第一个小于该间隔高度的间隔(如果相等则继续,不停止),在这两个边界之中,高度取p的高度建立的矩形是以p为高度的最大矩形,遍历一遍所有间隔就能获得整个图形中的最大矩形面积
求取左右的端点就是用单调栈实现,单调栈中保存的是从开始到现在所有的信息.对于一个出栈顺序是从小到大的单调栈而言,当一个元素弹出时,遇到的一定是第一个比他大的元素,因为假如之前遇到过比他的元素它早就被弹出了.反过来的顺序就是第一个它小的元素,我们大到小出栈顺序设计单调栈就可以实现我们上面的需求了.右边第一个是从0间隔到n间隔,左边第一个是从n间隔到0间隔 复杂度就是遍历一遍的大小$O(n)$
code #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std; int data[100004];//所有间隔的高度 int s[100004];//栈 int top = -1;//栈顶 pair&lt;int,int&gt; arr[100004];//左边第一个和右边第一个的坐标 int main() { int n; memset(data,0,sizeof(data)); memset(s,0,sizeof(s)); memset(arr,0,sizeof(arr)); while(true) { scanf(&#34;%d&#34;,&amp;n); if (n == 0) return 0; // data[0]=0,data[n&#43;1]=0;  for(int i=0;i&lt;n;i&#43;&#43;) scanf(&#34;%d&#34;,data&#43;i);//录入元素  for(int i=0;i&lt;n;i&#43;&#43;)//找到右边第一个小于的坐标  { while(top!=-1 &amp;&amp; data[s[top]]&gt;data[i])//不满足条件就出栈,同时更新出栈元素的边界  arr[s[top--]].second = i; s[&#43;&#43;top] = i;//新元素入栈  } while(top!=-1)//走到头把所有元素出栈  arr[s[top--]].second = n; top = -1;//重新开始栈  for(int i=n-1;i&gt;=0;i--)//左边第一个元素坐标,操作相同  { while(top!">
<meta name="author" content="">
<link rel="canonical" href="https://xyfuture.github.io/posts/program-week5-homework/" />
<link href="/assets/css/stylesheet.min.5c4f6d85b7abfcfea458637c672d16a7a9c38c37f002753cfdc7f314b6d3c8f2.css" integrity="sha256-XE9thber/P6kWGN8Zy0Wp6nDjDfwAnU8/cfzFLbTyPI=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://xyfuture.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://xyfuture.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://xyfuture.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://xyfuture.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://xyfuture.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />


<meta property="og:title" content="Program-week5-homework" />
<meta property="og:description" content="week5-homework A-最大矩形 题意 给定一个直方图,求取直方图中规则的矩形的最大面积,其中直方图中间隔都是1,每个间隔的高度都是现场给定的.
解法 使用单调栈
对于每个间隔p,我们都在左边和右边找到第一个小于该间隔高度的间隔(如果相等则继续,不停止),在这两个边界之中,高度取p的高度建立的矩形是以p为高度的最大矩形,遍历一遍所有间隔就能获得整个图形中的最大矩形面积
求取左右的端点就是用单调栈实现,单调栈中保存的是从开始到现在所有的信息.对于一个出栈顺序是从小到大的单调栈而言,当一个元素弹出时,遇到的一定是第一个比他大的元素,因为假如之前遇到过比他的元素它早就被弹出了.反过来的顺序就是第一个它小的元素,我们大到小出栈顺序设计单调栈就可以实现我们上面的需求了.右边第一个是从0间隔到n间隔,左边第一个是从n间隔到0间隔 复杂度就是遍历一遍的大小$O(n)$
code #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std; int data[100004];//所有间隔的高度 int s[100004];//栈 int top = -1;//栈顶 pair&lt;int,int&gt; arr[100004];//左边第一个和右边第一个的坐标 int main() { int n; memset(data,0,sizeof(data)); memset(s,0,sizeof(s)); memset(arr,0,sizeof(arr)); while(true) { scanf(&#34;%d&#34;,&amp;n); if (n == 0) return 0; // data[0]=0,data[n&#43;1]=0;  for(int i=0;i&lt;n;i&#43;&#43;) scanf(&#34;%d&#34;,data&#43;i);//录入元素  for(int i=0;i&lt;n;i&#43;&#43;)//找到右边第一个小于的坐标  { while(top!=-1 &amp;&amp; data[s[top]]&gt;data[i])//不满足条件就出栈,同时更新出栈元素的边界  arr[s[top--]].second = i; s[&#43;&#43;top] = i;//新元素入栈  } while(top!=-1)//走到头把所有元素出栈  arr[s[top--]].second = n; top = -1;//重新开始栈  for(int i=n-1;i&gt;=0;i--)//左边第一个元素坐标,操作相同  { while(top!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xyfuture.github.io/posts/program-week5-homework/" />
<meta property="article:published_time" content="2020-03-24T21:39:07+00:00" />
<meta property="article:modified_time" content="2020-03-24T21:39:07+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Program-week5-homework"/>
<meta name="twitter:description" content="week5-homework A-最大矩形 题意 给定一个直方图,求取直方图中规则的矩形的最大面积,其中直方图中间隔都是1,每个间隔的高度都是现场给定的.
解法 使用单调栈
对于每个间隔p,我们都在左边和右边找到第一个小于该间隔高度的间隔(如果相等则继续,不停止),在这两个边界之中,高度取p的高度建立的矩形是以p为高度的最大矩形,遍历一遍所有间隔就能获得整个图形中的最大矩形面积
求取左右的端点就是用单调栈实现,单调栈中保存的是从开始到现在所有的信息.对于一个出栈顺序是从小到大的单调栈而言,当一个元素弹出时,遇到的一定是第一个比他大的元素,因为假如之前遇到过比他的元素它早就被弹出了.反过来的顺序就是第一个它小的元素,我们大到小出栈顺序设计单调栈就可以实现我们上面的需求了.右边第一个是从0间隔到n间隔,左边第一个是从n间隔到0间隔 复杂度就是遍历一遍的大小$O(n)$
code #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std; int data[100004];//所有间隔的高度 int s[100004];//栈 int top = -1;//栈顶 pair&lt;int,int&gt; arr[100004];//左边第一个和右边第一个的坐标 int main() { int n; memset(data,0,sizeof(data)); memset(s,0,sizeof(s)); memset(arr,0,sizeof(arr)); while(true) { scanf(&#34;%d&#34;,&amp;n); if (n == 0) return 0; // data[0]=0,data[n&#43;1]=0;  for(int i=0;i&lt;n;i&#43;&#43;) scanf(&#34;%d&#34;,data&#43;i);//录入元素  for(int i=0;i&lt;n;i&#43;&#43;)//找到右边第一个小于的坐标  { while(top!=-1 &amp;&amp; data[s[top]]&gt;data[i])//不满足条件就出栈,同时更新出栈元素的边界  arr[s[top--]].second = i; s[&#43;&#43;top] = i;//新元素入栈  } while(top!=-1)//走到头把所有元素出栈  arr[s[top--]].second = n; top = -1;//重新开始栈  for(int i=n-1;i&gt;=0;i--)//左边第一个元素坐标,操作相同  { while(top!"/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Program-week5-homework",
  "name": "Program-week5-homework",
  "description": "week5-homework A-最大矩形 题意 给定一个直方图,求取直方图中规则的矩形的最大面积,其中直方图中间隔都是1,每个间隔的高度都是现场给定的.\n解法 使用单调栈\n对于每个间隔p,我们都在左边和右边找到第一个小于该间隔高度的间隔(如果相等则继续,不停止),在这两个边界之中,高度取p的高度建立的矩形是以p为高度的最大矩形,遍历一遍所有间隔就能获得整个 …",
  "keywords": [
    "Program", "homework"
  ],
  "articleBody": "week5-homework A-最大矩形 题意 给定一个直方图,求取直方图中规则的矩形的最大面积,其中直方图中间隔都是1,每个间隔的高度都是现场给定的.\n解法 使用单调栈\n对于每个间隔p,我们都在左边和右边找到第一个小于该间隔高度的间隔(如果相等则继续,不停止),在这两个边界之中,高度取p的高度建立的矩形是以p为高度的最大矩形,遍历一遍所有间隔就能获得整个图形中的最大矩形面积\n求取左右的端点就是用单调栈实现,单调栈中保存的是从开始到现在所有的信息.对于一个出栈顺序是从小到大的单调栈而言,当一个元素弹出时,遇到的一定是第一个比他大的元素,因为假如之前遇到过比他的元素它早就被弹出了.反过来的顺序就是第一个它小的元素,我们大到小出栈顺序设计单调栈就可以实现我们上面的需求了.右边第一个是从0间隔到n间隔,左边第一个是从n间隔到0间隔 复杂度就是遍历一遍的大小$O(n)$\ncode #include #include #include using namespace std; int data[100004];//所有间隔的高度 int s[100004];//栈 int top = -1;//栈顶 pairint,int arr[100004];//左边第一个和右边第一个的坐标 int main() { int n; memset(data,0,sizeof(data)); memset(s,0,sizeof(s)); memset(arr,0,sizeof(arr)); while(true) { scanf(\"%d\",\u0026n); if (n == 0) return 0; // data[0]=0,data[n+1]=0;  for(int i=0;in;i++) scanf(\"%d\",data+i);//录入元素  for(int i=0;in;i++)//找到右边第一个小于的坐标  { while(top!=-1 \u0026\u0026 data[s[top]]data[i])//不满足条件就出栈,同时更新出栈元素的边界  arr[s[top--]].second = i; s[++top] = i;//新元素入栈  } while(top!=-1)//走到头把所有元素出栈  arr[s[top--]].second = n; top = -1;//重新开始栈  for(int i=n-1;i=0;i--)//左边第一个元素坐标,操作相同  { while(top!=-1 \u0026\u0026 data[s[top]]data[i]) arr[s[top--]].first = i; s[++top] = i; } while(top!=-1) arr[s[top--]].first = -1; long long max = 0;//最大值超过了int 2e9,用long long  for(int i=0;in;i++) { long long temp = 1ll*(arr[i].second-arr[i].first-1)*data[i];//1ll使得乘法返回ll  if (tempmax)//更新最大  max = temp; } printf(\"%lld\\n\",max);//输出使用lld  top = -1; } } 总结 这道题思路上难度不大,但是我被卡住卡在了long long,一定要仔细看看题目要求的范围,很容易出现原始数据都是int,输出的结果却是long long的情况\nint 范围 -2147483648~2147483647 大约正负2e9\nlong long 范围 -9223372036854775809~9223372036854775807 大约9e18\n要是范围在大就得用高精啥的了,用字符串模拟实现\nB - TT’s Magic Cat 题意 这是一道差分的题目 题意大致是给定一个数组,然后我们在数组的一定范围内增加和减少一个确定的数,经过若干次操作后,我们输出最终的数组的各个元素的大小\n解法 差分的原理就是把一个求和的函数转换成了各个元素的大小,在数列上经常用,对于这道题而言差分能使得对一个区间内的操作转换成对两个元素的操作,大大降低复杂度.\n设给定的数组是S,我们取一个数组$B[i]=S[i]-S[i-1],S[i] = \\sum B[t]$,对S的区间(i,j)操作直接转为对B[i]和B[j+1]的操作\n最终把B累加起来就是S最终的答案\ncode #include #include #include using namespace std; long long sum[200005];//存和 long long per[200005];//存差分后的结果 int main() { memset(sum,0,sizeof(sum)); memset(per,0,sizeof(per)); int n,q; scanf(\"%d%d\",\u0026n,\u0026q); scanf(\"%lld\",\u0026sum[0]); per[0] = sum[0];//第一个不适用统一公式  for(int i=1;in;i++) { scanf(\"%lld\",sum+i); per[i] = sum[i]-sum[i-1];//求出差分后的结果  } long long a,b,c; for (int i=0;iq;i++) { scanf(\"%lld%lld%lld\",\u0026a,\u0026b,\u0026c);//读入操作  per[a-1]+=c;//差分直接操作  per[b]-=c; } sum[0] = per[0]; for(int i=1;in;i++)//求和求回去  sum[i] = sum[i-1]+per[i]; for(int i=0;in;i++) printf(\"%lld \",sum[i]); } 总结 这道题的问题还是数据范围,一开始全部用的int,交了好几遍发现不行,仔细一看数据范围又超了int,因此改用long long就过了,还是得分析一下数据的范围\nC - 平衡字符串 题意 现在有一个字符串,字符串中又QWER四种字母,现在要求任意替换字符串中的任意一部分(替换的部分长度要一致),使得这四种字母的出现次数一致\n解法 这道题是一道尺取的题目.\n首先我们取两个游标,l和r,r在前,l在后,当l,r中的元素满足条件时移动l,继续判断,当不满足条件和lr时令r移动\n条件的判断首先要求出(l,r)之外的区间QWER的数量,然后按照最多的数量,计算出需要在(l,r)中需要替换的数量,替换完后(l,r)之外的区间就满足条件了,然后再开(l,r)之中剩下的部分满不满足,只要看看剩下的部分能不能整除4就行了\n除此之外如果一上来就满足的情况需要单独判断一下,直接输出0\ncode #include #include #include #include #include using namespace std; int num[1000]; char data[100005]; char qwer[]={'Q','W','E','R'}; bool check(int l,int r,char data[])//检查条件 { int len = r-l+1;//区间长度  int temp[1000] ;//存一下当前区间的QWER  int curNum[1000] ;//区间外的QWER  memset(temp,0,sizeof(temp)); memset(curNum,0,sizeof(curNum)); for(int i=0;i4;i++) curNum[qwer[i]] = num[qwer[i]];//这里的数组的下标直接用字符的值  for(int i=l;ir;i++) temp[data[i]]++; for(int i=0;i4;i++) curNum[qwer[i]]-=temp[qwer[i]];//总的减去当前区间的就是区间外的  int max = curNum[qwer[0]]; for(int i=0;i4;i++) if(curNum[qwer[i]]max) max = curNum[qwer[i]];//找到区间外最多的字母的值  int all = 0;//需要补充多少  for (int i=0;i4;i++) all+=max-curNum[qwer[i]]; int free = r-l+1-all;//区间内剩下的  if(free%4 == 0 \u0026\u0026free=0)//能整除4满足条件  return true; else return false; } int main() { int l=0,r=0,ans=2000000000;//l,r是游标,ans是最终替换的数量  memset(data,0,sizeof(data)); scanf(\"%s\",data); int len = strlen(data); memset(num,0,sizeof(num)); for(int i=0;ilen;i++) num[data[i]]++;//录入直接用字符ascii当下标  if(num['Q']==num['W']\u0026\u0026num['E']==num['W']\u0026\u0026num['E']==num['R'])//直接满足  { cout'0'endl; return 0; } while(l!=len-1)//游标没有走完  { if(lr)//超了让r++  { r++; continue; } if(check(l,r,data))//检查条件  { ans = ansr-l+1?r-l+1:ans;//满足更新ans  l++;//左边前进  } else if(r==len-1)//到头了  l++; else//r,没到头  r++; } coutansendl; } 总结 这道题难度不是很大,直接按照课上讲的一步一步的来就行,但是因为是字母,定位下标的时候有点麻烦,一开始用QWER映射到0-3,这就需要一个循环来进行映射,但是这样会增加不少的复杂度,导致了超时,后来数组开大了,直接用ascii映射就直接O(1)存取了,这样就过了.这道题常数不能太大,否则还是不好过,用空间换时间还是不错的.\nD - 滑动窗口 题意 给定一个数组和一个窗口,窗口会一个格一个格地滑动,要求输出每一个窗口中的最大值和最小值\n解法 使用单调队列,可以求出一个区间内的最大值和最小值\n对于区间内的最大值而言,我们安排一个出队顺序是大到小的队列,然后每当我们要入队一个元素时我们检测队首的情况,如果队首在以入队元素为结尾的窗口内则队首就是窗口最大值,否则队首元素出队,继续判断直到找到最大值.\n最小值同理,换一个顺序安排队列就好了,这个方法的正确性和单调栈的证明类似,但是因为队首(栈底)能出队,所以可以运用于区间的情况.\ncode #include #include // #include  using namespace std; int data[1000005];//数组 int max[1000005];//最大值 int min[1000005];//最小值 int q[1000005];//队列 int front=0,back=-1; int main() { memset(data,0,sizeof(data)); memset(max,0,sizeof(max)); memset(min,0,sizeof(min)); memset(q,0,sizeof(q)); int k,n; scanf(\"%d%d\",\u0026n,\u0026k); for(int i=0;in;i++) scanf(\"%d\",data+i); q[++back] = 0;//先入队一个元素,其实没必要  for(int i=0;in;i++) { while(frontback\u0026\u0026q[front]i-k+1)//出队  front++; while(frontback\u0026\u0026data[q[back]]data[i])//入队检查  back--; q[++back] = i;//入队  max[i] = q[front]; } memset(q,0,sizeof(q)); front = 0,back = -1; q[++back] = 0;//类似,因为求两个方向  for(int i=0;in;i++) { while(frontback\u0026\u0026q[front]i-k+1) front++; while(frontback\u0026\u0026data[q[back]]=data[i]) back--; q[++back] = i; min[i] = q[front]; } for(int i=k-1;in;i++)//最大  printf(\"%d \",data[min[i]]); printf(\"\\n\"); for(int i=k-1;in;i++)//最小  printf(\"%d \",data[max[i]]); } 总结 这道题感觉有点神奇,用C++提交时输入输出是cstdio,结果用G++提交就T了,然而C++就用了5000ms,后来换了cin,cout关闭同步,再把memset去掉用在交G++,才过,而且用时8000ms,输入输出差异极大,cin和cout有时候在不同的编译器上体现有较大的差别,还得都试试\n",
  "wordCount" : "425",
  "inLanguage": "en",
  "datePublished": "2020-03-24T21:39:07Z",
  "dateModified": "2020-03-24T21:39:07Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://xyfuture.github.io/posts/program-week5-homework/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "My New Hugo Site",
    "logo": {
      "@type": "ImageObject",
      "url": "https://xyfuture.github.io/favicon.ico"
    }
  }
}
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        .theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://xyfuture.github.io/" accesskey="h" title="My New Hugo Site (Alt + H)">My New Hugo Site</a>
            <span class="logo-switches">
                <span class="theme-toggle" title="(Alt + T)">
                    <a id="theme-toggle" accesskey="t">
                        <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                        </svg>
                        <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                            fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round">
                            <circle cx="12" cy="12" r="5"></circle>
                            <line x1="12" y1="1" x2="12" y2="3"></line>
                            <line x1="12" y1="21" x2="12" y2="23"></line>
                            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                            <line x1="1" y1="12" x2="3" y2="12"></line>
                            <line x1="21" y1="12" x2="23" y2="12"></line>
                            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                        </svg>
                    </a>
                </span>
                
            </span>
        </div>
        <ul class="menu" id="menu" onscroll="menu_on_scroll()"></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">
      Program-week5-homework
    </h1>
    <div class="post-description">
      
    </div>
    <div class="post-meta">March 24, 2020

    </div>
  </header> 

  <div class="post-content">
<h1 id="week5-homework">week5-homework<a hidden class="anchor" aria-hidden="true" href="#week5-homework">#</a></h1>
<h2 id="a-最大矩形">A-最大矩形<a hidden class="anchor" aria-hidden="true" href="#a-最大矩形">#</a></h2>
<h3 id="题意">题意<a hidden class="anchor" aria-hidden="true" href="#题意">#</a></h3>
<p>给定一个直方图,求取直方图中规则的矩形的最大面积,其中直方图中间隔都是1,每个间隔的高度都是现场给定的.</p>
<h3 id="解法">解法<a hidden class="anchor" aria-hidden="true" href="#解法">#</a></h3>
<p>使用单调栈</p>
<p>对于每个间隔p,我们都在左边和右边找到第一个小于该间隔高度的间隔(如果相等则继续,不停止),在这两个边界之中,高度取p的高度建立的矩形是以p为高度的最大矩形,遍历一遍所有间隔就能获得整个图形中的最大矩形面积</p>
<p>求取左右的端点就是用单调栈实现,单调栈中保存的是从开始到现在所有的信息.对于一个出栈顺序是从小到大的单调栈而言,当一个元素弹出时,遇到的一定是第一个比他大的元素,因为假如之前遇到过比他的元素它早就被弹出了.反过来的顺序就是第一个它小的元素,我们大到小出栈顺序设计单调栈就可以实现我们上面的需求了.右边第一个是从0间隔到n间隔,左边第一个是从n间隔到0间隔
复杂度就是遍历一遍的大小$O(n)$</p>
<h3 id="code">code<a hidden class="anchor" aria-hidden="true" href="#code">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span>  <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> data[<span style="color:#ae81ff">100004</span>];<span style="color:#75715e">//所有间隔的高度
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> s[<span style="color:#ae81ff">100004</span>];<span style="color:#75715e">//栈
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> top <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//栈顶
</span><span style="color:#75715e"></span>pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> arr[<span style="color:#ae81ff">100004</span>];<span style="color:#75715e">//左边第一个和右边第一个的坐标
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> n;
    memset(data,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(data));
    memset(s,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(s));
    memset(arr,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(arr));
    <span style="color:#66d9ef">while</span>(true)
    {
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>n);
        <span style="color:#66d9ef">if</span> (n <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>)
            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#75715e">// data[0]=0,data[n+1]=0;
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
            scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,data<span style="color:#f92672">+</span>i);<span style="color:#75715e">//录入元素
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//找到右边第一个小于的坐标
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">while</span>(top<span style="color:#f92672">!=-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> data[s[top]]<span style="color:#f92672">&gt;</span>data[i])<span style="color:#75715e">//不满足条件就出栈,同时更新出栈元素的边界
</span><span style="color:#75715e"></span>                arr[s[top<span style="color:#f92672">--</span>]].second <span style="color:#f92672">=</span> i;
            s[<span style="color:#f92672">++</span>top] <span style="color:#f92672">=</span> i;<span style="color:#75715e">//新元素入栈
</span><span style="color:#75715e"></span>        }
        <span style="color:#66d9ef">while</span>(top<span style="color:#f92672">!=-</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//走到头把所有元素出栈
</span><span style="color:#75715e"></span>            arr[s[top<span style="color:#f92672">--</span>]].second <span style="color:#f92672">=</span> n;
        top <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//重新开始栈
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>)<span style="color:#75715e">//左边第一个元素坐标,操作相同
</span><span style="color:#75715e"></span>        {
            <span style="color:#66d9ef">while</span>(top<span style="color:#f92672">!=-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> data[s[top]]<span style="color:#f92672">&gt;</span>data[i])
                arr[s[top<span style="color:#f92672">--</span>]].first <span style="color:#f92672">=</span> i;
            s[<span style="color:#f92672">++</span>top] <span style="color:#f92672">=</span> i;
        }
        <span style="color:#66d9ef">while</span>(top<span style="color:#f92672">!=-</span><span style="color:#ae81ff">1</span>)
            arr[s[top<span style="color:#f92672">--</span>]].first <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> max <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//最大值超过了int 2e9,用long long
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
        {
            <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> temp <span style="color:#f92672">=</span> <span style="color:#ae81ff">1ll</span><span style="color:#f92672">*</span>(arr[i].second<span style="color:#f92672">-</span>arr[i].first<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span>data[i];<span style="color:#75715e">//1ll使得乘法返回ll
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (temp<span style="color:#f92672">&gt;</span>max)<span style="color:#75715e">//更新最大
</span><span style="color:#75715e"></span>                max <span style="color:#f92672">=</span> temp;
        }
        printf(<span style="color:#e6db74">&#34;%lld</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,max);<span style="color:#75715e">//输出使用lld
</span><span style="color:#75715e"></span>        top <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    }
}
</code></pre></div><h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<p>这道题思路上难度不大,但是我被卡住卡在了long long,一定要仔细看看题目要求的范围,很容易出现<strong>原始数据都是int,输出的结果却是long long</strong>的情况</p>
<p>int 范围  -2147483648~2147483647 大约正负2e9</p>
<p>long long 范围 -9223372036854775809~9223372036854775807 大约9e18</p>
<p>要是范围在大就得用高精啥的了,用字符串模拟实现</p>
<h2 id="b---tts-magic-cat">B - TT&rsquo;s Magic Cat<a hidden class="anchor" aria-hidden="true" href="#b---tts-magic-cat">#</a></h2>
<h3 id="题意-1">题意<a hidden class="anchor" aria-hidden="true" href="#题意-1">#</a></h3>
<p>这是一道差分的题目
题意大致是给定一个数组,然后我们在数组的一定范围内增加和减少一个确定的数,经过若干次操作后,我们输出最终的数组的各个元素的大小</p>
<h3 id="解法-1">解法<a hidden class="anchor" aria-hidden="true" href="#解法-1">#</a></h3>
<p>差分的原理就是把一个求和的函数转换成了各个元素的大小,在数列上经常用,对于这道题而言差分能使得对一个区间内的操作转换成对两个元素的操作,大大降低复杂度.</p>
<p>设给定的数组是S,我们取一个数组$B[i]=S[i]-S[i-1],S[i] = \sum B[t]$,对S的区间(i,j)操作直接转为对B[i]和B[j+1]的操作</p>
<p>最终把B累加起来就是S最终的答案</p>
<h3 id="code-1">code<a hidden class="anchor" aria-hidden="true" href="#code-1">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span>  <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> sum[<span style="color:#ae81ff">200005</span>];<span style="color:#75715e">//存和
</span><span style="color:#75715e"></span><span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> per[<span style="color:#ae81ff">200005</span>];<span style="color:#75715e">//存差分后的结果
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    memset(sum,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(sum));
    memset(per,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(per));
    <span style="color:#66d9ef">int</span> n,q;
    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>n,<span style="color:#f92672">&amp;</span>q);
    scanf(<span style="color:#e6db74">&#34;%lld&#34;</span>,<span style="color:#f92672">&amp;</span>sum[<span style="color:#ae81ff">0</span>]);
    per[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> sum[<span style="color:#ae81ff">0</span>];<span style="color:#75715e">//第一个不适用统一公式
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
    {
        scanf(<span style="color:#e6db74">&#34;%lld&#34;</span>,sum<span style="color:#f92672">+</span>i);
        per[i] <span style="color:#f92672">=</span> sum[i]<span style="color:#f92672">-</span>sum[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>];<span style="color:#75715e">//求出差分后的结果
</span><span style="color:#75715e"></span>    }
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> a,b,c;
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>q;i<span style="color:#f92672">++</span>)
    {
        scanf(<span style="color:#e6db74">&#34;%lld%lld%lld&#34;</span>,<span style="color:#f92672">&amp;</span>a,<span style="color:#f92672">&amp;</span>b,<span style="color:#f92672">&amp;</span>c);<span style="color:#75715e">//读入操作
</span><span style="color:#75715e"></span>        per[a<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+=</span>c;<span style="color:#75715e">//差分直接操作
</span><span style="color:#75715e"></span>        per[b]<span style="color:#f92672">-=</span>c;
    }
    sum[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> per[<span style="color:#ae81ff">0</span>];
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//求和求回去
</span><span style="color:#75715e"></span>        sum[i] <span style="color:#f92672">=</span> sum[i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">+</span>per[i];
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
        printf(<span style="color:#e6db74">&#34;%lld &#34;</span>,sum[i]);
}
</code></pre></div><h3 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h3>
<p>这道题的问题还是数据范围,一开始全部用的int,交了好几遍发现不行,仔细一看数据范围又超了int,因此改用long long就过了,还是得分析一下数据的范围</p>
<h2 id="c---平衡字符串">C - 平衡字符串<a hidden class="anchor" aria-hidden="true" href="#c---平衡字符串">#</a></h2>
<h3 id="题意-2">题意<a hidden class="anchor" aria-hidden="true" href="#题意-2">#</a></h3>
<p>现在有一个字符串,字符串中又QWER四种字母,现在要求任意替换字符串中的任意一部分(替换的部分长度要一致),使得这四种字母的出现次数一致</p>
<h3 id="解法-2">解法<a hidden class="anchor" aria-hidden="true" href="#解法-2">#</a></h3>
<p>这道题是一道尺取的题目.</p>
<p>首先我们取两个游标,l和r,r在前,l在后,当l,r中的元素满足条件时移动l,继续判断,当不满足条件和l&gt;r时令r移动</p>
<p>条件的判断首先要求出(l,r)之外的区间QWER的数量,然后按照最多的数量,计算出需要在(l,r)中需要替换的数量,替换完后(l,r)之外的区间就满足条件了,然后再开(l,r)之中剩下的部分满不满足,只要看看剩下的部分能不能整除4就行了</p>
<p>除此之外如果一上来就满足的情况需要单独判断一下,直接输出0</p>
<h3 id="code-2">code<a hidden class="anchor" aria-hidden="true" href="#code-2">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cmath&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> num[<span style="color:#ae81ff">1000</span>];
<span style="color:#66d9ef">char</span> data[<span style="color:#ae81ff">100005</span>];
<span style="color:#66d9ef">char</span> qwer[]<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#39;Q&#39;</span>,<span style="color:#e6db74">&#39;W&#39;</span>,<span style="color:#e6db74">&#39;E&#39;</span>,<span style="color:#e6db74">&#39;R&#39;</span>};
<span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">int</span> l,<span style="color:#66d9ef">int</span> r,<span style="color:#66d9ef">char</span> data[])<span style="color:#75715e">//检查条件
</span><span style="color:#75715e"></span>{
    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//区间长度
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> temp[<span style="color:#ae81ff">1000</span>] ;<span style="color:#75715e">//存一下当前区间的QWER
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> curNum[<span style="color:#ae81ff">1000</span>] ;<span style="color:#75715e">//区间外的QWER
</span><span style="color:#75715e"></span>
    memset(temp,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(temp));
    memset(curNum,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(curNum));

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>;i<span style="color:#f92672">++</span>)
        curNum[qwer[i]] <span style="color:#f92672">=</span> num[qwer[i]];<span style="color:#75715e">//这里的数组的下标直接用字符的值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>l;i<span style="color:#f92672">&lt;=</span>r;i<span style="color:#f92672">++</span>)
        temp[data[i]]<span style="color:#f92672">++</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>;i<span style="color:#f92672">++</span>)
        curNum[qwer[i]]<span style="color:#f92672">-=</span>temp[qwer[i]];<span style="color:#75715e">//总的减去当前区间的就是区间外的
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> max <span style="color:#f92672">=</span> curNum[qwer[<span style="color:#ae81ff">0</span>]];
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>;i<span style="color:#f92672">++</span>)
        <span style="color:#66d9ef">if</span>(curNum[qwer[i]]<span style="color:#f92672">&gt;</span>max)
            max <span style="color:#f92672">=</span> curNum[qwer[i]];<span style="color:#75715e">//找到区间外最多的字母的值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> all <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//需要补充多少
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">4</span>;i<span style="color:#f92672">++</span>)
        all<span style="color:#f92672">+=</span>max<span style="color:#f92672">-</span>curNum[qwer[i]];
    <span style="color:#66d9ef">int</span> free <span style="color:#f92672">=</span> r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>all;<span style="color:#75715e">//区间内剩下的
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(free<span style="color:#f92672">%</span><span style="color:#ae81ff">4</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span>free<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>)<span style="color:#75715e">//能整除4满足条件
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> true;
    <span style="color:#66d9ef">else</span>
        <span style="color:#66d9ef">return</span> false;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    <span style="color:#66d9ef">int</span> l<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,r<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,ans<span style="color:#f92672">=</span><span style="color:#ae81ff">2000000000</span>;<span style="color:#75715e">//l,r是游标,ans是最终替换的数量  
</span><span style="color:#75715e"></span>    memset(data,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(data));
    scanf(<span style="color:#e6db74">&#34;%s&#34;</span>,data);
    <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> strlen(data);
    memset(num,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(num));
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>len;i<span style="color:#f92672">++</span>)
        num[data[i]]<span style="color:#f92672">++</span>;<span style="color:#75715e">//录入直接用字符ascii当下标
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(num[<span style="color:#e6db74">&#39;Q&#39;</span>]<span style="color:#f92672">==</span>num[<span style="color:#e6db74">&#39;W&#39;</span>]<span style="color:#f92672">&amp;&amp;</span>num[<span style="color:#e6db74">&#39;E&#39;</span>]<span style="color:#f92672">==</span>num[<span style="color:#e6db74">&#39;W&#39;</span>]<span style="color:#f92672">&amp;&amp;</span>num[<span style="color:#e6db74">&#39;E&#39;</span>]<span style="color:#f92672">==</span>num[<span style="color:#e6db74">&#39;R&#39;</span>])<span style="color:#75715e">//直接满足
</span><span style="color:#75715e"></span>    {
        cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#39;0&#39;</span><span style="color:#f92672">&lt;&lt;</span>endl;
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
    <span style="color:#66d9ef">while</span>(l<span style="color:#f92672">!=</span>len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//游标没有走完
</span><span style="color:#75715e"></span>    {
        <span style="color:#66d9ef">if</span>(l<span style="color:#f92672">&gt;</span>r)<span style="color:#75715e">//超了让r++
</span><span style="color:#75715e"></span>        {
            r<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">continue</span>;
        }
        <span style="color:#66d9ef">if</span>(check(l,r,data))<span style="color:#75715e">//检查条件
</span><span style="color:#75715e"></span>        {
            ans <span style="color:#f92672">=</span> ans<span style="color:#f92672">&gt;</span>r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">?</span>r<span style="color:#f92672">-</span>l<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span>ans;<span style="color:#75715e">//满足更新ans
</span><span style="color:#75715e"></span>            l<span style="color:#f92672">++</span>;<span style="color:#75715e">//左边前进
</span><span style="color:#75715e"></span>        }
        <span style="color:#66d9ef">else</span>
            <span style="color:#66d9ef">if</span>(r<span style="color:#f92672">==</span>len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//到头了
</span><span style="color:#75715e"></span>                l<span style="color:#f92672">++</span>;
            <span style="color:#66d9ef">else</span><span style="color:#75715e">//r,没到头
</span><span style="color:#75715e"></span>                r<span style="color:#f92672">++</span>;        
    }
    cout<span style="color:#f92672">&lt;&lt;</span>ans<span style="color:#f92672">&lt;&lt;</span>endl;
}
</code></pre></div><h3 id="总结-2">总结<a hidden class="anchor" aria-hidden="true" href="#总结-2">#</a></h3>
<p>这道题难度不是很大,直接按照课上讲的一步一步的来就行,但是因为是字母,定位下标的时候有点麻烦,一开始用QWER映射到0-3,这就需要一个循环来进行映射,但是这样会增加不少的复杂度,导致了超时,后来数组开大了,直接用ascii映射就直接O(1)存取了,这样就过了.这道题常数不能太大,否则还是不好过,用空间换时间还是不错的.</p>
<h3 id="d---滑动窗口">D - 滑动窗口<a hidden class="anchor" aria-hidden="true" href="#d---滑动窗口">#</a></h3>
<h3 id="题意-3">题意<a hidden class="anchor" aria-hidden="true" href="#题意-3">#</a></h3>
<p>给定一个数组和一个窗口,窗口会一个格一个格地滑动,要求输出每一个窗口中的最大值和最小值</p>
<h3 id="解法-3">解法<a hidden class="anchor" aria-hidden="true" href="#解法-3">#</a></h3>
<p>使用单调队列,可以求出一个区间内的最大值和最小值</p>
<p>对于区间内的最大值而言,我们安排一个出队顺序是大到小的队列,然后每当我们要入队一个元素时我们检测队首的情况,如果队首在以入队元素为结尾的窗口内则队首就是窗口最大值,否则队首元素出队,继续判断直到找到最大值.</p>
<p>最小值同理,换一个顺序安排队列就好了,这个方法的正确性和单调栈的证明类似,但是因为队首(栈底)能出队,所以可以运用于区间的情况.</p>
<h3 id="code-3">code<a hidden class="anchor" aria-hidden="true" href="#code-3">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;cstdio&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span>  <span style="color:#75715e">&lt;cstring&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#75715e">// #include &lt;iostream&gt;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> data[<span style="color:#ae81ff">1000005</span>];<span style="color:#75715e">//数组
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> max[<span style="color:#ae81ff">1000005</span>];<span style="color:#75715e">//最大值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> min[<span style="color:#ae81ff">1000005</span>];<span style="color:#75715e">//最小值
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> q[<span style="color:#ae81ff">1000005</span>];<span style="color:#75715e">//队列
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> front<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,back<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    memset(data,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(data));
    memset(max,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(max));
    memset(min,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(min));
    memset(q,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(q));

    <span style="color:#66d9ef">int</span> k,n;
    scanf(<span style="color:#e6db74">&#34;%d%d&#34;</span>,<span style="color:#f92672">&amp;</span>n,<span style="color:#f92672">&amp;</span>k);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
        scanf(<span style="color:#e6db74">&#34;%d&#34;</span>,data<span style="color:#f92672">+</span>i);
    q[<span style="color:#f92672">++</span>back] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//先入队一个元素,其实没必要
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">while</span>(front<span style="color:#f92672">&lt;=</span>back<span style="color:#f92672">&amp;&amp;</span>q[front]<span style="color:#f92672">&lt;</span>i<span style="color:#f92672">-</span>k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#75715e">//出队
</span><span style="color:#75715e"></span>            front<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">while</span>(front<span style="color:#f92672">&lt;=</span>back<span style="color:#f92672">&amp;&amp;</span>data[q[back]]<span style="color:#f92672">&lt;=</span>data[i])<span style="color:#75715e">//入队检查
</span><span style="color:#75715e"></span>            back<span style="color:#f92672">--</span>;
        q[<span style="color:#f92672">++</span>back] <span style="color:#f92672">=</span> i;<span style="color:#75715e">//入队
</span><span style="color:#75715e"></span>        max[i] <span style="color:#f92672">=</span> q[front];
    } 
    memset(q,<span style="color:#ae81ff">0</span>,<span style="color:#66d9ef">sizeof</span>(q));
    front <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,back <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
    q[<span style="color:#f92672">++</span>back] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//类似,因为求两个方向
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)
    {
        <span style="color:#66d9ef">while</span>(front<span style="color:#f92672">&lt;=</span>back<span style="color:#f92672">&amp;&amp;</span>q[front]<span style="color:#f92672">&lt;</span>i<span style="color:#f92672">-</span>k<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
            front<span style="color:#f92672">++</span>;
        <span style="color:#66d9ef">while</span>(front<span style="color:#f92672">&lt;=</span>back<span style="color:#f92672">&amp;&amp;</span>data[q[back]]<span style="color:#f92672">&gt;=</span>data[i])
            back<span style="color:#f92672">--</span>;
        q[<span style="color:#f92672">++</span>back] <span style="color:#f92672">=</span> i;
        min[i] <span style="color:#f92672">=</span> q[front];
    } 
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//最大
</span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;%d &#34;</span>,data[min[i]]);
    printf(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>n;i<span style="color:#f92672">++</span>)<span style="color:#75715e">//最小
</span><span style="color:#75715e"></span>        printf(<span style="color:#e6db74">&#34;%d &#34;</span>,data[max[i]]);
}
</code></pre></div><h3 id="总结-3">总结<a hidden class="anchor" aria-hidden="true" href="#总结-3">#</a></h3>
<p>这道题感觉有点神奇,用C++提交时输入输出是cstdio,结果用G++提交就T了,然而C++就用了5000ms,后来换了cin,cout关闭同步,再把memset去掉用在交G++,才过,而且用时8000ms,输入输出差异极大,cin和cout有时候在不同的编译器上体现有较大的差别,还得都试试</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://xyfuture.github.io/tags/program/">Program</a></li>
      <li><a href="https://xyfuture.github.io/tags/homework/">homework</a></li>
    </ul>
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://xyfuture.github.io/">My New Hugo Site</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }
    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.replaceState(null, null, `#${id}`);
            }
        });
    });
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
